{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"children\", \"className\"],\n  _excluded2 = [\"user\"],\n  _excluded3 = [\"typing\"];\nimport React, { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState } from 'react';\nimport clsx from 'clsx';\nimport debounce from 'lodash.debounce';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport throttle from 'lodash.throttle';\nimport { localMessageToNewMessagePayload } from 'stream-chat';\nimport { initialState, makeChannelReducer } from './channelState';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { ChannelActionProvider, ChannelStateProvider, TypingProvider, useChatContext, useTranslationContext, WithComponents } from '../../context';\nimport { CHANNEL_CONTAINER_ID } from './constants';\nimport { DEFAULT_HIGHLIGHT_DURATION, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_JUMP_TO_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE } from '../../constants/limits';\nimport { hasMoreMessagesProbably } from '../MessageList';\nimport { getChatContainerClass, useChannelContainerClasses, useImageFlagEmojisOnWindowsClass } from './hooks/useChannelContainerClasses';\nimport { findInMsgSetByDate, findInMsgSetById, makeAddNotifications } from './utils';\nimport { useThreadContext } from '../Threads';\nimport { getChannel } from '../../utils';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration } from '../Attachment/attachment-sizing';\nimport { useSearchFocusedMessage } from '../../experimental/Search/hooks';\nconst ChannelContainer = _ref => {\n  let {\n      children,\n      className: additionalClassName\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const {\n    customClasses,\n    theme\n  } = useChatContext('Channel');\n  const {\n    channelClass,\n    chatClass\n  } = useChannelContainerClasses({\n    customClasses\n  });\n  const className = clsx(chatClass, theme, channelClass, additionalClassName);\n  return React.createElement(\"div\", _objectSpread(_objectSpread({\n    id: CHANNEL_CONTAINER_ID\n  }, props), {}, {\n    className: className\n  }), children);\n};\nconst UnMemoizedChannel = props => {\n  const {\n    channel: propsChannel,\n    EmptyPlaceholder = null,\n    LoadingErrorIndicator,\n    LoadingIndicator = DefaultLoadingIndicator\n  } = props;\n  const {\n    channel: contextChannel,\n    channelsQueryState\n  } = useChatContext('Channel');\n  const channel = propsChannel || contextChannel;\n  if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingIndicator, null));\n  }\n  if (channelsQueryState.error && LoadingErrorIndicator) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingErrorIndicator, {\n      error: channelsQueryState.error\n    }));\n  }\n  if (!(channel !== null && channel !== void 0 && channel.cid)) {\n    return React.createElement(ChannelContainer, null, EmptyPlaceholder);\n  }\n  return React.createElement(ChannelInner, _objectSpread(_objectSpread({}, props), {}, {\n    channel: channel,\n    key: channel.cid\n  }));\n};\nconst ChannelInner = props => {\n  var _channel$data;\n  const {\n    activeUnreadHandler,\n    channel,\n    channelQueryOptions: propChannelQueryOptions,\n    children,\n    doDeleteMessageRequest,\n    doMarkReadRequest,\n    doSendMessageRequest,\n    doUpdateMessageRequest,\n    initializeOnMount = true,\n    LoadingErrorIndicator = DefaultLoadingErrorIndicator,\n    LoadingIndicator = DefaultLoadingIndicator,\n    markReadOnMount = true,\n    onMentionsClick,\n    onMentionsHover,\n    skipMessageDataMemoization\n  } = props;\n  const channelQueryOptions = useMemo(() => defaultsDeep(propChannelQueryOptions, {\n    messages: {\n      limit: DEFAULT_INITIAL_CHANNEL_PAGE_SIZE\n    }\n  }), [propChannelQueryOptions]);\n  const {\n    client,\n    customClasses,\n    latestMessageDatesByChannels,\n    mutes,\n    searchController\n  } = useChatContext('Channel');\n  const {\n    t\n  } = useTranslationContext('Channel');\n  const chatContainerClass = getChatContainerClass(customClasses === null || customClasses === void 0 ? void 0 : customClasses.chatContainer);\n  const windowsEmojiClass = useImageFlagEmojisOnWindowsClass();\n  const thread = useThreadContext();\n  const [channelConfig, setChannelConfig] = useState(channel.getConfig());\n  const [notifications, setNotifications] = useState([]);\n  const notificationTimeouts = useRef([]);\n  const [channelUnreadUiState, _setChannelUnreadUiState] = useState();\n  const channelReducer = useMemo(() => makeChannelReducer(), []);\n  const [state, dispatch] = useReducer(channelReducer, // channel.initialized === false if client.channel().query() was not called, e.g. ChannelList is not used\n  // => Channel will call channel.watch() in useLayoutEffect => state.loading is used to signal the watch() call state\n  _objectSpread(_objectSpread({}, initialState), {}, {\n    hasMore: channel.state.messagePagination.hasPrev,\n    loading: !channel.initialized,\n    messages: channel.state.messages\n  }));\n  const jumpToMessageFromSearch = useSearchFocusedMessage();\n  const isMounted = useIsMounted();\n  const originalTitle = useRef('');\n  const lastRead = useRef(undefined);\n  const online = useRef(true);\n  const clearHighlightedMessageTimeoutId = useRef(null);\n  const channelCapabilitiesArray = (_channel$data = channel.data) === null || _channel$data === void 0 ? void 0 : _channel$data.own_capabilities;\n  const throttledCopyStateFromChannel = throttle(() => dispatch({\n    channel,\n    type: 'copyStateFromChannelOnEvent'\n  }), 500, {\n    leading: true,\n    trailing: true\n  });\n  const setChannelUnreadUiState = useMemo(() => throttle(_setChannelUnreadUiState, 200, {\n    leading: true,\n    trailing: false\n  }), []);\n  const markRead = useMemo(() => throttle(async options => {\n    const {\n      updateChannelUiUnreadState = true\n    } = options !== null && options !== void 0 ? options : {};\n    if (channel.disconnected || !(channelConfig !== null && channelConfig !== void 0 && channelConfig.read_events)) {\n      return;\n    }\n    lastRead.current = new Date();\n    try {\n      if (doMarkReadRequest) {\n        doMarkReadRequest(channel, updateChannelUiUnreadState ? setChannelUnreadUiState : undefined);\n      } else {\n        const markReadResponse = await channel.markRead();\n        if (updateChannelUiUnreadState && markReadResponse) {\n          _setChannelUnreadUiState({\n            last_read: lastRead.current,\n            last_read_message_id: markReadResponse.event.last_read_message_id,\n            unread_messages: 0\n          });\n        }\n      }\n      if (activeUnreadHandler) {\n        activeUnreadHandler(0, originalTitle.current);\n      } else if (originalTitle.current) {\n        document.title = originalTitle.current;\n      }\n    } catch (e) {\n      console.error(t('Failed to mark channel as read'));\n    }\n  }, 500, {\n    leading: true,\n    trailing: false\n  }), [activeUnreadHandler, channel, channelConfig, doMarkReadRequest, setChannelUnreadUiState, t]);\n  const handleEvent = async event => {\n    if (event.message) {\n      dispatch({\n        channel,\n        message: event.message,\n        type: 'updateThreadOnEvent'\n      });\n    }\n    if (event.type === 'user.watching.start' || event.type === 'user.watching.stop') return;\n    if (event.type === 'typing.start' || event.type === 'typing.stop') {\n      return dispatch({\n        channel,\n        type: 'setTyping'\n      });\n    }\n    if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n      online.current = event.online;\n    }\n    if (event.type === 'message.new') {\n      var _event$message, _event$message2, _event$message3, _event$message4, _event$message5;\n      const mainChannelUpdated = !((_event$message = event.message) !== null && _event$message !== void 0 && _event$message.parent_id) || ((_event$message2 = event.message) === null || _event$message2 === void 0 ? void 0 : _event$message2.show_in_channel);\n      if (mainChannelUpdated) {\n        if (document.hidden && channelConfig !== null && channelConfig !== void 0 && channelConfig.read_events && !channel.muteStatus().muted) {\n          const unread = channel.countUnread(lastRead.current);\n          if (activeUnreadHandler) {\n            activeUnreadHandler(unread, originalTitle.current);\n          } else {\n            document.title = \"(\".concat(unread, \") \").concat(originalTitle.current);\n          }\n        }\n      }\n      if (((_event$message3 = event.message) === null || _event$message3 === void 0 || (_event$message3 = _event$message3.user) === null || _event$message3 === void 0 ? void 0 : _event$message3.id) === client.userID && event !== null && event !== void 0 && (_event$message4 = event.message) !== null && _event$message4 !== void 0 && _event$message4.created_at && event !== null && event !== void 0 && (_event$message5 = event.message) !== null && _event$message5 !== void 0 && _event$message5.cid) {\n        const messageDate = new Date(event.message.created_at);\n        const cid = event.message.cid;\n        if (!latestMessageDatesByChannels[cid] || latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n          latestMessageDatesByChannels[cid] = messageDate;\n        }\n      }\n    }\n    if (event.type === 'user.deleted') {\n      var _channel$state;\n      const oldestID = (_channel$state = channel.state) === null || _channel$state === void 0 || (_channel$state = _channel$state.messages) === null || _channel$state === void 0 || (_channel$state = _channel$state[0]) === null || _channel$state === void 0 ? void 0 : _channel$state.id;\n      /**\n       * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n       */\n      // FIXME: we should use channelQueryOptions if they are available\n      await channel.query({\n        messages: {\n          id_lt: oldestID,\n          limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n        },\n        watchers: {\n          limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE\n        }\n      });\n    }\n    if (event.type === 'notification.mark_unread') _setChannelUnreadUiState(prev => {\n      var _event$unread_message;\n      if (!(event.last_read_at && event.user)) return prev;\n      return {\n        first_unread_message_id: event.first_unread_message_id,\n        last_read: new Date(event.last_read_at),\n        last_read_message_id: event.last_read_message_id,\n        unread_messages: (_event$unread_message = event.unread_messages) !== null && _event$unread_message !== void 0 ? _event$unread_message : 0\n      };\n    });\n    if (event.type === 'channel.truncated' && event.cid === channel.cid) {\n      _setChannelUnreadUiState(undefined);\n    }\n    throttledCopyStateFromChannel();\n  };\n  // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n  useLayoutEffect(() => {\n    let errored = false;\n    let done = false;\n    (async () => {\n      if (!channel.initialized && initializeOnMount) {\n        try {\n          var _channel$data2;\n          // if active channel has been set without id, we will create a temporary channel id from its member IDs\n          // to keep track of the /query request in progress. This is the same approach of generating temporary id\n          // that the JS client uses to keep track of channel in client.activeChannels\n          const members = [];\n          if (!channel.id && (_channel$data2 = channel.data) !== null && _channel$data2 !== void 0 && _channel$data2.members) {\n            for (const member of channel.data.members) {\n              let userId;\n              if (typeof member === 'string') {\n                userId = member;\n              } else if (typeof member === 'object') {\n                const {\n                  user,\n                  user_id\n                } = member;\n                userId = user_id || (user === null || user === void 0 ? void 0 : user.id);\n              }\n              if (userId) {\n                members.push(userId);\n              }\n            }\n          }\n          await getChannel({\n            channel,\n            client,\n            members,\n            options: channelQueryOptions\n          });\n          const config = channel.getConfig();\n          setChannelConfig(config);\n        } catch (e) {\n          dispatch({\n            error: e,\n            type: 'setError'\n          });\n          errored = true;\n        }\n      }\n      done = true;\n      originalTitle.current = document.title;\n      if (!errored) {\n        var _client$user;\n        dispatch({\n          channel,\n          hasMore: channel.state.messagePagination.hasPrev,\n          type: 'initStateFromChannel'\n        });\n        if ((_client$user = client.user) !== null && _client$user !== void 0 && _client$user.id && channel.state.read[client.user.id]) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const _channel$state$read$c = channel.state.read[client.user.id],\n            {\n              user\n            } = _channel$state$read$c,\n            ownReadState = _objectWithoutProperties(_channel$state$read$c, _excluded2);\n          _setChannelUnreadUiState(ownReadState);\n        }\n        /**\n         * TODO: maybe pass last_read to the countUnread method to get proper value\n         * combined with channel.countUnread adjustment (_countMessageAsUnread)\n         * to allow counting own messages too\n         *\n         * const lastRead = channel.state.read[client.userID as string].last_read;\n         */\n        if (channel.countUnread() > 0 && markReadOnMount) markRead({\n          updateChannelUiUnreadState: false\n        });\n        // The more complex sync logic is done in Chat\n        client.on('connection.changed', handleEvent);\n        client.on('connection.recovered', handleEvent);\n        client.on('user.updated', handleEvent);\n        client.on('user.deleted', handleEvent);\n        channel.on(handleEvent);\n      }\n    })();\n    const notificationTimeoutsRef = notificationTimeouts.current;\n    return () => {\n      if (errored || !done) return;\n      channel === null || channel === void 0 || channel.off(handleEvent);\n      client.off('connection.changed', handleEvent);\n      client.off('connection.recovered', handleEvent);\n      client.off('user.deleted', handleEvent);\n      notificationTimeoutsRef.forEach(clearTimeout);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [channel.cid, channelQueryOptions, doMarkReadRequest, channelConfig === null || channelConfig === void 0 ? void 0 : channelConfig.read_events, initializeOnMount]);\n  useEffect(() => {\n    var _state$messages;\n    if (!state.thread) return;\n    const message = (_state$messages = state.messages) === null || _state$messages === void 0 ? void 0 : _state$messages.find(m => {\n      var _state$thread;\n      return m.id === ((_state$thread = state.thread) === null || _state$thread === void 0 ? void 0 : _state$thread.id);\n    });\n    if (message) dispatch({\n      message,\n      type: 'setThread'\n    });\n  }, [state.messages, state.thread]);\n  const handleHighlightedMessageChange = useCallback(_ref2 => {\n    let {\n      highlightDuration,\n      highlightedMessageId\n    } = _ref2;\n    dispatch({\n      channel,\n      highlightedMessageId,\n      type: 'jumpToMessageFinished'\n    });\n    if (clearHighlightedMessageTimeoutId.current) {\n      clearTimeout(clearHighlightedMessageTimeoutId.current);\n    }\n    clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n      if (searchController._internalState.getLatestValue().focusedMessage) {\n        searchController._internalState.partialNext({\n          focusedMessage: undefined\n        });\n      }\n      clearHighlightedMessageTimeoutId.current = null;\n      dispatch({\n        type: 'clearHighlightedMessage'\n      });\n    }, highlightDuration !== null && highlightDuration !== void 0 ? highlightDuration : DEFAULT_HIGHLIGHT_DURATION);\n  }, [channel, searchController]);\n  useEffect(() => {\n    if (!(jumpToMessageFromSearch !== null && jumpToMessageFromSearch !== void 0 && jumpToMessageFromSearch.id)) return;\n    handleHighlightedMessageChange({\n      highlightedMessageId: jumpToMessageFromSearch.id\n    });\n  }, [jumpToMessageFromSearch, handleHighlightedMessageChange]);\n  /** MESSAGE */\n  // Adds a temporary notification to message list, will be removed after 5 seconds\n  const addNotification = useMemo(() => makeAddNotifications(setNotifications, notificationTimeouts.current), []);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const loadMoreFinished = useCallback(debounce((hasMore, messages) => {\n    if (!isMounted.current) return;\n    dispatch({\n      hasMore,\n      messages,\n      type: 'loadMoreFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  }), []);\n  const loadMore = async function () {\n    var _state$messages2;\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_NEXT_CHANNEL_PAGE_SIZE;\n    if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasPrev) return 0;\n    // prevent duplicate loading events...\n    const oldestMessage = state === null || state === void 0 || (_state$messages2 = state.messages) === null || _state$messages2 === void 0 ? void 0 : _state$messages2[0];\n    if (state.loadingMore || state.loadingMoreNewer || (oldestMessage === null || oldestMessage === void 0 ? void 0 : oldestMessage.status) !== 'received') {\n      return 0;\n    }\n    dispatch({\n      loadingMore: true,\n      type: 'setLoadingMore'\n    });\n    const oldestID = oldestMessage === null || oldestMessage === void 0 ? void 0 : oldestMessage.id;\n    const perPage = limit;\n    let queryResponse;\n    try {\n      queryResponse = await channel.query({\n        messages: {\n          id_lt: oldestID,\n          limit: perPage\n        },\n        watchers: {\n          limit: perPage\n        }\n      });\n    } catch (e) {\n      console.warn('message pagination request failed with error', e);\n      dispatch({\n        loadingMore: false,\n        type: 'setLoadingMore'\n      });\n      return 0;\n    }\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    return queryResponse.messages.length;\n  };\n  const loadMoreNewer = async function () {\n    var _state$messages3, _state$messages4;\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_NEXT_CHANNEL_PAGE_SIZE;\n    if (!online.current || !window.navigator.onLine || !channel.state.messagePagination.hasNext) return 0;\n    const newestMessage = state === null || state === void 0 || (_state$messages3 = state.messages) === null || _state$messages3 === void 0 ? void 0 : _state$messages3[(state === null || state === void 0 || (_state$messages4 = state.messages) === null || _state$messages4 === void 0 ? void 0 : _state$messages4.length) - 1];\n    if (state.loadingMore || state.loadingMoreNewer) return 0;\n    dispatch({\n      loadingMoreNewer: true,\n      type: 'setLoadingMoreNewer'\n    });\n    const newestId = newestMessage === null || newestMessage === void 0 ? void 0 : newestMessage.id;\n    const perPage = limit;\n    let queryResponse;\n    try {\n      queryResponse = await channel.query({\n        messages: {\n          id_gt: newestId,\n          limit: perPage\n        },\n        watchers: {\n          limit: perPage\n        }\n      });\n    } catch (e) {\n      console.warn('message pagination request failed with error', e);\n      dispatch({\n        loadingMoreNewer: false,\n        type: 'setLoadingMoreNewer'\n      });\n      return 0;\n    }\n    dispatch({\n      hasMoreNewer: channel.state.messagePagination.hasNext,\n      messages: channel.state.messages,\n      type: 'loadMoreNewerFinished'\n    });\n    return queryResponse.messages.length;\n  };\n  const jumpToMessage = useCallback(async function (messageId) {\n    let messageLimit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_JUMP_TO_PAGE_SIZE;\n    let highlightDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_HIGHLIGHT_DURATION;\n    dispatch({\n      loadingMore: true,\n      type: 'setLoadingMore'\n    });\n    await channel.state.loadMessageIntoState(messageId, undefined, messageLimit);\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    handleHighlightedMessageChange({\n      highlightDuration,\n      highlightedMessageId: messageId\n    });\n  }, [channel, handleHighlightedMessageChange, loadMoreFinished]);\n  const jumpToLatestMessage = useCallback(async () => {\n    await channel.state.loadMessageIntoState('latest');\n    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n    dispatch({\n      type: 'jumpToLatestMessage'\n    });\n  }, [channel, loadMoreFinished]);\n  const jumpToFirstUnreadMessage = useCallback(async function () {\n    let queryMessageLimit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_JUMP_TO_PAGE_SIZE;\n    let highlightDuration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_HIGHLIGHT_DURATION;\n    if (!(channelUnreadUiState !== null && channelUnreadUiState !== void 0 && channelUnreadUiState.unread_messages)) return;\n    let lastReadMessageId = channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.last_read_message_id;\n    let firstUnreadMessageId = channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.first_unread_message_id;\n    let isInCurrentMessageSet = false;\n    if (firstUnreadMessageId) {\n      const result = findInMsgSetById(firstUnreadMessageId, channel.state.messages);\n      isInCurrentMessageSet = result.index !== -1;\n    } else if (lastReadMessageId) {\n      var _channel$state$messag;\n      const result = findInMsgSetById(lastReadMessageId, channel.state.messages);\n      isInCurrentMessageSet = !!result.target;\n      firstUnreadMessageId = result.index > -1 ? (_channel$state$messag = channel.state.messages[result.index + 1]) === null || _channel$state$messag === void 0 ? void 0 : _channel$state$messag.id : undefined;\n    } else {\n      const lastReadTimestamp = channelUnreadUiState.last_read.getTime();\n      const {\n        index: lastReadMessageIndex,\n        target: lastReadMessage\n      } = findInMsgSetByDate(channelUnreadUiState.last_read, channel.state.messages, true);\n      if (lastReadMessage) {\n        var _channel$state$messag2;\n        firstUnreadMessageId = (_channel$state$messag2 = channel.state.messages[lastReadMessageIndex + 1]) === null || _channel$state$messag2 === void 0 ? void 0 : _channel$state$messag2.id;\n        isInCurrentMessageSet = !!firstUnreadMessageId;\n        lastReadMessageId = lastReadMessage.id;\n      } else {\n        dispatch({\n          loadingMore: true,\n          type: 'setLoadingMore'\n        });\n        let messages;\n        try {\n          messages = (await channel.query({\n            messages: {\n              created_at_around: channelUnreadUiState.last_read.toISOString(),\n              limit: queryMessageLimit\n            }\n          }, 'new')).messages;\n        } catch (e) {\n          addNotification(t('Failed to jump to the first unread message'), 'error');\n          loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n          return;\n        }\n        const firstMessageWithCreationDate = messages.find(msg => msg.created_at);\n        if (!firstMessageWithCreationDate) {\n          addNotification(t('Failed to jump to the first unread message'), 'error');\n          loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n          return;\n        }\n        const firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();\n        if (lastReadTimestamp < firstMessageTimestamp) {\n          // whole channel is unread\n          firstUnreadMessageId = firstMessageWithCreationDate.id;\n        } else {\n          var _result$target;\n          const result = findInMsgSetByDate(channelUnreadUiState.last_read, messages);\n          lastReadMessageId = (_result$target = result.target) === null || _result$target === void 0 ? void 0 : _result$target.id;\n        }\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n      }\n    }\n    if (!firstUnreadMessageId && !lastReadMessageId) {\n      addNotification(t('Failed to jump to the first unread message'), 'error');\n      return;\n    }\n    if (!isInCurrentMessageSet) {\n      dispatch({\n        loadingMore: true,\n        type: 'setLoadingMore'\n      });\n      try {\n        var _channel$state$messag3;\n        const targetId = firstUnreadMessageId !== null && firstUnreadMessageId !== void 0 ? firstUnreadMessageId : lastReadMessageId;\n        await channel.state.loadMessageIntoState(targetId, undefined, queryMessageLimit);\n        /**\n         * if the index of the last read message on the page is beyond the half of the page,\n         * we have arrived to the oldest page of the channel\n         */\n        const indexOfTarget = channel.state.messages.findIndex(message => message.id === targetId);\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        firstUnreadMessageId = firstUnreadMessageId !== null && firstUnreadMessageId !== void 0 ? firstUnreadMessageId : (_channel$state$messag3 = channel.state.messages[indexOfTarget + 1]) === null || _channel$state$messag3 === void 0 ? void 0 : _channel$state$messag3.id;\n      } catch (e) {\n        addNotification(t('Failed to jump to the first unread message'), 'error');\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        return;\n      }\n    }\n    if (!firstUnreadMessageId) {\n      addNotification(t('Failed to jump to the first unread message'), 'error');\n      return;\n    }\n    if (!channelUnreadUiState.first_unread_message_id) _setChannelUnreadUiState(_objectSpread(_objectSpread({}, channelUnreadUiState), {}, {\n      first_unread_message_id: firstUnreadMessageId,\n      last_read_message_id: lastReadMessageId\n    }));\n    handleHighlightedMessageChange({\n      highlightDuration,\n      highlightedMessageId: firstUnreadMessageId\n    });\n  }, [addNotification, channel, handleHighlightedMessageChange, loadMoreFinished, t, channelUnreadUiState]);\n  const deleteMessage = useCallback(async message => {\n    if (!(message !== null && message !== void 0 && message.id)) {\n      throw new Error('Cannot delete a message - missing message ID.');\n    }\n    let deletedMessage;\n    if (doDeleteMessageRequest) {\n      deletedMessage = await doDeleteMessageRequest(message);\n    } else {\n      const result = await client.deleteMessage(message.id);\n      deletedMessage = result.message;\n    }\n    return deletedMessage;\n  }, [client, doDeleteMessageRequest]);\n  const updateMessage = updatedMessage => {\n    // add the message to the local channel state\n    channel.state.addMessageSorted(updatedMessage, true);\n    dispatch({\n      channel,\n      parentId: state.thread && updatedMessage.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  const doSendMessage = async _ref3 => {\n    let {\n      localMessage,\n      message,\n      options\n    } = _ref3;\n    try {\n      var _messageResponse, _existingMessage, _messageResponse2, _existingMessage2;\n      let messageResponse;\n      if (doSendMessageRequest) {\n        messageResponse = await doSendMessageRequest(channel, message, options);\n      } else {\n        messageResponse = await channel.sendMessage(message, options);\n      }\n      let existingMessage = undefined;\n      for (let i = channel.state.messages.length - 1; i >= 0; i--) {\n        const msg = channel.state.messages[i];\n        if (msg.id && msg.id === message.id) {\n          existingMessage = msg;\n          break;\n        }\n      }\n      const responseTimestamp = new Date(((_messageResponse = messageResponse) === null || _messageResponse === void 0 || (_messageResponse = _messageResponse.message) === null || _messageResponse === void 0 ? void 0 : _messageResponse.updated_at) || 0).getTime();\n      const existingMessageTimestamp = ((_existingMessage = existingMessage) === null || _existingMessage === void 0 || (_existingMessage = _existingMessage.updated_at) === null || _existingMessage === void 0 ? void 0 : _existingMessage.getTime()) || 0;\n      const responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n      // Replace the message payload after send is completed\n      // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n      // Always override existing message in status \"sending\"\n      if ((_messageResponse2 = messageResponse) !== null && _messageResponse2 !== void 0 && _messageResponse2.message && (responseIsTheNewest || ((_existingMessage2 = existingMessage) === null || _existingMessage2 === void 0 ? void 0 : _existingMessage2.status) === 'sending')) {\n        updateMessage(_objectSpread(_objectSpread({}, messageResponse.message), {}, {\n          status: 'received'\n        }));\n      }\n    } catch (error) {\n      // error response isn't usable so needs to be stringified then parsed\n      const stringError = JSON.stringify(error);\n      const parsedError = stringError ? JSON.parse(stringError) : {};\n      // Handle the case where the message already exists\n      // (typically, when retrying to send a message).\n      // If the message already exists, we can assume it was sent successfully,\n      // so we update the message status to \"received\".\n      // Right now, the only way to check this error is by checking\n      // the combination of the error code and the error description,\n      // since there is no special error code for duplicate messages.\n      if (parsedError.code === 4 && error instanceof Error && error.message.includes('already exists')) {\n        updateMessage(_objectSpread(_objectSpread({}, localMessage), {}, {\n          status: 'received'\n        }));\n      } else {\n        updateMessage(_objectSpread(_objectSpread({}, localMessage), {}, {\n          error: parsedError,\n          status: 'failed'\n        }));\n        thread === null || thread === void 0 || thread.upsertReplyLocally({\n          message: _objectSpread(_objectSpread({}, localMessage), {}, {\n            error: parsedError,\n            status: 'failed'\n          })\n        });\n      }\n    }\n  };\n  const sendMessage = async _ref4 => {\n    let {\n      localMessage,\n      message,\n      options\n    } = _ref4;\n    channel.state.filterErrorMessages();\n    thread === null || thread === void 0 || thread.upsertReplyLocally({\n      message: localMessage\n    });\n    updateMessage(localMessage);\n    await doSendMessage({\n      localMessage,\n      message,\n      options\n    });\n  };\n  const retrySendMessage = async localMessage => {\n    updateMessage(_objectSpread(_objectSpread({}, localMessage), {}, {\n      error: undefined,\n      status: 'sending'\n    }));\n    await doSendMessage({\n      localMessage,\n      message: localMessageToNewMessagePayload(localMessage)\n    });\n  };\n  const removeMessage = message => {\n    channel.state.removeMessage(message);\n    dispatch({\n      channel,\n      parentId: state.thread && message.parent_id,\n      type: 'copyMessagesFromChannel'\n    });\n  };\n  /** THREAD */\n  const openThread = (message, event) => {\n    event === null || event === void 0 || event.preventDefault();\n    dispatch({\n      channel,\n      message,\n      type: 'openThread'\n    });\n  };\n  const closeThread = event => {\n    event === null || event === void 0 || event.preventDefault();\n    dispatch({\n      type: 'closeThread'\n    });\n  };\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const loadMoreThreadFinished = useCallback(debounce((threadHasMore, threadMessages) => {\n    dispatch({\n      threadHasMore,\n      threadMessages,\n      type: 'loadMoreThreadFinished'\n    });\n  }, 2000, {\n    leading: true,\n    trailing: true\n  }), []);\n  const loadMoreThread = async function () {\n    var _oldMessages$;\n    let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_THREAD_PAGE_SIZE;\n    // FIXME: should prevent loading more, if state.thread.reply_count === channel.state.threads[parentID].length\n    if (state.threadLoadingMore || !state.thread || !state.threadHasMore) return;\n    dispatch({\n      type: 'startLoadingThread'\n    });\n    const parentId = state.thread.id;\n    if (!parentId) {\n      return dispatch({\n        type: 'closeThread'\n      });\n    }\n    const oldMessages = channel.state.threads[parentId] || [];\n    const oldestMessageId = (_oldMessages$ = oldMessages[0]) === null || _oldMessages$ === void 0 ? void 0 : _oldMessages$.id;\n    try {\n      const queryResponse = await channel.getReplies(parentId, {\n        id_lt: oldestMessageId,\n        limit\n      });\n      const threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n      const newThreadMessages = channel.state.threads[parentId] || [];\n      // next set loadingMore to false so we can start asking for more data\n      loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n    } catch (e) {\n      loadMoreThreadFinished(false, oldMessages);\n    }\n  };\n  const onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n  const editMessage = useEditMessageHandler(doUpdateMessageRequest);\n  const {\n      typing\n    } = state,\n    restState = _objectWithoutProperties(state, _excluded3);\n  const channelStateContextValue = useCreateChannelStateContext(_objectSpread(_objectSpread({}, restState), {}, {\n    channel,\n    channelCapabilitiesArray,\n    channelConfig,\n    channelUnreadUiState,\n    giphyVersion: props.giphyVersion || 'fixed_height',\n    imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n    mutes,\n    notifications,\n    shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n    videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n    watcher_count: state.watcherCount\n  }));\n  const channelActionContextValue = useMemo(() => ({\n    addNotification,\n    closeThread,\n    deleteMessage,\n    dispatch,\n    editMessage,\n    jumpToFirstUnreadMessage,\n    jumpToLatestMessage,\n    jumpToMessage,\n    loadMore,\n    loadMoreNewer,\n    loadMoreThread,\n    markRead,\n    onMentionsClick: onMentionsHoverOrClick,\n    onMentionsHover: onMentionsHoverOrClick,\n    openThread,\n    removeMessage,\n    retrySendMessage,\n    sendMessage,\n    setChannelUnreadUiState,\n    skipMessageDataMemoization,\n    updateMessage\n  }),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [channel.cid, deleteMessage, loadMore, loadMoreNewer, markRead, jumpToFirstUnreadMessage, jumpToMessage, jumpToLatestMessage, setChannelUnreadUiState]);\n  const componentContextValue = useMemo(() => ({\n    Attachment: props.Attachment,\n    AttachmentPreviewList: props.AttachmentPreviewList,\n    AttachmentSelector: props.AttachmentSelector,\n    AttachmentSelectorInitiationButtonContents: props.AttachmentSelectorInitiationButtonContents,\n    AudioRecorder: props.AudioRecorder,\n    AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n    AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n    Avatar: props.Avatar,\n    BaseImage: props.BaseImage,\n    CooldownTimer: props.CooldownTimer,\n    CustomMessageActionsList: props.CustomMessageActionsList,\n    DateSeparator: props.DateSeparator,\n    EditMessageInput: props.EditMessageInput,\n    EmojiPicker: props.EmojiPicker,\n    emojiSearchIndex: props.emojiSearchIndex,\n    EmptyStateIndicator: props.EmptyStateIndicator,\n    FileUploadIcon: props.FileUploadIcon,\n    GiphyPreviewMessage: props.GiphyPreviewMessage,\n    HeaderComponent: props.HeaderComponent,\n    Input: props.Input,\n    LinkPreviewList: props.LinkPreviewList,\n    LoadingIndicator: props.LoadingIndicator,\n    Message: props.Message,\n    MessageActions: props.MessageActions,\n    MessageBlocked: props.MessageBlocked,\n    MessageBouncePrompt: props.MessageBouncePrompt,\n    MessageDeleted: props.MessageDeleted,\n    MessageIsThreadReplyInChannelButtonIndicator: props.MessageIsThreadReplyInChannelButtonIndicator,\n    MessageListNotifications: props.MessageListNotifications,\n    MessageNotification: props.MessageNotification,\n    MessageOptions: props.MessageOptions,\n    MessageRepliesCountButton: props.MessageRepliesCountButton,\n    MessageStatus: props.MessageStatus,\n    MessageSystem: props.MessageSystem,\n    MessageTimestamp: props.MessageTimestamp,\n    ModalGallery: props.ModalGallery,\n    PinIndicator: props.PinIndicator,\n    PollActions: props.PollActions,\n    PollContent: props.PollContent,\n    PollCreationDialog: props.PollCreationDialog,\n    PollHeader: props.PollHeader,\n    PollOptionSelector: props.PollOptionSelector,\n    QuotedMessage: props.QuotedMessage,\n    QuotedMessagePreview: props.QuotedMessagePreview,\n    QuotedPoll: props.QuotedPoll,\n    reactionOptions: props.reactionOptions,\n    ReactionSelector: props.ReactionSelector,\n    ReactionsList: props.ReactionsList,\n    ReactionsListModal: props.ReactionsListModal,\n    ReminderNotification: props.ReminderNotification,\n    SendButton: props.SendButton,\n    SendToChannelCheckbox: props.SendToChannelCheckbox,\n    StartRecordingAudioButton: props.StartRecordingAudioButton,\n    StopAIGenerationButton: props.StopAIGenerationButton,\n    StreamedMessageText: props.StreamedMessageText,\n    TextareaComposer: props.TextareaComposer,\n    ThreadHead: props.ThreadHead,\n    ThreadHeader: props.ThreadHeader,\n    ThreadStart: props.ThreadStart,\n    Timestamp: props.Timestamp,\n    TypingIndicator: props.TypingIndicator,\n    UnreadMessagesNotification: props.UnreadMessagesNotification,\n    UnreadMessagesSeparator: props.UnreadMessagesSeparator,\n    VirtualMessage: props.VirtualMessage\n  }), [props.Attachment, props.AttachmentPreviewList, props.AttachmentSelector, props.AttachmentSelectorInitiationButtonContents, props.AudioRecorder, props.AutocompleteSuggestionItem, props.AutocompleteSuggestionList, props.Avatar, props.BaseImage, props.CooldownTimer, props.CustomMessageActionsList, props.DateSeparator, props.EditMessageInput, props.EmojiPicker, props.emojiSearchIndex, props.EmptyStateIndicator, props.FileUploadIcon, props.GiphyPreviewMessage, props.HeaderComponent, props.Input, props.LinkPreviewList, props.LoadingIndicator, props.Message, props.MessageActions, props.MessageBlocked, props.MessageBouncePrompt, props.MessageDeleted, props.MessageIsThreadReplyInChannelButtonIndicator, props.MessageListNotifications, props.MessageNotification, props.MessageOptions, props.MessageRepliesCountButton, props.MessageStatus, props.MessageSystem, props.MessageTimestamp, props.ModalGallery, props.PinIndicator, props.PollActions, props.PollContent, props.PollCreationDialog, props.PollHeader, props.PollOptionSelector, props.QuotedMessage, props.QuotedMessagePreview, props.QuotedPoll, props.reactionOptions, props.ReactionSelector, props.ReactionsList, props.ReactionsListModal, props.ReminderNotification, props.SendButton, props.SendToChannelCheckbox, props.StartRecordingAudioButton, props.StopAIGenerationButton, props.StreamedMessageText, props.TextareaComposer, props.ThreadHead, props.ThreadHeader, props.ThreadStart, props.Timestamp, props.TypingIndicator, props.UnreadMessagesNotification, props.UnreadMessagesSeparator, props.VirtualMessage]);\n  const typingContextValue = useCreateTypingContext({\n    typing\n  });\n  if (state.error) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingErrorIndicator, {\n      error: state.error\n    }));\n  }\n  if (state.loading) {\n    return React.createElement(ChannelContainer, null, React.createElement(LoadingIndicator, null));\n  }\n  if (!channel.watch) {\n    return React.createElement(ChannelContainer, null, React.createElement(\"div\", null, t('Channel Missing')));\n  }\n  return React.createElement(ChannelContainer, {\n    className: windowsEmojiClass\n  }, React.createElement(ChannelStateProvider, {\n    value: channelStateContextValue\n  }, React.createElement(ChannelActionProvider, {\n    value: channelActionContextValue\n  }, React.createElement(WithComponents, {\n    overrides: componentContextValue\n  }, React.createElement(TypingProvider, {\n    value: typingContextValue\n  }, React.createElement(\"div\", {\n    className: clsx(chatContainerClass)\n  }, children))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport const Channel = React.memo(UnMemoizedChannel);","map":{"version":3,"names":["React","useCallback","useEffect","useLayoutEffect","useMemo","useReducer","useRef","useState","clsx","debounce","defaultsDeep","throttle","localMessageToNewMessagePayload","initialState","makeChannelReducer","useCreateChannelStateContext","useCreateTypingContext","useEditMessageHandler","useIsMounted","useMentionsHandlers","LoadingErrorIndicator","DefaultLoadingErrorIndicator","LoadingChannel","DefaultLoadingIndicator","ChannelActionProvider","ChannelStateProvider","TypingProvider","useChatContext","useTranslationContext","WithComponents","CHANNEL_CONTAINER_ID","DEFAULT_HIGHLIGHT_DURATION","DEFAULT_INITIAL_CHANNEL_PAGE_SIZE","DEFAULT_JUMP_TO_PAGE_SIZE","DEFAULT_NEXT_CHANNEL_PAGE_SIZE","DEFAULT_THREAD_PAGE_SIZE","hasMoreMessagesProbably","getChatContainerClass","useChannelContainerClasses","useImageFlagEmojisOnWindowsClass","findInMsgSetByDate","findInMsgSetById","makeAddNotifications","useThreadContext","getChannel","getImageAttachmentConfiguration","getVideoAttachmentConfiguration","useSearchFocusedMessage","ChannelContainer","_ref","children","className","additionalClassName","props","_objectWithoutProperties","_excluded","customClasses","theme","channelClass","chatClass","createElement","_objectSpread","id","UnMemoizedChannel","channel","propsChannel","EmptyPlaceholder","LoadingIndicator","contextChannel","channelsQueryState","queryInProgress","error","cid","ChannelInner","key","_channel$data","activeUnreadHandler","channelQueryOptions","propChannelQueryOptions","doDeleteMessageRequest","doMarkReadRequest","doSendMessageRequest","doUpdateMessageRequest","initializeOnMount","markReadOnMount","onMentionsClick","onMentionsHover","skipMessageDataMemoization","messages","limit","client","latestMessageDatesByChannels","mutes","searchController","t","chatContainerClass","chatContainer","windowsEmojiClass","thread","channelConfig","setChannelConfig","getConfig","notifications","setNotifications","notificationTimeouts","channelUnreadUiState","_setChannelUnreadUiState","channelReducer","state","dispatch","hasMore","messagePagination","hasPrev","loading","initialized","jumpToMessageFromSearch","isMounted","originalTitle","lastRead","undefined","online","clearHighlightedMessageTimeoutId","channelCapabilitiesArray","data","own_capabilities","throttledCopyStateFromChannel","type","leading","trailing","setChannelUnreadUiState","markRead","options","updateChannelUiUnreadState","disconnected","read_events","current","Date","markReadResponse","last_read","last_read_message_id","event","unread_messages","document","title","e","console","handleEvent","message","_event$message","_event$message2","_event$message3","_event$message4","_event$message5","mainChannelUpdated","parent_id","show_in_channel","hidden","muteStatus","muted","unread","countUnread","concat","user","userID","created_at","messageDate","getTime","_channel$state","oldestID","query","id_lt","watchers","prev","_event$unread_message","last_read_at","first_unread_message_id","errored","done","_channel$data2","members","member","userId","user_id","push","config","_client$user","read","_channel$state$read$c","ownReadState","_excluded2","on","notificationTimeoutsRef","off","forEach","clearTimeout","_state$messages","find","m","_state$thread","handleHighlightedMessageChange","_ref2","highlightDuration","highlightedMessageId","setTimeout","_internalState","getLatestValue","focusedMessage","partialNext","addNotification","loadMoreFinished","loadMore","_state$messages2","arguments","length","window","navigator","onLine","oldestMessage","loadingMore","loadingMoreNewer","status","perPage","queryResponse","warn","loadMoreNewer","_state$messages3","_state$messages4","hasNext","newestMessage","newestId","id_gt","hasMoreNewer","jumpToMessage","messageId","messageLimit","loadMessageIntoState","jumpToLatestMessage","jumpToFirstUnreadMessage","queryMessageLimit","lastReadMessageId","firstUnreadMessageId","isInCurrentMessageSet","result","index","_channel$state$messag","target","lastReadTimestamp","lastReadMessageIndex","lastReadMessage","_channel$state$messag2","created_at_around","toISOString","firstMessageWithCreationDate","msg","firstMessageTimestamp","_result$target","_channel$state$messag3","targetId","indexOfTarget","findIndex","deleteMessage","Error","deletedMessage","updateMessage","updatedMessage","addMessageSorted","parentId","doSendMessage","_ref3","localMessage","_messageResponse","_existingMessage","_messageResponse2","_existingMessage2","messageResponse","sendMessage","existingMessage","i","responseTimestamp","updated_at","existingMessageTimestamp","responseIsTheNewest","stringError","JSON","stringify","parsedError","parse","code","includes","upsertReplyLocally","_ref4","filterErrorMessages","retrySendMessage","removeMessage","openThread","preventDefault","closeThread","loadMoreThreadFinished","threadHasMore","threadMessages","loadMoreThread","_oldMessages$","threadLoadingMore","oldMessages","threads","oldestMessageId","getReplies","threadHasMoreMessages","newThreadMessages","onMentionsHoverOrClick","editMessage","typing","restState","_excluded3","channelStateContextValue","giphyVersion","imageAttachmentSizeHandler","shouldGenerateVideoThumbnail","videoAttachmentSizeHandler","watcher_count","watcherCount","channelActionContextValue","componentContextValue","Attachment","AttachmentPreviewList","AttachmentSelector","AttachmentSelectorInitiationButtonContents","AudioRecorder","AutocompleteSuggestionItem","AutocompleteSuggestionList","Avatar","BaseImage","CooldownTimer","CustomMessageActionsList","DateSeparator","EditMessageInput","EmojiPicker","emojiSearchIndex","EmptyStateIndicator","FileUploadIcon","GiphyPreviewMessage","HeaderComponent","Input","LinkPreviewList","Message","MessageActions","MessageBlocked","MessageBouncePrompt","MessageDeleted","MessageIsThreadReplyInChannelButtonIndicator","MessageListNotifications","MessageNotification","MessageOptions","MessageRepliesCountButton","MessageStatus","MessageSystem","MessageTimestamp","ModalGallery","PinIndicator","PollActions","PollContent","PollCreationDialog","PollHeader","PollOptionSelector","QuotedMessage","QuotedMessagePreview","QuotedPoll","reactionOptions","ReactionSelector","ReactionsList","ReactionsListModal","ReminderNotification","SendButton","SendToChannelCheckbox","StartRecordingAudioButton","StopAIGenerationButton","StreamedMessageText","TextareaComposer","ThreadHead","ThreadHeader","ThreadStart","Timestamp","TypingIndicator","UnreadMessagesNotification","UnreadMessagesSeparator","VirtualMessage","typingContextValue","watch","value","overrides","Channel","memo"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/Channel/Channel.js"],"sourcesContent":["import React, { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef, useState, } from 'react';\nimport clsx from 'clsx';\nimport debounce from 'lodash.debounce';\nimport defaultsDeep from 'lodash.defaultsdeep';\nimport throttle from 'lodash.throttle';\nimport { localMessageToNewMessagePayload } from 'stream-chat';\nimport { initialState, makeChannelReducer } from './channelState';\nimport { useCreateChannelStateContext } from './hooks/useCreateChannelStateContext';\nimport { useCreateTypingContext } from './hooks/useCreateTypingContext';\nimport { useEditMessageHandler } from './hooks/useEditMessageHandler';\nimport { useIsMounted } from './hooks/useIsMounted';\nimport { useMentionsHandlers } from './hooks/useMentionsHandlers';\nimport { LoadingErrorIndicator as DefaultLoadingErrorIndicator } from '../Loading';\nimport { LoadingChannel as DefaultLoadingIndicator } from './LoadingChannel';\nimport { ChannelActionProvider, ChannelStateProvider, TypingProvider, useChatContext, useTranslationContext, WithComponents, } from '../../context';\nimport { CHANNEL_CONTAINER_ID } from './constants';\nimport { DEFAULT_HIGHLIGHT_DURATION, DEFAULT_INITIAL_CHANNEL_PAGE_SIZE, DEFAULT_JUMP_TO_PAGE_SIZE, DEFAULT_NEXT_CHANNEL_PAGE_SIZE, DEFAULT_THREAD_PAGE_SIZE, } from '../../constants/limits';\nimport { hasMoreMessagesProbably } from '../MessageList';\nimport { getChatContainerClass, useChannelContainerClasses, useImageFlagEmojisOnWindowsClass, } from './hooks/useChannelContainerClasses';\nimport { findInMsgSetByDate, findInMsgSetById, makeAddNotifications } from './utils';\nimport { useThreadContext } from '../Threads';\nimport { getChannel } from '../../utils';\nimport { getImageAttachmentConfiguration, getVideoAttachmentConfiguration, } from '../Attachment/attachment-sizing';\nimport { useSearchFocusedMessage } from '../../experimental/Search/hooks';\nconst ChannelContainer = ({ children, className: additionalClassName, ...props }) => {\n    const { customClasses, theme } = useChatContext('Channel');\n    const { channelClass, chatClass } = useChannelContainerClasses({\n        customClasses,\n    });\n    const className = clsx(chatClass, theme, channelClass, additionalClassName);\n    return (React.createElement(\"div\", { id: CHANNEL_CONTAINER_ID, ...props, className: className }, children));\n};\nconst UnMemoizedChannel = (props) => {\n    const { channel: propsChannel, EmptyPlaceholder = null, LoadingErrorIndicator, LoadingIndicator = DefaultLoadingIndicator, } = props;\n    const { channel: contextChannel, channelsQueryState } = useChatContext('Channel');\n    const channel = propsChannel || contextChannel;\n    if (channelsQueryState.queryInProgress === 'reload' && LoadingIndicator) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingIndicator, null)));\n    }\n    if (channelsQueryState.error && LoadingErrorIndicator) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingErrorIndicator, { error: channelsQueryState.error })));\n    }\n    if (!channel?.cid) {\n        return React.createElement(ChannelContainer, null, EmptyPlaceholder);\n    }\n    return React.createElement(ChannelInner, { ...props, channel: channel, key: channel.cid });\n};\nconst ChannelInner = (props) => {\n    const { activeUnreadHandler, channel, channelQueryOptions: propChannelQueryOptions, children, doDeleteMessageRequest, doMarkReadRequest, doSendMessageRequest, doUpdateMessageRequest, initializeOnMount = true, LoadingErrorIndicator = DefaultLoadingErrorIndicator, LoadingIndicator = DefaultLoadingIndicator, markReadOnMount = true, onMentionsClick, onMentionsHover, skipMessageDataMemoization, } = props;\n    const channelQueryOptions = useMemo(() => defaultsDeep(propChannelQueryOptions, {\n        messages: { limit: DEFAULT_INITIAL_CHANNEL_PAGE_SIZE },\n    }), [propChannelQueryOptions]);\n    const { client, customClasses, latestMessageDatesByChannels, mutes, searchController } = useChatContext('Channel');\n    const { t } = useTranslationContext('Channel');\n    const chatContainerClass = getChatContainerClass(customClasses?.chatContainer);\n    const windowsEmojiClass = useImageFlagEmojisOnWindowsClass();\n    const thread = useThreadContext();\n    const [channelConfig, setChannelConfig] = useState(channel.getConfig());\n    const [notifications, setNotifications] = useState([]);\n    const notificationTimeouts = useRef([]);\n    const [channelUnreadUiState, _setChannelUnreadUiState] = useState();\n    const channelReducer = useMemo(() => makeChannelReducer(), []);\n    const [state, dispatch] = useReducer(channelReducer, \n    // channel.initialized === false if client.channel().query() was not called, e.g. ChannelList is not used\n    // => Channel will call channel.watch() in useLayoutEffect => state.loading is used to signal the watch() call state\n    {\n        ...initialState,\n        hasMore: channel.state.messagePagination.hasPrev,\n        loading: !channel.initialized,\n        messages: channel.state.messages,\n    });\n    const jumpToMessageFromSearch = useSearchFocusedMessage();\n    const isMounted = useIsMounted();\n    const originalTitle = useRef('');\n    const lastRead = useRef(undefined);\n    const online = useRef(true);\n    const clearHighlightedMessageTimeoutId = useRef(null);\n    const channelCapabilitiesArray = channel.data?.own_capabilities;\n    const throttledCopyStateFromChannel = throttle(() => dispatch({ channel, type: 'copyStateFromChannelOnEvent' }), 500, {\n        leading: true,\n        trailing: true,\n    });\n    const setChannelUnreadUiState = useMemo(() => throttle(_setChannelUnreadUiState, 200, {\n        leading: true,\n        trailing: false,\n    }), []);\n    const markRead = useMemo(() => throttle(async (options) => {\n        const { updateChannelUiUnreadState = true } = options ?? {};\n        if (channel.disconnected || !channelConfig?.read_events) {\n            return;\n        }\n        lastRead.current = new Date();\n        try {\n            if (doMarkReadRequest) {\n                doMarkReadRequest(channel, updateChannelUiUnreadState ? setChannelUnreadUiState : undefined);\n            }\n            else {\n                const markReadResponse = await channel.markRead();\n                if (updateChannelUiUnreadState && markReadResponse) {\n                    _setChannelUnreadUiState({\n                        last_read: lastRead.current,\n                        last_read_message_id: markReadResponse.event.last_read_message_id,\n                        unread_messages: 0,\n                    });\n                }\n            }\n            if (activeUnreadHandler) {\n                activeUnreadHandler(0, originalTitle.current);\n            }\n            else if (originalTitle.current) {\n                document.title = originalTitle.current;\n            }\n        }\n        catch (e) {\n            console.error(t('Failed to mark channel as read'));\n        }\n    }, 500, { leading: true, trailing: false }), [\n        activeUnreadHandler,\n        channel,\n        channelConfig,\n        doMarkReadRequest,\n        setChannelUnreadUiState,\n        t,\n    ]);\n    const handleEvent = async (event) => {\n        if (event.message) {\n            dispatch({\n                channel,\n                message: event.message,\n                type: 'updateThreadOnEvent',\n            });\n        }\n        if (event.type === 'user.watching.start' || event.type === 'user.watching.stop')\n            return;\n        if (event.type === 'typing.start' || event.type === 'typing.stop') {\n            return dispatch({ channel, type: 'setTyping' });\n        }\n        if (event.type === 'connection.changed' && typeof event.online === 'boolean') {\n            online.current = event.online;\n        }\n        if (event.type === 'message.new') {\n            const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n            if (mainChannelUpdated) {\n                if (document.hidden &&\n                    channelConfig?.read_events &&\n                    !channel.muteStatus().muted) {\n                    const unread = channel.countUnread(lastRead.current);\n                    if (activeUnreadHandler) {\n                        activeUnreadHandler(unread, originalTitle.current);\n                    }\n                    else {\n                        document.title = `(${unread}) ${originalTitle.current}`;\n                    }\n                }\n            }\n            if (event.message?.user?.id === client.userID &&\n                event?.message?.created_at &&\n                event?.message?.cid) {\n                const messageDate = new Date(event.message.created_at);\n                const cid = event.message.cid;\n                if (!latestMessageDatesByChannels[cid] ||\n                    latestMessageDatesByChannels[cid].getTime() < messageDate.getTime()) {\n                    latestMessageDatesByChannels[cid] = messageDate;\n                }\n            }\n        }\n        if (event.type === 'user.deleted') {\n            const oldestID = channel.state?.messages?.[0]?.id;\n            /**\n             * As the channel state is not normalized we re-fetch the channel data. Thus, we avoid having to search for user references in the channel state.\n             */\n            // FIXME: we should use channelQueryOptions if they are available\n            await channel.query({\n                messages: { id_lt: oldestID, limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE },\n                watchers: { limit: DEFAULT_NEXT_CHANNEL_PAGE_SIZE },\n            });\n        }\n        if (event.type === 'notification.mark_unread')\n            _setChannelUnreadUiState((prev) => {\n                if (!(event.last_read_at && event.user))\n                    return prev;\n                return {\n                    first_unread_message_id: event.first_unread_message_id,\n                    last_read: new Date(event.last_read_at),\n                    last_read_message_id: event.last_read_message_id,\n                    unread_messages: event.unread_messages ?? 0,\n                };\n            });\n        if (event.type === 'channel.truncated' && event.cid === channel.cid) {\n            _setChannelUnreadUiState(undefined);\n        }\n        throttledCopyStateFromChannel();\n    };\n    // useLayoutEffect here to prevent spinner. Use Suspense when it is available in stable release\n    useLayoutEffect(() => {\n        let errored = false;\n        let done = false;\n        (async () => {\n            if (!channel.initialized && initializeOnMount) {\n                try {\n                    // if active channel has been set without id, we will create a temporary channel id from its member IDs\n                    // to keep track of the /query request in progress. This is the same approach of generating temporary id\n                    // that the JS client uses to keep track of channel in client.activeChannels\n                    const members = [];\n                    if (!channel.id && channel.data?.members) {\n                        for (const member of channel.data.members) {\n                            let userId;\n                            if (typeof member === 'string') {\n                                userId = member;\n                            }\n                            else if (typeof member === 'object') {\n                                const { user, user_id } = member;\n                                userId = user_id || user?.id;\n                            }\n                            if (userId) {\n                                members.push(userId);\n                            }\n                        }\n                    }\n                    await getChannel({ channel, client, members, options: channelQueryOptions });\n                    const config = channel.getConfig();\n                    setChannelConfig(config);\n                }\n                catch (e) {\n                    dispatch({ error: e, type: 'setError' });\n                    errored = true;\n                }\n            }\n            done = true;\n            originalTitle.current = document.title;\n            if (!errored) {\n                dispatch({\n                    channel,\n                    hasMore: channel.state.messagePagination.hasPrev,\n                    type: 'initStateFromChannel',\n                });\n                if (client.user?.id && channel.state.read[client.user.id]) {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    const { user, ...ownReadState } = channel.state.read[client.user.id];\n                    _setChannelUnreadUiState(ownReadState);\n                }\n                /**\n                 * TODO: maybe pass last_read to the countUnread method to get proper value\n                 * combined with channel.countUnread adjustment (_countMessageAsUnread)\n                 * to allow counting own messages too\n                 *\n                 * const lastRead = channel.state.read[client.userID as string].last_read;\n                 */\n                if (channel.countUnread() > 0 && markReadOnMount)\n                    markRead({ updateChannelUiUnreadState: false });\n                // The more complex sync logic is done in Chat\n                client.on('connection.changed', handleEvent);\n                client.on('connection.recovered', handleEvent);\n                client.on('user.updated', handleEvent);\n                client.on('user.deleted', handleEvent);\n                channel.on(handleEvent);\n            }\n        })();\n        const notificationTimeoutsRef = notificationTimeouts.current;\n        return () => {\n            if (errored || !done)\n                return;\n            channel?.off(handleEvent);\n            client.off('connection.changed', handleEvent);\n            client.off('connection.recovered', handleEvent);\n            client.off('user.deleted', handleEvent);\n            notificationTimeoutsRef.forEach(clearTimeout);\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        channel.cid,\n        channelQueryOptions,\n        doMarkReadRequest,\n        channelConfig?.read_events,\n        initializeOnMount,\n    ]);\n    useEffect(() => {\n        if (!state.thread)\n            return;\n        const message = state.messages?.find((m) => m.id === state.thread?.id);\n        if (message)\n            dispatch({ message, type: 'setThread' });\n    }, [state.messages, state.thread]);\n    const handleHighlightedMessageChange = useCallback(({ highlightDuration, highlightedMessageId, }) => {\n        dispatch({\n            channel,\n            highlightedMessageId,\n            type: 'jumpToMessageFinished',\n        });\n        if (clearHighlightedMessageTimeoutId.current) {\n            clearTimeout(clearHighlightedMessageTimeoutId.current);\n        }\n        clearHighlightedMessageTimeoutId.current = setTimeout(() => {\n            if (searchController._internalState.getLatestValue().focusedMessage) {\n                searchController._internalState.partialNext({ focusedMessage: undefined });\n            }\n            clearHighlightedMessageTimeoutId.current = null;\n            dispatch({ type: 'clearHighlightedMessage' });\n        }, highlightDuration ?? DEFAULT_HIGHLIGHT_DURATION);\n    }, [channel, searchController]);\n    useEffect(() => {\n        if (!jumpToMessageFromSearch?.id)\n            return;\n        handleHighlightedMessageChange({ highlightedMessageId: jumpToMessageFromSearch.id });\n    }, [jumpToMessageFromSearch, handleHighlightedMessageChange]);\n    /** MESSAGE */\n    // Adds a temporary notification to message list, will be removed after 5 seconds\n    const addNotification = useMemo(() => makeAddNotifications(setNotifications, notificationTimeouts.current), []);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const loadMoreFinished = useCallback(debounce((hasMore, messages) => {\n        if (!isMounted.current)\n            return;\n        dispatch({ hasMore, messages, type: 'loadMoreFinished' });\n    }, 2000, { leading: true, trailing: true }), []);\n    const loadMore = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n        if (!online.current ||\n            !window.navigator.onLine ||\n            !channel.state.messagePagination.hasPrev)\n            return 0;\n        // prevent duplicate loading events...\n        const oldestMessage = state?.messages?.[0];\n        if (state.loadingMore ||\n            state.loadingMoreNewer ||\n            oldestMessage?.status !== 'received') {\n            return 0;\n        }\n        dispatch({ loadingMore: true, type: 'setLoadingMore' });\n        const oldestID = oldestMessage?.id;\n        const perPage = limit;\n        let queryResponse;\n        try {\n            queryResponse = await channel.query({\n                messages: { id_lt: oldestID, limit: perPage },\n                watchers: { limit: perPage },\n            });\n        }\n        catch (e) {\n            console.warn('message pagination request failed with error', e);\n            dispatch({ loadingMore: false, type: 'setLoadingMore' });\n            return 0;\n        }\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        return queryResponse.messages.length;\n    };\n    const loadMoreNewer = async (limit = DEFAULT_NEXT_CHANNEL_PAGE_SIZE) => {\n        if (!online.current ||\n            !window.navigator.onLine ||\n            !channel.state.messagePagination.hasNext)\n            return 0;\n        const newestMessage = state?.messages?.[state?.messages?.length - 1];\n        if (state.loadingMore || state.loadingMoreNewer)\n            return 0;\n        dispatch({ loadingMoreNewer: true, type: 'setLoadingMoreNewer' });\n        const newestId = newestMessage?.id;\n        const perPage = limit;\n        let queryResponse;\n        try {\n            queryResponse = await channel.query({\n                messages: { id_gt: newestId, limit: perPage },\n                watchers: { limit: perPage },\n            });\n        }\n        catch (e) {\n            console.warn('message pagination request failed with error', e);\n            dispatch({ loadingMoreNewer: false, type: 'setLoadingMoreNewer' });\n            return 0;\n        }\n        dispatch({\n            hasMoreNewer: channel.state.messagePagination.hasNext,\n            messages: channel.state.messages,\n            type: 'loadMoreNewerFinished',\n        });\n        return queryResponse.messages.length;\n    };\n    const jumpToMessage = useCallback(async (messageId, messageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n        dispatch({ loadingMore: true, type: 'setLoadingMore' });\n        await channel.state.loadMessageIntoState(messageId, undefined, messageLimit);\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        handleHighlightedMessageChange({\n            highlightDuration,\n            highlightedMessageId: messageId,\n        });\n    }, [channel, handleHighlightedMessageChange, loadMoreFinished]);\n    const jumpToLatestMessage = useCallback(async () => {\n        await channel.state.loadMessageIntoState('latest');\n        loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n        dispatch({\n            type: 'jumpToLatestMessage',\n        });\n    }, [channel, loadMoreFinished]);\n    const jumpToFirstUnreadMessage = useCallback(async (queryMessageLimit = DEFAULT_JUMP_TO_PAGE_SIZE, highlightDuration = DEFAULT_HIGHLIGHT_DURATION) => {\n        if (!channelUnreadUiState?.unread_messages)\n            return;\n        let lastReadMessageId = channelUnreadUiState?.last_read_message_id;\n        let firstUnreadMessageId = channelUnreadUiState?.first_unread_message_id;\n        let isInCurrentMessageSet = false;\n        if (firstUnreadMessageId) {\n            const result = findInMsgSetById(firstUnreadMessageId, channel.state.messages);\n            isInCurrentMessageSet = result.index !== -1;\n        }\n        else if (lastReadMessageId) {\n            const result = findInMsgSetById(lastReadMessageId, channel.state.messages);\n            isInCurrentMessageSet = !!result.target;\n            firstUnreadMessageId =\n                result.index > -1 ? channel.state.messages[result.index + 1]?.id : undefined;\n        }\n        else {\n            const lastReadTimestamp = channelUnreadUiState.last_read.getTime();\n            const { index: lastReadMessageIndex, target: lastReadMessage } = findInMsgSetByDate(channelUnreadUiState.last_read, channel.state.messages, true);\n            if (lastReadMessage) {\n                firstUnreadMessageId = channel.state.messages[lastReadMessageIndex + 1]?.id;\n                isInCurrentMessageSet = !!firstUnreadMessageId;\n                lastReadMessageId = lastReadMessage.id;\n            }\n            else {\n                dispatch({ loadingMore: true, type: 'setLoadingMore' });\n                let messages;\n                try {\n                    messages = (await channel.query({\n                        messages: {\n                            created_at_around: channelUnreadUiState.last_read.toISOString(),\n                            limit: queryMessageLimit,\n                        },\n                    }, 'new')).messages;\n                }\n                catch (e) {\n                    addNotification(t('Failed to jump to the first unread message'), 'error');\n                    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                    return;\n                }\n                const firstMessageWithCreationDate = messages.find((msg) => msg.created_at);\n                if (!firstMessageWithCreationDate) {\n                    addNotification(t('Failed to jump to the first unread message'), 'error');\n                    loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                    return;\n                }\n                const firstMessageTimestamp = new Date(firstMessageWithCreationDate.created_at).getTime();\n                if (lastReadTimestamp < firstMessageTimestamp) {\n                    // whole channel is unread\n                    firstUnreadMessageId = firstMessageWithCreationDate.id;\n                }\n                else {\n                    const result = findInMsgSetByDate(channelUnreadUiState.last_read, messages);\n                    lastReadMessageId = result.target?.id;\n                }\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n            }\n        }\n        if (!firstUnreadMessageId && !lastReadMessageId) {\n            addNotification(t('Failed to jump to the first unread message'), 'error');\n            return;\n        }\n        if (!isInCurrentMessageSet) {\n            dispatch({ loadingMore: true, type: 'setLoadingMore' });\n            try {\n                const targetId = (firstUnreadMessageId ?? lastReadMessageId);\n                await channel.state.loadMessageIntoState(targetId, undefined, queryMessageLimit);\n                /**\n                 * if the index of the last read message on the page is beyond the half of the page,\n                 * we have arrived to the oldest page of the channel\n                 */\n                const indexOfTarget = channel.state.messages.findIndex((message) => message.id === targetId);\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                firstUnreadMessageId =\n                    firstUnreadMessageId ?? channel.state.messages[indexOfTarget + 1]?.id;\n            }\n            catch (e) {\n                addNotification(t('Failed to jump to the first unread message'), 'error');\n                loadMoreFinished(channel.state.messagePagination.hasPrev, channel.state.messages);\n                return;\n            }\n        }\n        if (!firstUnreadMessageId) {\n            addNotification(t('Failed to jump to the first unread message'), 'error');\n            return;\n        }\n        if (!channelUnreadUiState.first_unread_message_id)\n            _setChannelUnreadUiState({\n                ...channelUnreadUiState,\n                first_unread_message_id: firstUnreadMessageId,\n                last_read_message_id: lastReadMessageId,\n            });\n        handleHighlightedMessageChange({\n            highlightDuration,\n            highlightedMessageId: firstUnreadMessageId,\n        });\n    }, [\n        addNotification,\n        channel,\n        handleHighlightedMessageChange,\n        loadMoreFinished,\n        t,\n        channelUnreadUiState,\n    ]);\n    const deleteMessage = useCallback(async (message) => {\n        if (!message?.id) {\n            throw new Error('Cannot delete a message - missing message ID.');\n        }\n        let deletedMessage;\n        if (doDeleteMessageRequest) {\n            deletedMessage = await doDeleteMessageRequest(message);\n        }\n        else {\n            const result = await client.deleteMessage(message.id);\n            deletedMessage = result.message;\n        }\n        return deletedMessage;\n    }, [client, doDeleteMessageRequest]);\n    const updateMessage = (updatedMessage) => {\n        // add the message to the local channel state\n        channel.state.addMessageSorted(updatedMessage, true);\n        dispatch({\n            channel,\n            parentId: state.thread && updatedMessage.parent_id,\n            type: 'copyMessagesFromChannel',\n        });\n    };\n    const doSendMessage = async ({ localMessage, message, options, }) => {\n        try {\n            let messageResponse;\n            if (doSendMessageRequest) {\n                messageResponse = await doSendMessageRequest(channel, message, options);\n            }\n            else {\n                messageResponse = await channel.sendMessage(message, options);\n            }\n            let existingMessage = undefined;\n            for (let i = channel.state.messages.length - 1; i >= 0; i--) {\n                const msg = channel.state.messages[i];\n                if (msg.id && msg.id === message.id) {\n                    existingMessage = msg;\n                    break;\n                }\n            }\n            const responseTimestamp = new Date(messageResponse?.message?.updated_at || 0).getTime();\n            const existingMessageTimestamp = existingMessage?.updated_at?.getTime() || 0;\n            const responseIsTheNewest = responseTimestamp > existingMessageTimestamp;\n            // Replace the message payload after send is completed\n            // We need to check for the newest message payload, because on slow network, the response can arrive later than WS events message.new, message.updated.\n            // Always override existing message in status \"sending\"\n            if (messageResponse?.message &&\n                (responseIsTheNewest || existingMessage?.status === 'sending')) {\n                updateMessage({\n                    ...messageResponse.message,\n                    status: 'received',\n                });\n            }\n        }\n        catch (error) {\n            // error response isn't usable so needs to be stringified then parsed\n            const stringError = JSON.stringify(error);\n            const parsedError = (stringError ? JSON.parse(stringError) : {});\n            // Handle the case where the message already exists\n            // (typically, when retrying to send a message).\n            // If the message already exists, we can assume it was sent successfully,\n            // so we update the message status to \"received\".\n            // Right now, the only way to check this error is by checking\n            // the combination of the error code and the error description,\n            // since there is no special error code for duplicate messages.\n            if (parsedError.code === 4 &&\n                error instanceof Error &&\n                error.message.includes('already exists')) {\n                updateMessage({\n                    ...localMessage,\n                    status: 'received',\n                });\n            }\n            else {\n                updateMessage({\n                    ...localMessage,\n                    error: parsedError,\n                    status: 'failed',\n                });\n                thread?.upsertReplyLocally({\n                    message: {\n                        ...localMessage,\n                        error: parsedError,\n                        status: 'failed',\n                    },\n                });\n            }\n        }\n    };\n    const sendMessage = async ({ localMessage, message, options, }) => {\n        channel.state.filterErrorMessages();\n        thread?.upsertReplyLocally({\n            message: localMessage,\n        });\n        updateMessage(localMessage);\n        await doSendMessage({ localMessage, message, options });\n    };\n    const retrySendMessage = async (localMessage) => {\n        updateMessage({\n            ...localMessage,\n            error: undefined,\n            status: 'sending',\n        });\n        await doSendMessage({\n            localMessage,\n            message: localMessageToNewMessagePayload(localMessage),\n        });\n    };\n    const removeMessage = (message) => {\n        channel.state.removeMessage(message);\n        dispatch({\n            channel,\n            parentId: state.thread && message.parent_id,\n            type: 'copyMessagesFromChannel',\n        });\n    };\n    /** THREAD */\n    const openThread = (message, event) => {\n        event?.preventDefault();\n        dispatch({ channel, message, type: 'openThread' });\n    };\n    const closeThread = (event) => {\n        event?.preventDefault();\n        dispatch({ type: 'closeThread' });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const loadMoreThreadFinished = useCallback(debounce((threadHasMore, threadMessages) => {\n        dispatch({\n            threadHasMore,\n            threadMessages,\n            type: 'loadMoreThreadFinished',\n        });\n    }, 2000, { leading: true, trailing: true }), []);\n    const loadMoreThread = async (limit = DEFAULT_THREAD_PAGE_SIZE) => {\n        // FIXME: should prevent loading more, if state.thread.reply_count === channel.state.threads[parentID].length\n        if (state.threadLoadingMore || !state.thread || !state.threadHasMore)\n            return;\n        dispatch({ type: 'startLoadingThread' });\n        const parentId = state.thread.id;\n        if (!parentId) {\n            return dispatch({ type: 'closeThread' });\n        }\n        const oldMessages = channel.state.threads[parentId] || [];\n        const oldestMessageId = oldMessages[0]?.id;\n        try {\n            const queryResponse = await channel.getReplies(parentId, {\n                id_lt: oldestMessageId,\n                limit,\n            });\n            const threadHasMoreMessages = hasMoreMessagesProbably(queryResponse.messages.length, limit);\n            const newThreadMessages = channel.state.threads[parentId] || [];\n            // next set loadingMore to false so we can start asking for more data\n            loadMoreThreadFinished(threadHasMoreMessages, newThreadMessages);\n        }\n        catch (e) {\n            loadMoreThreadFinished(false, oldMessages);\n        }\n    };\n    const onMentionsHoverOrClick = useMentionsHandlers(onMentionsHover, onMentionsClick);\n    const editMessage = useEditMessageHandler(doUpdateMessageRequest);\n    const { typing, ...restState } = state;\n    const channelStateContextValue = useCreateChannelStateContext({\n        ...restState,\n        channel,\n        channelCapabilitiesArray,\n        channelConfig,\n        channelUnreadUiState,\n        giphyVersion: props.giphyVersion || 'fixed_height',\n        imageAttachmentSizeHandler: props.imageAttachmentSizeHandler || getImageAttachmentConfiguration,\n        mutes,\n        notifications,\n        shouldGenerateVideoThumbnail: props.shouldGenerateVideoThumbnail || true,\n        videoAttachmentSizeHandler: props.videoAttachmentSizeHandler || getVideoAttachmentConfiguration,\n        watcher_count: state.watcherCount,\n    });\n    const channelActionContextValue = useMemo(() => ({\n        addNotification,\n        closeThread,\n        deleteMessage,\n        dispatch,\n        editMessage,\n        jumpToFirstUnreadMessage,\n        jumpToLatestMessage,\n        jumpToMessage,\n        loadMore,\n        loadMoreNewer,\n        loadMoreThread,\n        markRead,\n        onMentionsClick: onMentionsHoverOrClick,\n        onMentionsHover: onMentionsHoverOrClick,\n        openThread,\n        removeMessage,\n        retrySendMessage,\n        sendMessage,\n        setChannelUnreadUiState,\n        skipMessageDataMemoization,\n        updateMessage,\n    }), \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        channel.cid,\n        deleteMessage,\n        loadMore,\n        loadMoreNewer,\n        markRead,\n        jumpToFirstUnreadMessage,\n        jumpToMessage,\n        jumpToLatestMessage,\n        setChannelUnreadUiState,\n    ]);\n    const componentContextValue = useMemo(() => ({\n        Attachment: props.Attachment,\n        AttachmentPreviewList: props.AttachmentPreviewList,\n        AttachmentSelector: props.AttachmentSelector,\n        AttachmentSelectorInitiationButtonContents: props.AttachmentSelectorInitiationButtonContents,\n        AudioRecorder: props.AudioRecorder,\n        AutocompleteSuggestionItem: props.AutocompleteSuggestionItem,\n        AutocompleteSuggestionList: props.AutocompleteSuggestionList,\n        Avatar: props.Avatar,\n        BaseImage: props.BaseImage,\n        CooldownTimer: props.CooldownTimer,\n        CustomMessageActionsList: props.CustomMessageActionsList,\n        DateSeparator: props.DateSeparator,\n        EditMessageInput: props.EditMessageInput,\n        EmojiPicker: props.EmojiPicker,\n        emojiSearchIndex: props.emojiSearchIndex,\n        EmptyStateIndicator: props.EmptyStateIndicator,\n        FileUploadIcon: props.FileUploadIcon,\n        GiphyPreviewMessage: props.GiphyPreviewMessage,\n        HeaderComponent: props.HeaderComponent,\n        Input: props.Input,\n        LinkPreviewList: props.LinkPreviewList,\n        LoadingIndicator: props.LoadingIndicator,\n        Message: props.Message,\n        MessageActions: props.MessageActions,\n        MessageBlocked: props.MessageBlocked,\n        MessageBouncePrompt: props.MessageBouncePrompt,\n        MessageDeleted: props.MessageDeleted,\n        MessageIsThreadReplyInChannelButtonIndicator: props.MessageIsThreadReplyInChannelButtonIndicator,\n        MessageListNotifications: props.MessageListNotifications,\n        MessageNotification: props.MessageNotification,\n        MessageOptions: props.MessageOptions,\n        MessageRepliesCountButton: props.MessageRepliesCountButton,\n        MessageStatus: props.MessageStatus,\n        MessageSystem: props.MessageSystem,\n        MessageTimestamp: props.MessageTimestamp,\n        ModalGallery: props.ModalGallery,\n        PinIndicator: props.PinIndicator,\n        PollActions: props.PollActions,\n        PollContent: props.PollContent,\n        PollCreationDialog: props.PollCreationDialog,\n        PollHeader: props.PollHeader,\n        PollOptionSelector: props.PollOptionSelector,\n        QuotedMessage: props.QuotedMessage,\n        QuotedMessagePreview: props.QuotedMessagePreview,\n        QuotedPoll: props.QuotedPoll,\n        reactionOptions: props.reactionOptions,\n        ReactionSelector: props.ReactionSelector,\n        ReactionsList: props.ReactionsList,\n        ReactionsListModal: props.ReactionsListModal,\n        ReminderNotification: props.ReminderNotification,\n        SendButton: props.SendButton,\n        SendToChannelCheckbox: props.SendToChannelCheckbox,\n        StartRecordingAudioButton: props.StartRecordingAudioButton,\n        StopAIGenerationButton: props.StopAIGenerationButton,\n        StreamedMessageText: props.StreamedMessageText,\n        TextareaComposer: props.TextareaComposer,\n        ThreadHead: props.ThreadHead,\n        ThreadHeader: props.ThreadHeader,\n        ThreadStart: props.ThreadStart,\n        Timestamp: props.Timestamp,\n        TypingIndicator: props.TypingIndicator,\n        UnreadMessagesNotification: props.UnreadMessagesNotification,\n        UnreadMessagesSeparator: props.UnreadMessagesSeparator,\n        VirtualMessage: props.VirtualMessage,\n    }), [\n        props.Attachment,\n        props.AttachmentPreviewList,\n        props.AttachmentSelector,\n        props.AttachmentSelectorInitiationButtonContents,\n        props.AudioRecorder,\n        props.AutocompleteSuggestionItem,\n        props.AutocompleteSuggestionList,\n        props.Avatar,\n        props.BaseImage,\n        props.CooldownTimer,\n        props.CustomMessageActionsList,\n        props.DateSeparator,\n        props.EditMessageInput,\n        props.EmojiPicker,\n        props.emojiSearchIndex,\n        props.EmptyStateIndicator,\n        props.FileUploadIcon,\n        props.GiphyPreviewMessage,\n        props.HeaderComponent,\n        props.Input,\n        props.LinkPreviewList,\n        props.LoadingIndicator,\n        props.Message,\n        props.MessageActions,\n        props.MessageBlocked,\n        props.MessageBouncePrompt,\n        props.MessageDeleted,\n        props.MessageIsThreadReplyInChannelButtonIndicator,\n        props.MessageListNotifications,\n        props.MessageNotification,\n        props.MessageOptions,\n        props.MessageRepliesCountButton,\n        props.MessageStatus,\n        props.MessageSystem,\n        props.MessageTimestamp,\n        props.ModalGallery,\n        props.PinIndicator,\n        props.PollActions,\n        props.PollContent,\n        props.PollCreationDialog,\n        props.PollHeader,\n        props.PollOptionSelector,\n        props.QuotedMessage,\n        props.QuotedMessagePreview,\n        props.QuotedPoll,\n        props.reactionOptions,\n        props.ReactionSelector,\n        props.ReactionsList,\n        props.ReactionsListModal,\n        props.ReminderNotification,\n        props.SendButton,\n        props.SendToChannelCheckbox,\n        props.StartRecordingAudioButton,\n        props.StopAIGenerationButton,\n        props.StreamedMessageText,\n        props.TextareaComposer,\n        props.ThreadHead,\n        props.ThreadHeader,\n        props.ThreadStart,\n        props.Timestamp,\n        props.TypingIndicator,\n        props.UnreadMessagesNotification,\n        props.UnreadMessagesSeparator,\n        props.VirtualMessage,\n    ]);\n    const typingContextValue = useCreateTypingContext({\n        typing,\n    });\n    if (state.error) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingErrorIndicator, { error: state.error })));\n    }\n    if (state.loading) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(LoadingIndicator, null)));\n    }\n    if (!channel.watch) {\n        return (React.createElement(ChannelContainer, null,\n            React.createElement(\"div\", null, t('Channel Missing'))));\n    }\n    return (React.createElement(ChannelContainer, { className: windowsEmojiClass },\n        React.createElement(ChannelStateProvider, { value: channelStateContextValue },\n            React.createElement(ChannelActionProvider, { value: channelActionContextValue },\n                React.createElement(WithComponents, { overrides: componentContextValue },\n                    React.createElement(TypingProvider, { value: typingContextValue },\n                        React.createElement(\"div\", { className: clsx(chatContainerClass) }, children)))))));\n};\n/**\n * A wrapper component that provides channel data and renders children.\n * The Channel component provides the following contexts:\n * - [ChannelStateContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_state_context/)\n * - [ChannelActionContext](https://getstream.io/chat/docs/sdk/react/contexts/channel_action_context/)\n * - [ComponentContext](https://getstream.io/chat/docs/sdk/react/contexts/component_context/)\n * - [TypingContext](https://getstream.io/chat/docs/sdk/react/contexts/typing_context/)\n */\nexport const Channel = React.memo(UnMemoizedChannel);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}