{"ast":null,"code":"import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { MediaRecorderController } from '../classes';\nimport { useTranslationContext } from '../../../context';\nimport { useMessageComposer } from '../../MessageInput';\nexport const useMediaRecorder = _ref => {\n  let {\n    asyncMessagesMultiSendEnabled,\n    enabled,\n    generateRecordingTitle,\n    handleSubmit,\n    recordingConfig\n  } = _ref;\n  const {\n    t\n  } = useTranslationContext('useMediaRecorder');\n  const messageComposer = useMessageComposer();\n  const [recording, setRecording] = useState();\n  const [recordingState, setRecordingState] = useState();\n  const [permissionState, setPermissionState] = useState();\n  const [isScheduledForSubmit, scheduleForSubmit] = useState(false);\n  const recorder = useMemo(() => enabled ? new MediaRecorderController({\n    config: recordingConfig !== null && recordingConfig !== void 0 ? recordingConfig : {},\n    generateRecordingTitle,\n    t\n  }) : undefined, [recordingConfig, enabled, generateRecordingTitle, t]);\n  const completeRecording = useCallback(async () => {\n    if (!recorder) return;\n    const recording = await recorder.stop();\n    if (!recording) return;\n    await messageComposer.attachmentManager.uploadAttachment(recording);\n    if (!asyncMessagesMultiSendEnabled) {\n      // FIXME: cannot call handleSubmit() directly as the function has stale reference to attachments\n      scheduleForSubmit(true);\n    }\n    recorder.cleanUp();\n  }, [asyncMessagesMultiSendEnabled, messageComposer, recorder]);\n  useEffect(() => {\n    if (!isScheduledForSubmit) return;\n    handleSubmit();\n    scheduleForSubmit(false);\n  }, [handleSubmit, isScheduledForSubmit]);\n  useEffect(() => {\n    if (!recorder) return;\n    recorder.permission.watch();\n    const recordingSubscription = recorder.recording.subscribe(setRecording);\n    const recordingStateSubscription = recorder.recordingState.subscribe(setRecordingState);\n    const permissionStateSubscription = recorder.permission.state.subscribe(setPermissionState);\n    return () => {\n      recorder.cancel();\n      recorder.permission.unwatch();\n      recordingSubscription.unsubscribe();\n      recordingStateSubscription.unsubscribe();\n      permissionStateSubscription.unsubscribe();\n    };\n  }, [recorder]);\n  return {\n    completeRecording,\n    permissionState,\n    recorder,\n    recording,\n    recordingState\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useMemo","useState","MediaRecorderController","useTranslationContext","useMessageComposer","useMediaRecorder","_ref","asyncMessagesMultiSendEnabled","enabled","generateRecordingTitle","handleSubmit","recordingConfig","t","messageComposer","recording","setRecording","recordingState","setRecordingState","permissionState","setPermissionState","isScheduledForSubmit","scheduleForSubmit","recorder","config","undefined","completeRecording","stop","attachmentManager","uploadAttachment","cleanUp","permission","watch","recordingSubscription","subscribe","recordingStateSubscription","permissionStateSubscription","state","cancel","unwatch","unsubscribe"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MediaRecorder/hooks/useMediaRecorder.js"],"sourcesContent":["import { useCallback, useEffect, useMemo, useState } from 'react';\nimport { MediaRecorderController } from '../classes';\nimport { useTranslationContext } from '../../../context';\nimport { useMessageComposer } from '../../MessageInput';\nexport const useMediaRecorder = ({ asyncMessagesMultiSendEnabled, enabled, generateRecordingTitle, handleSubmit, recordingConfig, }) => {\n    const { t } = useTranslationContext('useMediaRecorder');\n    const messageComposer = useMessageComposer();\n    const [recording, setRecording] = useState();\n    const [recordingState, setRecordingState] = useState();\n    const [permissionState, setPermissionState] = useState();\n    const [isScheduledForSubmit, scheduleForSubmit] = useState(false);\n    const recorder = useMemo(() => enabled\n        ? new MediaRecorderController({\n            config: recordingConfig ?? {},\n            generateRecordingTitle,\n            t,\n        })\n        : undefined, [recordingConfig, enabled, generateRecordingTitle, t]);\n    const completeRecording = useCallback(async () => {\n        if (!recorder)\n            return;\n        const recording = await recorder.stop();\n        if (!recording)\n            return;\n        await messageComposer.attachmentManager.uploadAttachment(recording);\n        if (!asyncMessagesMultiSendEnabled) {\n            // FIXME: cannot call handleSubmit() directly as the function has stale reference to attachments\n            scheduleForSubmit(true);\n        }\n        recorder.cleanUp();\n    }, [asyncMessagesMultiSendEnabled, messageComposer, recorder]);\n    useEffect(() => {\n        if (!isScheduledForSubmit)\n            return;\n        handleSubmit();\n        scheduleForSubmit(false);\n    }, [handleSubmit, isScheduledForSubmit]);\n    useEffect(() => {\n        if (!recorder)\n            return;\n        recorder.permission.watch();\n        const recordingSubscription = recorder.recording.subscribe(setRecording);\n        const recordingStateSubscription = recorder.recordingState.subscribe(setRecordingState);\n        const permissionStateSubscription = recorder.permission.state.subscribe(setPermissionState);\n        return () => {\n            recorder.cancel();\n            recorder.permission.unwatch();\n            recordingSubscription.unsubscribe();\n            recordingStateSubscription.unsubscribe();\n            permissionStateSubscription.unsubscribe();\n        };\n    }, [recorder]);\n    return {\n        completeRecording,\n        permissionState,\n        recorder,\n        recording,\n        recordingState,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}