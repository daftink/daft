{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useCallback } from 'react';\nimport throttle from 'lodash.throttle';\nimport { useThreadContext } from '../../Threads';\nimport { useChannelActionContext } from '../../../context/ChannelActionContext';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nimport { useChatContext } from '../../../context/ChatContext';\nexport const reactionHandlerWarning = \"Reaction handler was called, but it is missing one of its required arguments.\\nMake sure the ChannelAction and ChannelState contexts are properly set and the hook is initialized with a valid message.\";\nexport const useReactionHandler = message => {\n  const thread = useThreadContext();\n  const {\n    updateMessage\n  } = useChannelActionContext('useReactionHandler');\n  const {\n    channel,\n    channelCapabilities\n  } = useChannelStateContext('useReactionHandler');\n  const {\n    client\n  } = useChatContext('useReactionHandler');\n  const createMessagePreview = useCallback((add, reaction, message) => {\n    var _message$latest_react, _message$own_reaction;\n    const newReactionGroups = (message === null || message === void 0 ? void 0 : message.reaction_groups) || {};\n    const reactionType = reaction.type;\n    const hasReaction = !!newReactionGroups[reactionType];\n    if (add) {\n      const timestamp = new Date().toISOString();\n      newReactionGroups[reactionType] = hasReaction ? _objectSpread(_objectSpread({}, newReactionGroups[reactionType]), {}, {\n        count: newReactionGroups[reactionType].count + 1\n      }) : {\n        count: 1,\n        first_reaction_at: timestamp,\n        last_reaction_at: timestamp,\n        sum_scores: 1\n      };\n    } else {\n      if (hasReaction && newReactionGroups[reactionType].count > 1) {\n        newReactionGroups[reactionType] = _objectSpread(_objectSpread({}, newReactionGroups[reactionType]), {}, {\n          count: newReactionGroups[reactionType].count - 1\n        });\n      } else {\n        delete newReactionGroups[reactionType];\n      }\n    }\n    const newReactions = add ? [reaction, ...((message === null || message === void 0 ? void 0 : message.latest_reactions) || [])] : (_message$latest_react = message.latest_reactions) === null || _message$latest_react === void 0 ? void 0 : _message$latest_react.filter(item => !(item.type === reaction.type && item.user_id === reaction.user_id));\n    const newOwnReactions = add ? [reaction, ...((message === null || message === void 0 ? void 0 : message.own_reactions) || [])] : message === null || message === void 0 || (_message$own_reaction = message.own_reactions) === null || _message$own_reaction === void 0 ? void 0 : _message$own_reaction.filter(item => item.type !== reaction.type);\n    return _objectSpread(_objectSpread({}, message), {}, {\n      latest_reactions: newReactions || message.latest_reactions,\n      own_reactions: newOwnReactions,\n      reaction_groups: newReactionGroups\n    });\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [client.user, client.userID]);\n  const createReactionPreview = type => {\n    var _client$user;\n    return {\n      message_id: message === null || message === void 0 ? void 0 : message.id,\n      score: 1,\n      type,\n      user: client.user,\n      user_id: (_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.id\n    };\n  };\n  const toggleReaction = throttle(async (id, type, add) => {\n    if (!message || !channelCapabilities['send-reaction']) return;\n    const newReaction = createReactionPreview(type);\n    const tempMessage = createMessagePreview(add, newReaction, message);\n    try {\n      updateMessage(tempMessage);\n      thread === null || thread === void 0 || thread.upsertReplyLocally({\n        message: tempMessage\n      });\n      const messageResponse = add ? await channel.sendReaction(id, {\n        type\n      }) : await channel.deleteReaction(id, type);\n      // seems useless as we're expecting WS event to come in and replace this anyway\n      updateMessage(messageResponse.message);\n    } catch (error) {\n      // revert to the original message if the API call fails\n      updateMessage(message);\n      thread === null || thread === void 0 || thread.upsertReplyLocally({\n        message\n      });\n    }\n  }, 1000);\n  return async (reactionType, event) => {\n    if (event !== null && event !== void 0 && event.preventDefault) {\n      event.preventDefault();\n    }\n    if (!message) {\n      return console.warn(reactionHandlerWarning);\n    }\n    let userExistingReaction = null;\n    if (message.own_reactions) {\n      message.own_reactions.forEach(reaction => {\n        // own user should only ever contain the current user id\n        // just in case we check to prevent bugs with message updates from breaking reactions\n        if (reaction.user && client.userID === reaction.user.id && reaction.type === reactionType) {\n          userExistingReaction = reaction;\n        } else if (reaction.user && client.userID !== reaction.user.id) {\n          console.warn(\"message.own_reactions contained reactions from a different user, this indicates a bug\");\n        }\n      });\n    }\n    try {\n      if (userExistingReaction) {\n        await toggleReaction(message.id, userExistingReaction.type, false);\n      } else {\n        await toggleReaction(message.id, reactionType, true);\n      }\n    } catch (error) {\n      console.log({\n        error\n      });\n    }\n  };\n};","map":{"version":3,"names":["useCallback","throttle","useThreadContext","useChannelActionContext","useChannelStateContext","useChatContext","reactionHandlerWarning","useReactionHandler","message","thread","updateMessage","channel","channelCapabilities","client","createMessagePreview","add","reaction","_message$latest_react","_message$own_reaction","newReactionGroups","reaction_groups","reactionType","type","hasReaction","timestamp","Date","toISOString","_objectSpread","count","first_reaction_at","last_reaction_at","sum_scores","newReactions","latest_reactions","filter","item","user_id","newOwnReactions","own_reactions","user","userID","createReactionPreview","_client$user","message_id","id","score","toggleReaction","newReaction","tempMessage","upsertReplyLocally","messageResponse","sendReaction","deleteReaction","error","event","preventDefault","console","warn","userExistingReaction","forEach","log"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/Message/hooks/useReactionHandler.js"],"sourcesContent":["import { useCallback } from 'react';\nimport throttle from 'lodash.throttle';\nimport { useThreadContext } from '../../Threads';\nimport { useChannelActionContext } from '../../../context/ChannelActionContext';\nimport { useChannelStateContext } from '../../../context/ChannelStateContext';\nimport { useChatContext } from '../../../context/ChatContext';\nexport const reactionHandlerWarning = `Reaction handler was called, but it is missing one of its required arguments.\nMake sure the ChannelAction and ChannelState contexts are properly set and the hook is initialized with a valid message.`;\nexport const useReactionHandler = (message) => {\n    const thread = useThreadContext();\n    const { updateMessage } = useChannelActionContext('useReactionHandler');\n    const { channel, channelCapabilities } = useChannelStateContext('useReactionHandler');\n    const { client } = useChatContext('useReactionHandler');\n    const createMessagePreview = useCallback((add, reaction, message) => {\n        const newReactionGroups = message?.reaction_groups || {};\n        const reactionType = reaction.type;\n        const hasReaction = !!newReactionGroups[reactionType];\n        if (add) {\n            const timestamp = new Date().toISOString();\n            newReactionGroups[reactionType] = hasReaction\n                ? {\n                    ...newReactionGroups[reactionType],\n                    count: newReactionGroups[reactionType].count + 1,\n                }\n                : {\n                    count: 1,\n                    first_reaction_at: timestamp,\n                    last_reaction_at: timestamp,\n                    sum_scores: 1,\n                };\n        }\n        else {\n            if (hasReaction && newReactionGroups[reactionType].count > 1) {\n                newReactionGroups[reactionType] = {\n                    ...newReactionGroups[reactionType],\n                    count: newReactionGroups[reactionType].count - 1,\n                };\n            }\n            else {\n                delete newReactionGroups[reactionType];\n            }\n        }\n        const newReactions = add\n            ? [reaction, ...(message?.latest_reactions || [])]\n            : message.latest_reactions?.filter((item) => !(item.type === reaction.type && item.user_id === reaction.user_id));\n        const newOwnReactions = add\n            ? [reaction, ...(message?.own_reactions || [])]\n            : message?.own_reactions?.filter((item) => item.type !== reaction.type);\n        return {\n            ...message,\n            latest_reactions: newReactions || message.latest_reactions,\n            own_reactions: newOwnReactions,\n            reaction_groups: newReactionGroups,\n        };\n    }, \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client.user, client.userID]);\n    const createReactionPreview = (type) => ({\n        message_id: message?.id,\n        score: 1,\n        type,\n        user: client.user,\n        user_id: client.user?.id,\n    });\n    const toggleReaction = throttle(async (id, type, add) => {\n        if (!message || !channelCapabilities['send-reaction'])\n            return;\n        const newReaction = createReactionPreview(type);\n        const tempMessage = createMessagePreview(add, newReaction, message);\n        try {\n            updateMessage(tempMessage);\n            thread?.upsertReplyLocally({ message: tempMessage });\n            const messageResponse = add\n                ? await channel.sendReaction(id, { type })\n                : await channel.deleteReaction(id, type);\n            // seems useless as we're expecting WS event to come in and replace this anyway\n            updateMessage(messageResponse.message);\n        }\n        catch (error) {\n            // revert to the original message if the API call fails\n            updateMessage(message);\n            thread?.upsertReplyLocally({ message });\n        }\n    }, 1000);\n    return async (reactionType, event) => {\n        if (event?.preventDefault) {\n            event.preventDefault();\n        }\n        if (!message) {\n            return console.warn(reactionHandlerWarning);\n        }\n        let userExistingReaction = null;\n        if (message.own_reactions) {\n            message.own_reactions.forEach((reaction) => {\n                // own user should only ever contain the current user id\n                // just in case we check to prevent bugs with message updates from breaking reactions\n                if (reaction.user &&\n                    client.userID === reaction.user.id &&\n                    reaction.type === reactionType) {\n                    userExistingReaction = reaction;\n                }\n                else if (reaction.user && client.userID !== reaction.user.id) {\n                    console.warn(`message.own_reactions contained reactions from a different user, this indicates a bug`);\n                }\n            });\n        }\n        try {\n            if (userExistingReaction) {\n                await toggleReaction(message.id, userExistingReaction.type, false);\n            }\n            else {\n                await toggleReaction(message.id, reactionType, true);\n            }\n        }\n        catch (error) {\n            console.log({ error });\n        }\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}