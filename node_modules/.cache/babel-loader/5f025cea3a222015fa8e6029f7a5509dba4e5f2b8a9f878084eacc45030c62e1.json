{"ast":null,"code":"import { renderAudio, toAudioBuffer } from './audioProcessing';\nconst WAV_HEADER_LENGTH_BYTES = 44;\nconst BYTES_PER_SAMPLE = 2;\nconst RIFF_FILE_MAX_BYTES = 4294967295;\nconst HEADER = {\n  AUDIO_FORMAT: {\n    offset: 20,\n    value: 1\n  },\n  // PCM = 1\n  BITS_PER_SAMPLE: {\n    offset: 34,\n    value: BYTES_PER_SAMPLE * 8\n  },\n  // 16 bits encoding\n  BLOCK_ALIGN: {\n    offset: 32\n  },\n  BYTE_RATE: {\n    offset: 28\n  },\n  CHANNEL_COUNT: {\n    offset: 22\n  },\n  // 1 - mono, 2 - stereo\n  CHUNK_ID: {\n    offset: 0,\n    value: 0x52494646\n  },\n  // hex representation of string \"RIFF\" (Resource Interchange File Format) - identifies the file structure that defines a class of more specific file formats, e.g. WAVE\n  CHUNK_SIZE: {\n    offset: 4\n  },\n  FILE_FORMAT: {\n    offset: 8,\n    value: 0x57415645\n  },\n  // hex representation of string \"WAVE\"\n  SAMPLE_RATE: {\n    offset: 24\n  },\n  SUBCHUNK1_ID: {\n    offset: 12,\n    value: 0x666d7420\n  },\n  // hex representation of string \"fmt \" - identifies the start of \"format\" section of the header\n  SUBCHUNK1_SIZE: {\n    offset: 16,\n    value: 16\n  },\n  // Subchunk1 Size without SUBCHUNK1_ID and SUBCHUNK1_SIZE fields\n  SUBCHUNK2_ID: {\n    offset: 36,\n    value: 0x64617461\n  },\n  // hex representation of string \"data\" - identifies the start of actual audio data section\n  SUBCHUNK2_SIZE: {\n    offset: 40\n  } // actual audio data size\n};\nconst fourCharsToInt = chars => chars.charCodeAt(0) << 24 | chars.charCodeAt(1) << 16 | chars.charCodeAt(2) << 8 | chars.charCodeAt(3);\nconst WAV_HEADER_FLAGS = {\n  data: fourCharsToInt('data'),\n  fmt: fourCharsToInt('fmt '),\n  RIFF: fourCharsToInt('RIFF'),\n  WAVE: fourCharsToInt('WAVE')\n};\nconst writeWavHeader = _ref => {\n  let {\n    arrayBuffer,\n    channelCount,\n    sampleRate\n  } = _ref;\n  const byteRate = sampleRate * channelCount * BYTES_PER_SAMPLE; // bytes/sec\n  const blockAlign = channelCount * BYTES_PER_SAMPLE;\n  const dataView = new DataView(arrayBuffer);\n  /*\n   * The maximum size of a RIFF file is 4294967295 bytes and since the header takes up 44 bytes there are 4294967251 bytes left for the\n   * data chunk.\n   */\n  const dataChunkSize = Math.min(dataView.byteLength - WAV_HEADER_LENGTH_BYTES, RIFF_FILE_MAX_BYTES - WAV_HEADER_LENGTH_BYTES);\n  dataView.setUint32(HEADER.CHUNK_ID.offset, HEADER.CHUNK_ID.value); // \"RIFF\"\n  dataView.setUint32(HEADER.CHUNK_SIZE.offset, arrayBuffer.byteLength - 8, true); // adjustment for the first two headers - chunk id + file size\n  dataView.setUint32(HEADER.FILE_FORMAT.offset, HEADER.FILE_FORMAT.value); // \"WAVE\"\n  dataView.setUint32(HEADER.SUBCHUNK1_ID.offset, HEADER.SUBCHUNK1_ID.value); // \"fmt \"\n  dataView.setUint32(HEADER.SUBCHUNK1_SIZE.offset, HEADER.SUBCHUNK1_SIZE.value, true);\n  dataView.setUint16(HEADER.AUDIO_FORMAT.offset, HEADER.AUDIO_FORMAT.value, true);\n  dataView.setUint16(HEADER.CHANNEL_COUNT.offset, channelCount, true);\n  dataView.setUint32(HEADER.SAMPLE_RATE.offset, sampleRate, true);\n  dataView.setUint32(HEADER.BYTE_RATE.offset, byteRate, true);\n  dataView.setUint16(HEADER.BLOCK_ALIGN.offset, blockAlign, true);\n  dataView.setUint16(HEADER.BITS_PER_SAMPLE.offset, HEADER.BITS_PER_SAMPLE.value, true);\n  dataView.setUint32(HEADER.SUBCHUNK2_ID.offset, HEADER.SUBCHUNK2_ID.value); // \"data\"\n  dataView.setUint32(HEADER.SUBCHUNK2_SIZE.offset, dataChunkSize, true);\n};\nexport const readWavHeader = dataView => {\n  const header = dataView.getUint32(0, false);\n  if (WAV_HEADER_FLAGS.RIFF !== header) {\n    console.error('Missing RIFF header in WAVE file');\n    return;\n  }\n  if (WAV_HEADER_FLAGS.WAVE !== dataView.getUint32(HEADER.FILE_FORMAT.offset, false)) {\n    console.error('Missing WAVE header in WAVE file');\n    return;\n  }\n  if (WAV_HEADER_FLAGS.fmt !== dataView.getUint32(HEADER.SUBCHUNK1_ID.offset, false)) {\n    console.error('Missing fmt header in WAVE file');\n    return;\n  }\n  return {\n    audioDataSizeBytes: dataView.getUint32(HEADER.SUBCHUNK2_SIZE.offset, true),\n    audioDataStartOffset: WAV_HEADER_LENGTH_BYTES,\n    channelCount: dataView.getUint16(HEADER.CHANNEL_COUNT.offset, true),\n    sampleRate: dataView.getUint32(HEADER.SAMPLE_RATE.offset, true)\n  };\n};\nconst splitDataByChannel = audioBuffer => Array.from({\n  length: audioBuffer.numberOfChannels\n}, (_, i) => audioBuffer.getChannelData(i));\n/**\n * In a WAV file, samples for each channel are usually interleaved, meaning samples from each channel are grouped together sequentially.\n * For example, in a stereo audio file (2 channels), samples alternate between the left and right channels.\n * @param arrayBuffer\n * @param dataByChannel\n */\nconst writeWavAudioData = _ref2 => {\n  let {\n    arrayBuffer,\n    dataByChannel\n  } = _ref2;\n  const dataView = new DataView(arrayBuffer);\n  const channelCount = dataByChannel.length;\n  dataByChannel.forEach((channelData, channelIndex) => {\n    let writeOffset = WAV_HEADER_LENGTH_BYTES + channelCount * channelIndex;\n    channelData.forEach(float32Value => {\n      dataView.setInt16(writeOffset, float32Value < 0 ? Math.max(-1, float32Value) * 32768 : Math.min(1, float32Value) * 32767, true);\n      writeOffset += channelCount * BYTES_PER_SAMPLE;\n    });\n  });\n};\nexport const encodeToWaw = async (file, sampleRate) => {\n  const audioBuffer = await renderAudio(await toAudioBuffer(file), sampleRate);\n  const numberOfSamples = audioBuffer.duration * sampleRate;\n  const fileSizeBytes = numberOfSamples * audioBuffer.numberOfChannels * BYTES_PER_SAMPLE + WAV_HEADER_LENGTH_BYTES;\n  const arrayBuffer = new ArrayBuffer(fileSizeBytes);\n  writeWavHeader({\n    arrayBuffer,\n    channelCount: audioBuffer.numberOfChannels,\n    sampleRate\n  });\n  writeWavAudioData({\n    arrayBuffer,\n    dataByChannel: splitDataByChannel(audioBuffer)\n  });\n  return new Blob([arrayBuffer], {\n    type: 'audio/wav'\n  });\n};","map":{"version":3,"names":["renderAudio","toAudioBuffer","WAV_HEADER_LENGTH_BYTES","BYTES_PER_SAMPLE","RIFF_FILE_MAX_BYTES","HEADER","AUDIO_FORMAT","offset","value","BITS_PER_SAMPLE","BLOCK_ALIGN","BYTE_RATE","CHANNEL_COUNT","CHUNK_ID","CHUNK_SIZE","FILE_FORMAT","SAMPLE_RATE","SUBCHUNK1_ID","SUBCHUNK1_SIZE","SUBCHUNK2_ID","SUBCHUNK2_SIZE","fourCharsToInt","chars","charCodeAt","WAV_HEADER_FLAGS","data","fmt","RIFF","WAVE","writeWavHeader","_ref","arrayBuffer","channelCount","sampleRate","byteRate","blockAlign","dataView","DataView","dataChunkSize","Math","min","byteLength","setUint32","setUint16","readWavHeader","header","getUint32","console","error","audioDataSizeBytes","audioDataStartOffset","getUint16","splitDataByChannel","audioBuffer","Array","from","length","numberOfChannels","_","i","getChannelData","writeWavAudioData","_ref2","dataByChannel","forEach","channelData","channelIndex","writeOffset","float32Value","setInt16","max","encodeToWaw","file","numberOfSamples","duration","fileSizeBytes","ArrayBuffer","Blob","type"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MediaRecorder/transcode/wav.js"],"sourcesContent":["import { renderAudio, toAudioBuffer } from './audioProcessing';\nconst WAV_HEADER_LENGTH_BYTES = 44;\nconst BYTES_PER_SAMPLE = 2;\nconst RIFF_FILE_MAX_BYTES = 4294967295;\nconst HEADER = {\n    AUDIO_FORMAT: { offset: 20, value: 1 }, // PCM = 1\n    BITS_PER_SAMPLE: { offset: 34, value: BYTES_PER_SAMPLE * 8 }, // 16 bits encoding\n    BLOCK_ALIGN: { offset: 32 },\n    BYTE_RATE: { offset: 28 },\n    CHANNEL_COUNT: { offset: 22 }, // 1 - mono, 2 - stereo\n    CHUNK_ID: { offset: 0, value: 0x52494646 }, // hex representation of string \"RIFF\" (Resource Interchange File Format) - identifies the file structure that defines a class of more specific file formats, e.g. WAVE\n    CHUNK_SIZE: { offset: 4 },\n    FILE_FORMAT: { offset: 8, value: 0x57415645 }, // hex representation of string \"WAVE\"\n    SAMPLE_RATE: { offset: 24 },\n    SUBCHUNK1_ID: { offset: 12, value: 0x666d7420 }, // hex representation of string \"fmt \" - identifies the start of \"format\" section of the header\n    SUBCHUNK1_SIZE: { offset: 16, value: 16 }, // Subchunk1 Size without SUBCHUNK1_ID and SUBCHUNK1_SIZE fields\n    SUBCHUNK2_ID: { offset: 36, value: 0x64617461 }, // hex representation of string \"data\" - identifies the start of actual audio data section\n    SUBCHUNK2_SIZE: { offset: 40 }, // actual audio data size\n};\nconst fourCharsToInt = (chars) => (chars.charCodeAt(0) << 24) |\n    (chars.charCodeAt(1) << 16) |\n    (chars.charCodeAt(2) << 8) |\n    chars.charCodeAt(3);\nconst WAV_HEADER_FLAGS = {\n    data: fourCharsToInt('data'),\n    fmt: fourCharsToInt('fmt '),\n    RIFF: fourCharsToInt('RIFF'),\n    WAVE: fourCharsToInt('WAVE'),\n};\nconst writeWavHeader = ({ arrayBuffer, channelCount, sampleRate, }) => {\n    const byteRate = sampleRate * channelCount * BYTES_PER_SAMPLE; // bytes/sec\n    const blockAlign = channelCount * BYTES_PER_SAMPLE;\n    const dataView = new DataView(arrayBuffer);\n    /*\n     * The maximum size of a RIFF file is 4294967295 bytes and since the header takes up 44 bytes there are 4294967251 bytes left for the\n     * data chunk.\n     */\n    const dataChunkSize = Math.min(dataView.byteLength - WAV_HEADER_LENGTH_BYTES, RIFF_FILE_MAX_BYTES - WAV_HEADER_LENGTH_BYTES);\n    dataView.setUint32(HEADER.CHUNK_ID.offset, HEADER.CHUNK_ID.value); // \"RIFF\"\n    dataView.setUint32(HEADER.CHUNK_SIZE.offset, arrayBuffer.byteLength - 8, true); // adjustment for the first two headers - chunk id + file size\n    dataView.setUint32(HEADER.FILE_FORMAT.offset, HEADER.FILE_FORMAT.value); // \"WAVE\"\n    dataView.setUint32(HEADER.SUBCHUNK1_ID.offset, HEADER.SUBCHUNK1_ID.value); // \"fmt \"\n    dataView.setUint32(HEADER.SUBCHUNK1_SIZE.offset, HEADER.SUBCHUNK1_SIZE.value, true);\n    dataView.setUint16(HEADER.AUDIO_FORMAT.offset, HEADER.AUDIO_FORMAT.value, true);\n    dataView.setUint16(HEADER.CHANNEL_COUNT.offset, channelCount, true);\n    dataView.setUint32(HEADER.SAMPLE_RATE.offset, sampleRate, true);\n    dataView.setUint32(HEADER.BYTE_RATE.offset, byteRate, true);\n    dataView.setUint16(HEADER.BLOCK_ALIGN.offset, blockAlign, true);\n    dataView.setUint16(HEADER.BITS_PER_SAMPLE.offset, HEADER.BITS_PER_SAMPLE.value, true);\n    dataView.setUint32(HEADER.SUBCHUNK2_ID.offset, HEADER.SUBCHUNK2_ID.value); // \"data\"\n    dataView.setUint32(HEADER.SUBCHUNK2_SIZE.offset, dataChunkSize, true);\n};\nexport const readWavHeader = (dataView) => {\n    const header = dataView.getUint32(0, false);\n    if (WAV_HEADER_FLAGS.RIFF !== header) {\n        console.error('Missing RIFF header in WAVE file');\n        return;\n    }\n    if (WAV_HEADER_FLAGS.WAVE !== dataView.getUint32(HEADER.FILE_FORMAT.offset, false)) {\n        console.error('Missing WAVE header in WAVE file');\n        return;\n    }\n    if (WAV_HEADER_FLAGS.fmt !== dataView.getUint32(HEADER.SUBCHUNK1_ID.offset, false)) {\n        console.error('Missing fmt header in WAVE file');\n        return;\n    }\n    return {\n        audioDataSizeBytes: dataView.getUint32(HEADER.SUBCHUNK2_SIZE.offset, true),\n        audioDataStartOffset: WAV_HEADER_LENGTH_BYTES,\n        channelCount: dataView.getUint16(HEADER.CHANNEL_COUNT.offset, true),\n        sampleRate: dataView.getUint32(HEADER.SAMPLE_RATE.offset, true),\n    };\n};\nconst splitDataByChannel = (audioBuffer) => Array.from({ length: audioBuffer.numberOfChannels }, (_, i) => audioBuffer.getChannelData(i));\n/**\n * In a WAV file, samples for each channel are usually interleaved, meaning samples from each channel are grouped together sequentially.\n * For example, in a stereo audio file (2 channels), samples alternate between the left and right channels.\n * @param arrayBuffer\n * @param dataByChannel\n */\nconst writeWavAudioData = ({ arrayBuffer, dataByChannel }) => {\n    const dataView = new DataView(arrayBuffer);\n    const channelCount = dataByChannel.length;\n    dataByChannel.forEach((channelData, channelIndex) => {\n        let writeOffset = WAV_HEADER_LENGTH_BYTES + channelCount * channelIndex;\n        channelData.forEach((float32Value) => {\n            dataView.setInt16(writeOffset, float32Value < 0\n                ? Math.max(-1, float32Value) * 32768\n                : Math.min(1, float32Value) * 32767, true);\n            writeOffset += channelCount * BYTES_PER_SAMPLE;\n        });\n    });\n};\nexport const encodeToWaw = async (file, sampleRate) => {\n    const audioBuffer = await renderAudio(await toAudioBuffer(file), sampleRate);\n    const numberOfSamples = audioBuffer.duration * sampleRate;\n    const fileSizeBytes = numberOfSamples * audioBuffer.numberOfChannels * BYTES_PER_SAMPLE +\n        WAV_HEADER_LENGTH_BYTES;\n    const arrayBuffer = new ArrayBuffer(fileSizeBytes);\n    writeWavHeader({ arrayBuffer, channelCount: audioBuffer.numberOfChannels, sampleRate });\n    writeWavAudioData({ arrayBuffer, dataByChannel: splitDataByChannel(audioBuffer) });\n    return new Blob([arrayBuffer], { type: 'audio/wav' });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}