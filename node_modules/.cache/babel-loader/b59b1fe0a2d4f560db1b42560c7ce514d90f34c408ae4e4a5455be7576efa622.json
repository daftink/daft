{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { extractSortValue, findLastPinnedChannelIndex, isChannelArchived, isChannelPinned, moveChannelUpwards, shouldConsiderArchivedChannels, shouldConsiderPinnedChannels } from '../utils';\nimport { useChatContext } from '../../../context';\nimport { getChannel } from '../../../utils';\nconst shared = _ref => {\n  let {\n    customHandler,\n    event,\n    setChannels\n  } = _ref;\n  if (typeof customHandler === 'function') {\n    return customHandler(setChannels, event);\n  }\n  setChannels(channels => {\n    const channelIndex = channels.findIndex(channel => channel.cid === event.cid);\n    if (channelIndex < 0) return channels;\n    channels.splice(channelIndex, 1);\n    return [...channels];\n  });\n};\nexport const useChannelListShapeDefaults = () => {\n  const {\n    client\n  } = useChatContext();\n  const handleMessageNew = useCallback(_ref2 => {\n    let {\n      allowNewMessagesFromUnfilteredChannels,\n      customHandler,\n      event,\n      filters,\n      lockChannelOrder,\n      setChannels,\n      sort\n    } = _ref2;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    const channelType = event.channel_type;\n    const channelId = event.channel_id;\n    if (!channelType || !channelId) return;\n    setChannels(currentChannels => {\n      const targetChannel = client.channel(channelType, channelId);\n      const targetChannelIndex = currentChannels.indexOf(targetChannel);\n      const targetChannelExistsWithinList = targetChannelIndex >= 0;\n      const isTargetChannelPinned = isChannelPinned(targetChannel);\n      const isTargetChannelArchived = isChannelArchived(targetChannel);\n      const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n      const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n      if (\n      // filter is defined, target channel is archived and filter option is set to false\n      considerArchivedChannels && isTargetChannelArchived && !filters.archived ||\n      // filter is defined, target channel isn't archived and filter option is set to true\n      considerArchivedChannels && !isTargetChannelArchived && filters.archived ||\n      // sort option is defined, target channel is pinned\n      considerPinnedChannels && isTargetChannelPinned ||\n      // list order is locked\n      lockChannelOrder ||\n      // target channel is not within the loaded list and loading from cache is disallowed\n      !targetChannelExistsWithinList && !allowNewMessagesFromUnfilteredChannels) {\n        return currentChannels;\n      }\n      return moveChannelUpwards({\n        channels: currentChannels,\n        channelToMove: targetChannel,\n        channelToMoveIndexWithinChannels: targetChannelIndex,\n        sort\n      });\n    });\n  }, [client]);\n  const handleNotificationMessageNew = useCallback(async _ref3 => {\n    let {\n      allowNewMessagesFromUnfilteredChannels,\n      customHandler,\n      event,\n      filters,\n      setChannels,\n      sort\n    } = _ref3;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    if (!event.channel) {\n      return;\n    }\n    const channel = await getChannel({\n      client,\n      id: event.channel.id,\n      type: event.channel.type\n    });\n    const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n    if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n      return;\n    }\n    if (!allowNewMessagesFromUnfilteredChannels) {\n      return;\n    }\n    setChannels(channels => moveChannelUpwards({\n      channels,\n      channelToMove: channel,\n      sort\n    }));\n  }, [client]);\n  const handleNotificationAddedToChannel = useCallback(async _ref4 => {\n    var _event$channel$member;\n    let {\n      allowNewMessagesFromUnfilteredChannels,\n      customHandler,\n      event,\n      setChannels,\n      sort\n    } = _ref4;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    if (!event.channel || !allowNewMessagesFromUnfilteredChannels) {\n      return;\n    }\n    const channel = await getChannel({\n      client,\n      id: event.channel.id,\n      members: (_event$channel$member = event.channel.members) === null || _event$channel$member === void 0 ? void 0 : _event$channel$member.reduce((newMembers, _ref5) => {\n        let {\n          user,\n          user_id\n        } = _ref5;\n        const userId = user_id || (user === null || user === void 0 ? void 0 : user.id);\n        if (userId) newMembers.push(userId);\n        return newMembers;\n      }, []),\n      type: event.channel.type\n    });\n    // membership has been reset (target channel shouldn't be pinned nor archived)\n    setChannels(channels => moveChannelUpwards({\n      channels,\n      channelToMove: channel,\n      sort\n    }));\n  }, [client]);\n  const handleNotificationRemovedFromChannel = useCallback(_ref6 => {\n    let {\n      customHandler,\n      event,\n      setChannels\n    } = _ref6;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    setChannels(channels => channels.filter(channel => {\n      var _event$channel;\n      return channel.cid !== ((_event$channel = event.channel) === null || _event$channel === void 0 ? void 0 : _event$channel.cid);\n    }));\n  }, []);\n  const handleMemberUpdated = useCallback(_ref7 => {\n    var _event$member;\n    let {\n      event,\n      filters,\n      lockChannelOrder,\n      setChannels,\n      sort\n    } = _ref7;\n    if (!((_event$member = event.member) !== null && _event$member !== void 0 && _event$member.user) || event.member.user.id !== client.userID || !event.channel_type) {\n      return;\n    }\n    const channelType = event.channel_type;\n    const channelId = event.channel_id;\n    const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n    const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n    // `pinned_at` nor `archived` properties are set or channel list order is locked, return early\n    if (!considerPinnedChannels && !considerArchivedChannels || lockChannelOrder) {\n      return;\n    }\n    const pinnedAtSort = extractSortValue({\n      atIndex: 0,\n      sort,\n      targetKey: 'pinned_at'\n    });\n    setChannels(currentChannels => {\n      const targetChannel = client.channel(channelType, channelId);\n      // assumes that channel instances are not changing\n      const targetChannelIndex = currentChannels.indexOf(targetChannel);\n      const targetChannelExistsWithinList = targetChannelIndex >= 0;\n      const isTargetChannelArchived = isChannelArchived(targetChannel);\n      const isTargetChannelPinned = isChannelPinned(targetChannel);\n      const newChannels = [...currentChannels];\n      if (targetChannelExistsWithinList) {\n        newChannels.splice(targetChannelIndex, 1);\n      }\n      // handle archiving (remove channel)\n      if (considerArchivedChannels && isTargetChannelArchived && !filters.archived || considerArchivedChannels && !isTargetChannelArchived && filters.archived) {\n        return newChannels;\n      }\n      let lastPinnedChannelIndex = null;\n      // calculate last pinned channel index only if `pinned_at` sort is set to\n      // ascending order or if it's in descending order while the pin is being removed, otherwise\n      // we move to the top (index 0)\n      if (pinnedAtSort === 1 || pinnedAtSort === -1 && !isTargetChannelPinned) {\n        lastPinnedChannelIndex = findLastPinnedChannelIndex({\n          channels: newChannels\n        });\n      }\n      const newTargetChannelIndex = typeof lastPinnedChannelIndex === 'number' ? lastPinnedChannelIndex + 1 : 0;\n      // skip re-render if the position of the channel does not change\n      if (currentChannels[newTargetChannelIndex] === targetChannel) {\n        return currentChannels;\n      }\n      newChannels.splice(newTargetChannelIndex, 0, targetChannel);\n      return newChannels;\n    });\n  }, [client]);\n  const handleChannelDeleted = useCallback(p => shared(p), []);\n  const handleChannelHidden = useCallback(p => shared(p), []);\n  const handleChannelVisible = useCallback(async _ref8 => {\n    let {\n      customHandler,\n      event,\n      filters,\n      setChannels,\n      sort\n    } = _ref8;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    if (!event.channel_id && !event.channel_type) {\n      return;\n    }\n    const channel = await getChannel({\n      client,\n      id: event.channel_id,\n      type: event.channel_type\n    });\n    const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n    if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n      return;\n    }\n    setChannels(channels => moveChannelUpwards({\n      channels,\n      channelToMove: channel,\n      sort\n    }));\n  }, [client]);\n  const handleChannelTruncated = useCallback(_ref9 => {\n    let {\n      customHandler,\n      event,\n      setChannels\n    } = _ref9;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    // TODO: not sure whether this is needed\n    setChannels(channels => [...channels]);\n    // if (forceUpdate) {\n    //   forceUpdate();\n    // }\n  }, []);\n  const handleChannelUpdated = useCallback(_ref0 => {\n    let {\n      customHandler,\n      event,\n      setChannels\n    } = _ref0;\n    if (typeof customHandler === 'function') {\n      return customHandler(setChannels, event);\n    }\n    setChannels(channels => {\n      const channelIndex = channels.findIndex(channel => {\n        var _event$channel2;\n        return channel.cid === ((_event$channel2 = event.channel) === null || _event$channel2 === void 0 ? void 0 : _event$channel2.cid);\n      });\n      if (channelIndex > -1 && event.channel) {\n        var _event$channel$hidden, _event$channel3, _newChannels$channelI, _event$channel$own_ca, _event$channel4, _newChannels$channelI2;\n        const newChannels = channels;\n        newChannels[channelIndex].data = _objectSpread(_objectSpread({}, event.channel), {}, {\n          hidden: (_event$channel$hidden = (_event$channel3 = event.channel) === null || _event$channel3 === void 0 ? void 0 : _event$channel3.hidden) !== null && _event$channel$hidden !== void 0 ? _event$channel$hidden : (_newChannels$channelI = newChannels[channelIndex].data) === null || _newChannels$channelI === void 0 ? void 0 : _newChannels$channelI.hidden,\n          own_capabilities: (_event$channel$own_ca = (_event$channel4 = event.channel) === null || _event$channel4 === void 0 ? void 0 : _event$channel4.own_capabilities) !== null && _event$channel$own_ca !== void 0 ? _event$channel$own_ca : (_newChannels$channelI2 = newChannels[channelIndex].data) === null || _newChannels$channelI2 === void 0 ? void 0 : _newChannels$channelI2.own_capabilities\n        });\n        return [...newChannels];\n      }\n      return channels;\n    });\n    // if (forceUpdate) {\n    //   forceUpdate();\n    // }\n  }, []);\n  const handleUserPresenceChanged = useCallback(_ref1 => {\n    let {\n      event,\n      setChannels\n    } = _ref1;\n    setChannels(channels => {\n      const newChannels = channels.map(channel => {\n        var _event$user;\n        if (!((_event$user = event.user) !== null && _event$user !== void 0 && _event$user.id) || !channel.state.members[event.user.id]) {\n          return channel;\n        }\n        // FIXME: oh no...\n        const newChannel = channel;\n        newChannel.state.members[event.user.id].user = event.user;\n        return newChannel;\n      });\n      return newChannels;\n    });\n  }, []);\n  return useMemo(() => ({\n    handleChannelDeleted,\n    handleChannelHidden,\n    handleChannelTruncated,\n    handleChannelUpdated,\n    handleChannelVisible,\n    handleMemberUpdated,\n    handleMessageNew,\n    handleNotificationAddedToChannel,\n    handleNotificationMessageNew,\n    handleNotificationRemovedFromChannel,\n    handleUserPresenceChanged\n  }), [handleChannelDeleted, handleChannelHidden, handleChannelTruncated, handleChannelUpdated, handleChannelVisible, handleMemberUpdated, handleMessageNew, handleNotificationAddedToChannel, handleNotificationMessageNew, handleNotificationRemovedFromChannel, handleUserPresenceChanged]);\n};\nexport const usePrepareShapeHandlers = _ref10 => {\n  let {\n    allowNewMessagesFromUnfilteredChannels,\n    customHandleChannelListShape,\n    filters,\n    lockChannelOrder,\n    onAddedToChannel,\n    onChannelDeleted,\n    onChannelHidden,\n    onChannelTruncated,\n    onChannelUpdated,\n    onChannelVisible,\n    onMessageNew,\n    onMessageNewHandler,\n    onRemovedFromChannel,\n    setChannels,\n    sort\n  } = _ref10;\n  const defaults = useChannelListShapeDefaults();\n  const defaultHandleChannelListShapeRef = useRef(undefined);\n  const customHandleChannelListShapeRef = useRef(undefined);\n  customHandleChannelListShapeRef.current = event => {\n    customHandleChannelListShape === null || customHandleChannelListShape === void 0 || customHandleChannelListShape({\n      defaults,\n      event,\n      setChannels\n    });\n  };\n  defaultHandleChannelListShapeRef.current = event => {\n    switch (event.type) {\n      case 'message.new':\n        defaults.handleMessageNew({\n          allowNewMessagesFromUnfilteredChannels,\n          customHandler: onMessageNewHandler,\n          event,\n          filters,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      case 'notification.message_new':\n        defaults.handleNotificationMessageNew({\n          allowNewMessagesFromUnfilteredChannels,\n          customHandler: onMessageNew,\n          event,\n          filters,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      case 'notification.added_to_channel':\n        defaults.handleNotificationAddedToChannel({\n          allowNewMessagesFromUnfilteredChannels,\n          customHandler: onAddedToChannel,\n          event,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      case 'notification.removed_from_channel':\n        defaults.handleNotificationRemovedFromChannel({\n          customHandler: onRemovedFromChannel,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.deleted':\n        defaults.handleChannelDeleted({\n          customHandler: onChannelDeleted,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.hidden':\n        defaults.handleChannelHidden({\n          customHandler: onChannelHidden,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.visible':\n        defaults.handleChannelVisible({\n          customHandler: onChannelVisible,\n          event,\n          filters,\n          setChannels,\n          sort\n        });\n        break;\n      case 'channel.truncated':\n        defaults.handleChannelTruncated({\n          customHandler: onChannelTruncated,\n          event,\n          setChannels\n        });\n        break;\n      case 'channel.updated':\n        defaults.handleChannelUpdated({\n          customHandler: onChannelUpdated,\n          event,\n          setChannels\n        });\n        break;\n      case 'user.presence.changed':\n        defaults.handleUserPresenceChanged({\n          event,\n          setChannels\n        });\n        break;\n      case 'member.updated':\n        defaults.handleMemberUpdated({\n          event,\n          filters,\n          lockChannelOrder,\n          setChannels,\n          sort\n        });\n        break;\n      default:\n        break;\n    }\n  };\n  const defaultFn = useCallback(e => {\n    var _defaultHandleChannel;\n    (_defaultHandleChannel = defaultHandleChannelListShapeRef.current) === null || _defaultHandleChannel === void 0 || _defaultHandleChannel.call(defaultHandleChannelListShapeRef, e);\n  }, []);\n  const customFn = useMemo(() => {\n    if (!customHandleChannelListShape) return null;\n    return e => {\n      var _customHandleChannelL;\n      (_customHandleChannelL = customHandleChannelListShapeRef.current) === null || _customHandleChannelL === void 0 || _customHandleChannelL.call(customHandleChannelListShapeRef, e);\n    };\n  }, [customHandleChannelListShape]);\n  return {\n    customHandler: customFn,\n    defaultHandler: defaultFn\n  };\n};\nexport const useChannelListShape = handler => {\n  const {\n    client\n  } = useChatContext();\n  useEffect(() => {\n    const subscription = client.on('all', handler);\n    return subscription.unsubscribe;\n  }, [client, handler]);\n};","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","extractSortValue","findLastPinnedChannelIndex","isChannelArchived","isChannelPinned","moveChannelUpwards","shouldConsiderArchivedChannels","shouldConsiderPinnedChannels","useChatContext","getChannel","shared","_ref","customHandler","event","setChannels","channels","channelIndex","findIndex","channel","cid","splice","useChannelListShapeDefaults","client","handleMessageNew","_ref2","allowNewMessagesFromUnfilteredChannels","filters","lockChannelOrder","sort","channelType","channel_type","channelId","channel_id","currentChannels","targetChannel","targetChannelIndex","indexOf","targetChannelExistsWithinList","isTargetChannelPinned","isTargetChannelArchived","considerArchivedChannels","considerPinnedChannels","archived","channelToMove","channelToMoveIndexWithinChannels","handleNotificationMessageNew","_ref3","id","type","handleNotificationAddedToChannel","_ref4","_event$channel$member","members","reduce","newMembers","_ref5","user","user_id","userId","push","handleNotificationRemovedFromChannel","_ref6","filter","_event$channel","handleMemberUpdated","_ref7","_event$member","member","userID","pinnedAtSort","atIndex","targetKey","newChannels","lastPinnedChannelIndex","newTargetChannelIndex","handleChannelDeleted","p","handleChannelHidden","handleChannelVisible","_ref8","handleChannelTruncated","_ref9","handleChannelUpdated","_ref0","_event$channel2","_event$channel$hidden","_event$channel3","_newChannels$channelI","_event$channel$own_ca","_event$channel4","_newChannels$channelI2","data","_objectSpread","hidden","own_capabilities","handleUserPresenceChanged","_ref1","map","_event$user","state","newChannel","usePrepareShapeHandlers","_ref10","customHandleChannelListShape","onAddedToChannel","onChannelDeleted","onChannelHidden","onChannelTruncated","onChannelUpdated","onChannelVisible","onMessageNew","onMessageNewHandler","onRemovedFromChannel","defaults","defaultHandleChannelListShapeRef","undefined","customHandleChannelListShapeRef","current","defaultFn","e","_defaultHandleChannel","call","customFn","_customHandleChannelL","defaultHandler","useChannelListShape","handler","subscription","on","unsubscribe"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/ChannelList/hooks/useChannelListShape.js"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { extractSortValue, findLastPinnedChannelIndex, isChannelArchived, isChannelPinned, moveChannelUpwards, shouldConsiderArchivedChannels, shouldConsiderPinnedChannels, } from '../utils';\nimport { useChatContext } from '../../../context';\nimport { getChannel } from '../../../utils';\nconst shared = ({ customHandler, event, setChannels, }) => {\n    if (typeof customHandler === 'function') {\n        return customHandler(setChannels, event);\n    }\n    setChannels((channels) => {\n        const channelIndex = channels.findIndex((channel) => channel.cid === event.cid);\n        if (channelIndex < 0)\n            return channels;\n        channels.splice(channelIndex, 1);\n        return [...channels];\n    });\n};\nexport const useChannelListShapeDefaults = () => {\n    const { client } = useChatContext();\n    const handleMessageNew = useCallback(({ allowNewMessagesFromUnfilteredChannels, customHandler, event, filters, lockChannelOrder, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        const channelType = event.channel_type;\n        const channelId = event.channel_id;\n        if (!channelType || !channelId)\n            return;\n        setChannels((currentChannels) => {\n            const targetChannel = client.channel(channelType, channelId);\n            const targetChannelIndex = currentChannels.indexOf(targetChannel);\n            const targetChannelExistsWithinList = targetChannelIndex >= 0;\n            const isTargetChannelPinned = isChannelPinned(targetChannel);\n            const isTargetChannelArchived = isChannelArchived(targetChannel);\n            const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n            const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n            if (\n            // filter is defined, target channel is archived and filter option is set to false\n            (considerArchivedChannels && isTargetChannelArchived && !filters.archived) ||\n                // filter is defined, target channel isn't archived and filter option is set to true\n                (considerArchivedChannels && !isTargetChannelArchived && filters.archived) ||\n                // sort option is defined, target channel is pinned\n                (considerPinnedChannels && isTargetChannelPinned) ||\n                // list order is locked\n                lockChannelOrder ||\n                // target channel is not within the loaded list and loading from cache is disallowed\n                (!targetChannelExistsWithinList && !allowNewMessagesFromUnfilteredChannels)) {\n                return currentChannels;\n            }\n            return moveChannelUpwards({\n                channels: currentChannels,\n                channelToMove: targetChannel,\n                channelToMoveIndexWithinChannels: targetChannelIndex,\n                sort,\n            });\n        });\n    }, [client]);\n    const handleNotificationMessageNew = useCallback(async ({ allowNewMessagesFromUnfilteredChannels, customHandler, event, filters, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        if (!event.channel) {\n            return;\n        }\n        const channel = await getChannel({\n            client,\n            id: event.channel.id,\n            type: event.channel.type,\n        });\n        const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n        if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n            return;\n        }\n        if (!allowNewMessagesFromUnfilteredChannels) {\n            return;\n        }\n        setChannels((channels) => moveChannelUpwards({\n            channels,\n            channelToMove: channel,\n            sort,\n        }));\n    }, [client]);\n    const handleNotificationAddedToChannel = useCallback(async ({ allowNewMessagesFromUnfilteredChannels, customHandler, event, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        if (!event.channel || !allowNewMessagesFromUnfilteredChannels) {\n            return;\n        }\n        const channel = await getChannel({\n            client,\n            id: event.channel.id,\n            members: event.channel.members?.reduce((newMembers, { user, user_id }) => {\n                const userId = user_id || user?.id;\n                if (userId)\n                    newMembers.push(userId);\n                return newMembers;\n            }, []),\n            type: event.channel.type,\n        });\n        // membership has been reset (target channel shouldn't be pinned nor archived)\n        setChannels((channels) => moveChannelUpwards({\n            channels,\n            channelToMove: channel,\n            sort,\n        }));\n    }, [client]);\n    const handleNotificationRemovedFromChannel = useCallback(({ customHandler, event, setChannels, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        setChannels((channels) => channels.filter((channel) => channel.cid !== event.channel?.cid));\n    }, []);\n    const handleMemberUpdated = useCallback(({ event, filters, lockChannelOrder, setChannels, sort, }) => {\n        if (!event.member?.user ||\n            event.member.user.id !== client.userID ||\n            !event.channel_type) {\n            return;\n        }\n        const channelType = event.channel_type;\n        const channelId = event.channel_id;\n        const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n        const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n        // `pinned_at` nor `archived` properties are set or channel list order is locked, return early\n        if ((!considerPinnedChannels && !considerArchivedChannels) || lockChannelOrder) {\n            return;\n        }\n        const pinnedAtSort = extractSortValue({ atIndex: 0, sort, targetKey: 'pinned_at' });\n        setChannels((currentChannels) => {\n            const targetChannel = client.channel(channelType, channelId);\n            // assumes that channel instances are not changing\n            const targetChannelIndex = currentChannels.indexOf(targetChannel);\n            const targetChannelExistsWithinList = targetChannelIndex >= 0;\n            const isTargetChannelArchived = isChannelArchived(targetChannel);\n            const isTargetChannelPinned = isChannelPinned(targetChannel);\n            const newChannels = [...currentChannels];\n            if (targetChannelExistsWithinList) {\n                newChannels.splice(targetChannelIndex, 1);\n            }\n            // handle archiving (remove channel)\n            if ((considerArchivedChannels && isTargetChannelArchived && !filters.archived) ||\n                (considerArchivedChannels && !isTargetChannelArchived && filters.archived)) {\n                return newChannels;\n            }\n            let lastPinnedChannelIndex = null;\n            // calculate last pinned channel index only if `pinned_at` sort is set to\n            // ascending order or if it's in descending order while the pin is being removed, otherwise\n            // we move to the top (index 0)\n            if (pinnedAtSort === 1 || (pinnedAtSort === -1 && !isTargetChannelPinned)) {\n                lastPinnedChannelIndex = findLastPinnedChannelIndex({ channels: newChannels });\n            }\n            const newTargetChannelIndex = typeof lastPinnedChannelIndex === 'number' ? lastPinnedChannelIndex + 1 : 0;\n            // skip re-render if the position of the channel does not change\n            if (currentChannels[newTargetChannelIndex] === targetChannel) {\n                return currentChannels;\n            }\n            newChannels.splice(newTargetChannelIndex, 0, targetChannel);\n            return newChannels;\n        });\n    }, [client]);\n    const handleChannelDeleted = useCallback((p) => shared(p), []);\n    const handleChannelHidden = useCallback((p) => shared(p), []);\n    const handleChannelVisible = useCallback(async ({ customHandler, event, filters, setChannels, sort, }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        if (!event.channel_id && !event.channel_type) {\n            return;\n        }\n        const channel = await getChannel({\n            client,\n            id: event.channel_id,\n            type: event.channel_type,\n        });\n        const considerArchivedChannels = shouldConsiderArchivedChannels(filters);\n        if (isChannelArchived(channel) && considerArchivedChannels && !filters.archived) {\n            return;\n        }\n        setChannels((channels) => moveChannelUpwards({\n            channels,\n            channelToMove: channel,\n            sort,\n        }));\n    }, [client]);\n    const handleChannelTruncated = useCallback(({ customHandler, event, setChannels }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        // TODO: not sure whether this is needed\n        setChannels((channels) => [...channels]);\n        // if (forceUpdate) {\n        //   forceUpdate();\n        // }\n    }, []);\n    const handleChannelUpdated = useCallback(({ customHandler, event, setChannels }) => {\n        if (typeof customHandler === 'function') {\n            return customHandler(setChannels, event);\n        }\n        setChannels((channels) => {\n            const channelIndex = channels.findIndex((channel) => channel.cid === event.channel?.cid);\n            if (channelIndex > -1 && event.channel) {\n                const newChannels = channels;\n                newChannels[channelIndex].data = {\n                    ...event.channel,\n                    hidden: event.channel?.hidden ?? newChannels[channelIndex].data?.hidden,\n                    own_capabilities: event.channel?.own_capabilities ??\n                        newChannels[channelIndex].data?.own_capabilities,\n                };\n                return [...newChannels];\n            }\n            return channels;\n        });\n        // if (forceUpdate) {\n        //   forceUpdate();\n        // }\n    }, []);\n    const handleUserPresenceChanged = useCallback(({ event, setChannels }) => {\n        setChannels((channels) => {\n            const newChannels = channels.map((channel) => {\n                if (!event.user?.id || !channel.state.members[event.user.id]) {\n                    return channel;\n                }\n                // FIXME: oh no...\n                const newChannel = channel;\n                newChannel.state.members[event.user.id].user = event.user;\n                return newChannel;\n            });\n            return newChannels;\n        });\n    }, []);\n    return useMemo(() => ({\n        handleChannelDeleted,\n        handleChannelHidden,\n        handleChannelTruncated,\n        handleChannelUpdated,\n        handleChannelVisible,\n        handleMemberUpdated,\n        handleMessageNew,\n        handleNotificationAddedToChannel,\n        handleNotificationMessageNew,\n        handleNotificationRemovedFromChannel,\n        handleUserPresenceChanged,\n    }), [\n        handleChannelDeleted,\n        handleChannelHidden,\n        handleChannelTruncated,\n        handleChannelUpdated,\n        handleChannelVisible,\n        handleMemberUpdated,\n        handleMessageNew,\n        handleNotificationAddedToChannel,\n        handleNotificationMessageNew,\n        handleNotificationRemovedFromChannel,\n        handleUserPresenceChanged,\n    ]);\n};\nexport const usePrepareShapeHandlers = ({ allowNewMessagesFromUnfilteredChannels, customHandleChannelListShape, filters, lockChannelOrder, onAddedToChannel, onChannelDeleted, onChannelHidden, onChannelTruncated, onChannelUpdated, onChannelVisible, onMessageNew, onMessageNewHandler, onRemovedFromChannel, setChannels, sort, }) => {\n    const defaults = useChannelListShapeDefaults();\n    const defaultHandleChannelListShapeRef = useRef(undefined);\n    const customHandleChannelListShapeRef = useRef(undefined);\n    customHandleChannelListShapeRef.current = (event) => {\n        customHandleChannelListShape?.({ defaults, event, setChannels });\n    };\n    defaultHandleChannelListShapeRef.current = (event) => {\n        switch (event.type) {\n            case 'message.new':\n                defaults.handleMessageNew({\n                    allowNewMessagesFromUnfilteredChannels,\n                    customHandler: onMessageNewHandler,\n                    event,\n                    filters,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'notification.message_new':\n                defaults.handleNotificationMessageNew({\n                    allowNewMessagesFromUnfilteredChannels,\n                    customHandler: onMessageNew,\n                    event,\n                    filters,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'notification.added_to_channel':\n                defaults.handleNotificationAddedToChannel({\n                    allowNewMessagesFromUnfilteredChannels,\n                    customHandler: onAddedToChannel,\n                    event,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'notification.removed_from_channel':\n                defaults.handleNotificationRemovedFromChannel({\n                    customHandler: onRemovedFromChannel,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.deleted':\n                defaults.handleChannelDeleted({\n                    customHandler: onChannelDeleted,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.hidden':\n                defaults.handleChannelHidden({\n                    customHandler: onChannelHidden,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.visible':\n                defaults.handleChannelVisible({\n                    customHandler: onChannelVisible,\n                    event,\n                    filters,\n                    setChannels,\n                    sort,\n                });\n                break;\n            case 'channel.truncated':\n                defaults.handleChannelTruncated({\n                    customHandler: onChannelTruncated,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'channel.updated':\n                defaults.handleChannelUpdated({\n                    customHandler: onChannelUpdated,\n                    event,\n                    setChannels,\n                });\n                break;\n            case 'user.presence.changed':\n                defaults.handleUserPresenceChanged({ event, setChannels });\n                break;\n            case 'member.updated':\n                defaults.handleMemberUpdated({\n                    event,\n                    filters,\n                    lockChannelOrder,\n                    setChannels,\n                    sort,\n                });\n                break;\n            default:\n                break;\n        }\n    };\n    const defaultFn = useCallback((e) => {\n        defaultHandleChannelListShapeRef.current?.(e);\n    }, []);\n    const customFn = useMemo(() => {\n        if (!customHandleChannelListShape)\n            return null;\n        return (e) => {\n            customHandleChannelListShapeRef.current?.(e);\n        };\n    }, [customHandleChannelListShape]);\n    return {\n        customHandler: customFn,\n        defaultHandler: defaultFn,\n    };\n};\nexport const useChannelListShape = (handler) => {\n    const { client } = useChatContext();\n    useEffect(() => {\n        const subscription = client.on('all', handler);\n        return subscription.unsubscribe;\n    }, [client, handler]);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}