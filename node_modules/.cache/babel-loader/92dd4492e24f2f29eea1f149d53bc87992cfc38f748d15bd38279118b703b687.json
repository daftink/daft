{"ast":null,"code":"import _objectWithoutProperties from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"calendarFormats\"];\nimport Dayjs, { isDayjs } from 'dayjs';\nexport const notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';\nexport const noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';\nexport const isNumberOrString = output => typeof output === 'string' || typeof output === 'number';\nexport const isDayOrMoment = output => !!(output !== null && output !== void 0 && output.isSame);\nexport const isDate = output => output !== null && typeof output === 'object' && typeof output.getTime === 'function';\nexport function getDateString(_ref) {\n  let {\n    calendar,\n    calendarFormats,\n    format,\n    formatDate,\n    messageCreatedAt,\n    t,\n    tDateTimeParser,\n    timestampTranslationKey\n  } = _ref;\n  if (!messageCreatedAt || typeof messageCreatedAt === 'string' && !Date.parse(messageCreatedAt)) {\n    console.warn(notValidDateWarning);\n    return null;\n  }\n  if (typeof formatDate === 'function') {\n    return formatDate(new Date(messageCreatedAt));\n  }\n  if (t && timestampTranslationKey) {\n    const options = {};\n    if (typeof calendar !== 'undefined' && calendar !== null) options.calendar = calendar;\n    if (typeof calendarFormats !== 'undefined' && calendarFormats !== null) options.calendarFormats = calendarFormats;\n    if (typeof format !== 'undefined' && format !== null) options.format = format;\n    const translatedTimestamp = t(timestampTranslationKey, _objectSpread(_objectSpread({}, options), {}, {\n      timestamp: new Date(messageCreatedAt)\n    }));\n    const translationKeyFound = timestampTranslationKey !== translatedTimestamp;\n    if (translationKeyFound) return translatedTimestamp;\n  }\n  if (!tDateTimeParser) {\n    console.warn(noParsingFunctionWarning);\n    return null;\n  }\n  const parsedTime = tDateTimeParser(messageCreatedAt);\n  if (isDayOrMoment(parsedTime)) {\n    /**\n     * parsedTime.calendar is guaranteed on the type but is only\n     * available when a user calls dayjs.extend(calendar)\n     */\n    return calendar && parsedTime.calendar ? parsedTime.calendar(undefined, calendarFormats || undefined) : parsedTime.format(format || undefined);\n  }\n  if (isDate(parsedTime)) {\n    return parsedTime.toDateString();\n  }\n  if (isNumberOrString(parsedTime)) {\n    return parsedTime;\n  }\n  return null;\n}\nexport const predefinedFormatters = {\n  durationFormatter: streamI18n => (value, _, _ref2) => {\n    let {\n      format,\n      withSuffix\n    } = _ref2;\n    if (format && isDayjs(streamI18n.DateTimeParser)) {\n      return streamI18n.DateTimeParser.duration(value).format(format);\n    }\n    return streamI18n.DateTimeParser.duration(value).humanize(!!withSuffix);\n  },\n  timestampFormatter: streamI18n => (value, _, _ref3) => {\n    let {\n        calendarFormats\n      } = _ref3,\n      options = _objectWithoutProperties(_ref3, _excluded);\n    let parsedCalendarFormats;\n    try {\n      if (!options.calendar) {\n        parsedCalendarFormats = {};\n      } else if (typeof calendarFormats === 'string') {\n        parsedCalendarFormats = JSON.parse(calendarFormats);\n      } else if (typeof calendarFormats === 'object') {\n        parsedCalendarFormats = calendarFormats;\n      }\n    } catch (e) {\n      console.error('[TIMESTAMP FORMATTER]', e);\n    }\n    const result = getDateString(_objectSpread(_objectSpread({}, options), {}, {\n      calendarFormats: parsedCalendarFormats,\n      messageCreatedAt: value,\n      tDateTimeParser: streamI18n.tDateTimeParser\n    }));\n    if (!result || typeof result === 'number') {\n      return JSON.stringify(value);\n    }\n    return result;\n  }\n};\nexport const defaultTranslatorFunction = key => key;\nexport const defaultDateTimeParser = input => Dayjs(input);\nexport const isLanguageSupported = language => {\n  const translations = ['de', 'en', 'es', 'fr', 'hi', 'it', 'ja', 'ko', 'nl', 'pt', 'ru', 'tr'];\n  return translations.some(translation => language === translation);\n};","map":{"version":3,"names":["Dayjs","isDayjs","notValidDateWarning","noParsingFunctionWarning","isNumberOrString","output","isDayOrMoment","isSame","isDate","getTime","getDateString","_ref","calendar","calendarFormats","format","formatDate","messageCreatedAt","t","tDateTimeParser","timestampTranslationKey","Date","parse","console","warn","options","translatedTimestamp","_objectSpread","timestamp","translationKeyFound","parsedTime","undefined","toDateString","predefinedFormatters","durationFormatter","streamI18n","value","_","_ref2","withSuffix","DateTimeParser","duration","humanize","timestampFormatter","_ref3","_objectWithoutProperties","_excluded","parsedCalendarFormats","JSON","e","error","result","stringify","defaultTranslatorFunction","key","defaultDateTimeParser","input","isLanguageSupported","language","translations","some","translation"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/i18n/utils.js"],"sourcesContent":["import Dayjs, { isDayjs } from 'dayjs';\nexport const notValidDateWarning = 'MessageTimestamp was called without a message, or message has invalid created_at date.';\nexport const noParsingFunctionWarning = 'MessageTimestamp was called but there is no datetime parsing function available';\nexport const isNumberOrString = (output) => typeof output === 'string' || typeof output === 'number';\nexport const isDayOrMoment = (output) => !!output?.isSame;\nexport const isDate = (output) => output !== null &&\n    typeof output === 'object' &&\n    typeof output.getTime === 'function';\nexport function getDateString({ calendar, calendarFormats, format, formatDate, messageCreatedAt, t, tDateTimeParser, timestampTranslationKey, }) {\n    if (!messageCreatedAt ||\n        (typeof messageCreatedAt === 'string' && !Date.parse(messageCreatedAt))) {\n        console.warn(notValidDateWarning);\n        return null;\n    }\n    if (typeof formatDate === 'function') {\n        return formatDate(new Date(messageCreatedAt));\n    }\n    if (t && timestampTranslationKey) {\n        const options = {};\n        if (typeof calendar !== 'undefined' && calendar !== null)\n            options.calendar = calendar;\n        if (typeof calendarFormats !== 'undefined' && calendarFormats !== null)\n            options.calendarFormats = calendarFormats;\n        if (typeof format !== 'undefined' && format !== null)\n            options.format = format;\n        const translatedTimestamp = t(timestampTranslationKey, {\n            ...options,\n            timestamp: new Date(messageCreatedAt),\n        });\n        const translationKeyFound = timestampTranslationKey !== translatedTimestamp;\n        if (translationKeyFound)\n            return translatedTimestamp;\n    }\n    if (!tDateTimeParser) {\n        console.warn(noParsingFunctionWarning);\n        return null;\n    }\n    const parsedTime = tDateTimeParser(messageCreatedAt);\n    if (isDayOrMoment(parsedTime)) {\n        /**\n         * parsedTime.calendar is guaranteed on the type but is only\n         * available when a user calls dayjs.extend(calendar)\n         */\n        return calendar && parsedTime.calendar\n            ? parsedTime.calendar(undefined, calendarFormats || undefined)\n            : parsedTime.format(format || undefined);\n    }\n    if (isDate(parsedTime)) {\n        return parsedTime.toDateString();\n    }\n    if (isNumberOrString(parsedTime)) {\n        return parsedTime;\n    }\n    return null;\n}\nexport const predefinedFormatters = {\n    durationFormatter: (streamI18n) => (value, _, { format, withSuffix }) => {\n        if (format && isDayjs(streamI18n.DateTimeParser)) {\n            return streamI18n.DateTimeParser.duration(value).format(format);\n        }\n        return streamI18n.DateTimeParser.duration(value).humanize(!!withSuffix);\n    },\n    timestampFormatter: (streamI18n) => (value, _, { calendarFormats, ...options }) => {\n        let parsedCalendarFormats;\n        try {\n            if (!options.calendar) {\n                parsedCalendarFormats = {};\n            }\n            else if (typeof calendarFormats === 'string') {\n                parsedCalendarFormats = JSON.parse(calendarFormats);\n            }\n            else if (typeof calendarFormats === 'object') {\n                parsedCalendarFormats = calendarFormats;\n            }\n        }\n        catch (e) {\n            console.error('[TIMESTAMP FORMATTER]', e);\n        }\n        const result = getDateString({\n            ...options,\n            calendarFormats: parsedCalendarFormats,\n            messageCreatedAt: value,\n            tDateTimeParser: streamI18n.tDateTimeParser,\n        });\n        if (!result || typeof result === 'number') {\n            return JSON.stringify(value);\n        }\n        return result;\n    },\n};\nexport const defaultTranslatorFunction = ((key) => key);\nexport const defaultDateTimeParser = (input) => Dayjs(input);\nexport const isLanguageSupported = (language) => {\n    const translations = [\n        'de',\n        'en',\n        'es',\n        'fr',\n        'hi',\n        'it',\n        'ja',\n        'ko',\n        'nl',\n        'pt',\n        'ru',\n        'tr',\n    ];\n    return translations.some((translation) => language === translation);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}