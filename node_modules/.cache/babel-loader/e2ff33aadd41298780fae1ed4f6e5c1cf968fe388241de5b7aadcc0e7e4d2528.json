{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport fixWebmDuration from 'fix-webm-duration';\nimport { nanoid } from 'nanoid';\nimport { AmplitudeRecorder, DEFAULT_AMPLITUDE_RECORDER_CONFIG } from './AmplitudeRecorder';\nimport { BrowserPermission } from './BrowserPermission';\nimport { BehaviorSubject, Subject } from '../observable';\nimport { transcode } from '../transcode';\nimport { resampleWaveformData } from '../../Attachment';\nimport { createFileFromBlobs, getExtensionFromMimeType, getRecordedMediaTypeFromMimeType } from '../../ReactFileUtilities';\nimport { defaultTranslatorFunction } from '../../../i18n';\nimport { mergeDeepUndefined } from '../../../utils/mergeDeep';\nexport const RECORDED_MIME_TYPE_BY_BROWSER = {\n  audio: {\n    others: 'audio/webm',\n    safari: 'audio/mp4;codecs=mp4a.40.2'\n  }\n};\nexport const DEFAULT_AUDIO_TRANSCODER_CONFIG = {\n  sampleRate: 16000\n};\nconst disposeOfMediaStream = stream => {\n  if (!(stream !== null && stream !== void 0 && stream.active)) return;\n  stream.getTracks().forEach(track => {\n    track.stop();\n    stream.removeTrack(track);\n  });\n};\nconst logError = e => e && console.error('[MEDIA RECORDER ERROR]', e);\nexport var MediaRecordingState;\n(function (MediaRecordingState) {\n  MediaRecordingState[\"PAUSED\"] = \"paused\";\n  MediaRecordingState[\"RECORDING\"] = \"recording\";\n  MediaRecordingState[\"STOPPED\"] = \"stopped\";\n})(MediaRecordingState || (MediaRecordingState = {}));\nexport var RecordingAttachmentType;\n(function (RecordingAttachmentType) {\n  RecordingAttachmentType[\"VOICE_RECORDING\"] = \"voiceRecording\";\n})(RecordingAttachmentType || (RecordingAttachmentType = {}));\nexport class MediaRecorderController {\n  constructor() {\n    let {\n      config,\n      generateRecordingTitle,\n      t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.recordedChunkDurations = [];\n    this.recordedData = [];\n    this.recordingState = new BehaviorSubject(undefined);\n    this.recording = new BehaviorSubject(undefined);\n    this.error = new Subject();\n    this.notification = new Subject();\n    this.generateRecordingTitle = mimeType => {\n      if (this.customGenerateRecordingTitle) {\n        return this.customGenerateRecordingTitle(mimeType);\n      }\n      return \"\".concat(this.mediaType, \"_recording_\").concat(new Date().toISOString(), \".\").concat(getExtensionFromMimeType(mimeType)); // extension needed so that desktop Safari can play the asset\n    };\n    this.makeVoiceRecording = async () => {\n      var _this$amplitudeRecord, _this$amplitudeRecord2;\n      if (this.recordingUri) URL.revokeObjectURL(this.recordingUri);\n      if (!this.recordedData.length) return;\n      const {\n        mimeType\n      } = this.mediaRecorderConfig;\n      let blob = new Blob(this.recordedData, {\n        type: mimeType\n      });\n      if (mimeType.match('audio/webm')) {\n        // The browser does not include duration metadata with the recorded blob\n        blob = await fixWebmDuration(blob, this.durationMs, {\n          logger: () => null // prevents polluting the browser console\n        });\n      }\n      if (!mimeType.match('audio/mp4')) {\n        blob = await transcode(_objectSpread({\n          blob\n        }, this.transcoderConfig));\n      }\n      if (!blob) return;\n      this.recordingUri = URL.createObjectURL(blob);\n      const file = createFileFromBlobs({\n        blobsArray: [blob],\n        fileName: this.generateRecordingTitle(blob.type),\n        mimeType: blob.type\n      });\n      return {\n        asset_url: this.recordingUri,\n        duration: this.durationMs / 1000,\n        file_size: blob.size,\n        localMetadata: {\n          file,\n          id: nanoid()\n        },\n        mime_type: blob.type,\n        title: file.name,\n        type: RecordingAttachmentType.VOICE_RECORDING,\n        waveform_data: resampleWaveformData((_this$amplitudeRecord = (_this$amplitudeRecord2 = this.amplitudeRecorder) === null || _this$amplitudeRecord2 === void 0 ? void 0 : _this$amplitudeRecord2.amplitudes.value) !== null && _this$amplitudeRecord !== void 0 ? _this$amplitudeRecord : [], this.amplitudeRecorderConfig.sampleCount)\n      };\n    };\n    this.handleErrorEvent = e => {\n      const {\n        error\n      } = e;\n      logError(error);\n      this.error.next(error);\n      this.notification.next({\n        text: this.t('An error has occurred during recording'),\n        type: 'error'\n      });\n    };\n    this.handleDataavailableEvent = async e => {\n      if (!e.data.size) return;\n      if (this.mediaType !== 'audio') return;\n      try {\n        var _this$signalRecording;\n        this.recordedData.push(e.data);\n        const recording = await this.makeVoiceRecording();\n        if (!recording) return;\n        (_this$signalRecording = this.signalRecordingReady) === null || _this$signalRecording === void 0 || _this$signalRecording.call(this, recording);\n        this.recording.next(recording);\n      } catch (e) {\n        logError(e);\n        this.error.next(e);\n        this.notification.next({\n          text: this.t('An error has occurred during the recording processing'),\n          type: 'error'\n        });\n      }\n    };\n    this.resetRecordingState = () => {\n      this.recordedData = [];\n      this.recording.next(undefined);\n      this.recordingState.next(undefined);\n      this.recordedChunkDurations = [];\n      this.startTime = undefined;\n    };\n    this.cleanUp = () => {\n      var _this$amplitudeRecord3;\n      this.resetRecordingState();\n      if (this.recordingUri) URL.revokeObjectURL(this.recordingUri);\n      (_this$amplitudeRecord3 = this.amplitudeRecorder) === null || _this$amplitudeRecord3 === void 0 || _this$amplitudeRecord3.close();\n      if (this.mediaRecorder) {\n        disposeOfMediaStream(this.mediaRecorder.stream);\n        this.mediaRecorder.removeEventListener('dataavailable', this.handleDataavailableEvent);\n        this.mediaRecorder.removeEventListener('error', this.handleErrorEvent);\n      }\n    };\n    this.start = async () => {\n      if ([MediaRecordingState.RECORDING, MediaRecordingState.PAUSED].includes(this.recordingState.value)) {\n        const error = new Error('Cannot start recording. Recording already in progress');\n        logError(error);\n        this.error.next(error);\n        return;\n      }\n      // account for requirement on iOS as per this bug report: https://bugs.webkit.org/show_bug.cgi?id=252303\n      if (!navigator.mediaDevices) {\n        const error = new Error('Media recording is not supported');\n        logError(error);\n        this.error.next(error);\n        this.notification.next({\n          text: this.t('Error starting recording'),\n          type: 'error'\n        });\n        return;\n      }\n      if (this.mediaType === 'video') {\n        const error = new Error(\"Video recording is not supported. Provided MIME type: \".concat(this.mediaRecorderConfig.mimeType));\n        logError(error);\n        this.error.next(error);\n        this.notification.next({\n          text: this.t('Error starting recording'),\n          type: 'error'\n        });\n        return;\n      }\n      if (!this.permission.state.value) {\n        await this.permission.check();\n      }\n      if (this.permission.state.value === 'denied') {\n        logError(new Error('Permission denied'));\n        return;\n      }\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true\n        });\n        this.mediaRecorder = new MediaRecorder(stream, this.mediaRecorderConfig);\n        this.mediaRecorder.addEventListener('dataavailable', this.handleDataavailableEvent);\n        this.mediaRecorder.addEventListener('error', this.handleErrorEvent);\n        this.startTime = new Date().getTime();\n        this.mediaRecorder.start();\n        if (this.mediaType === 'audio' && stream) {\n          this.amplitudeRecorder = new AmplitudeRecorder({\n            config: this.amplitudeRecorderConfig,\n            stream\n          });\n          this.amplitudeRecorder.start();\n        }\n        this.recordingState.next(MediaRecordingState.RECORDING);\n      } catch (error) {\n        logError(error);\n        this.cancel();\n        this.error.next(error);\n        this.notification.next({\n          text: this.t('Error starting recording'),\n          type: 'error'\n        });\n      }\n    };\n    this.pause = () => {\n      var _this$mediaRecorder, _this$amplitudeRecord4;\n      if (this.recordingState.value !== MediaRecordingState.RECORDING) return;\n      if (this.startTime) {\n        this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n        this.startTime = undefined;\n      }\n      (_this$mediaRecorder = this.mediaRecorder) === null || _this$mediaRecorder === void 0 || _this$mediaRecorder.pause();\n      (_this$amplitudeRecord4 = this.amplitudeRecorder) === null || _this$amplitudeRecord4 === void 0 || _this$amplitudeRecord4.stop();\n      this.recordingState.next(MediaRecordingState.PAUSED);\n    };\n    this.resume = () => {\n      var _this$mediaRecorder2, _this$amplitudeRecord5;\n      if (this.recordingState.value !== MediaRecordingState.PAUSED) return;\n      this.startTime = new Date().getTime();\n      (_this$mediaRecorder2 = this.mediaRecorder) === null || _this$mediaRecorder2 === void 0 || _this$mediaRecorder2.resume();\n      (_this$amplitudeRecord5 = this.amplitudeRecorder) === null || _this$amplitudeRecord5 === void 0 || _this$amplitudeRecord5.start();\n      this.recordingState.next(MediaRecordingState.RECORDING);\n    };\n    this.stop = () => {\n      var _this$mediaRecorder3, _this$mediaRecorder4, _this$amplitudeRecord6;\n      const recording = this.recording.value;\n      if (recording) return Promise.resolve(recording);\n      if (![MediaRecordingState.PAUSED, MediaRecordingState.RECORDING].includes(((_this$mediaRecorder3 = this.mediaRecorder) === null || _this$mediaRecorder3 === void 0 ? void 0 : _this$mediaRecorder3.state) || '')) return Promise.resolve(undefined);\n      if (this.startTime) {\n        this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n        this.startTime = undefined;\n      }\n      const result = new Promise(res => {\n        this.signalRecordingReady = res;\n      });\n      (_this$mediaRecorder4 = this.mediaRecorder) === null || _this$mediaRecorder4 === void 0 || _this$mediaRecorder4.stop();\n      (_this$amplitudeRecord6 = this.amplitudeRecorder) === null || _this$amplitudeRecord6 === void 0 || _this$amplitudeRecord6.stop();\n      this.recordingState.next(MediaRecordingState.STOPPED);\n      return result;\n    };\n    this.cancel = () => {\n      this.stop();\n      this.cleanUp();\n    };\n    this.t = t || defaultTranslatorFunction;\n    this.amplitudeRecorderConfig = mergeDeepUndefined(_objectSpread({}, config === null || config === void 0 ? void 0 : config.amplitudeRecorderConfig), DEFAULT_AMPLITUDE_RECORDER_CONFIG);\n    this.mediaRecorderConfig = mergeDeepUndefined(_objectSpread({}, config === null || config === void 0 ? void 0 : config.mediaRecorderConfig), {\n      mimeType: MediaRecorder.isTypeSupported('audio/webm') ? RECORDED_MIME_TYPE_BY_BROWSER.audio.others : RECORDED_MIME_TYPE_BY_BROWSER.audio.safari\n    });\n    this.transcoderConfig = mergeDeepUndefined(_objectSpread({}, config === null || config === void 0 ? void 0 : config.transcoderConfig), DEFAULT_AUDIO_TRANSCODER_CONFIG);\n    const mediaType = getRecordedMediaTypeFromMimeType(this.mediaRecorderConfig.mimeType);\n    if (!mediaType) {\n      throw new Error(\"Unsupported media type (supported audio or video only). Provided mimeType: \".concat(this.mediaRecorderConfig.mimeType));\n    }\n    this.mediaType = mediaType;\n    this.permission = new BrowserPermission({\n      mediaType\n    });\n    this.customGenerateRecordingTitle = generateRecordingTitle;\n  }\n  get durationMs() {\n    return this.recordedChunkDurations.reduce((acc, val) => acc + val, 0);\n  }\n}","map":{"version":3,"names":["fixWebmDuration","nanoid","AmplitudeRecorder","DEFAULT_AMPLITUDE_RECORDER_CONFIG","BrowserPermission","BehaviorSubject","Subject","transcode","resampleWaveformData","createFileFromBlobs","getExtensionFromMimeType","getRecordedMediaTypeFromMimeType","defaultTranslatorFunction","mergeDeepUndefined","RECORDED_MIME_TYPE_BY_BROWSER","audio","others","safari","DEFAULT_AUDIO_TRANSCODER_CONFIG","sampleRate","disposeOfMediaStream","stream","active","getTracks","forEach","track","stop","removeTrack","logError","e","console","error","MediaRecordingState","RecordingAttachmentType","MediaRecorderController","constructor","config","generateRecordingTitle","t","arguments","length","undefined","recordedChunkDurations","recordedData","recordingState","recording","notification","mimeType","customGenerateRecordingTitle","concat","mediaType","Date","toISOString","makeVoiceRecording","_this$amplitudeRecord","_this$amplitudeRecord2","recordingUri","URL","revokeObjectURL","mediaRecorderConfig","blob","Blob","type","match","durationMs","logger","_objectSpread","transcoderConfig","createObjectURL","file","blobsArray","fileName","asset_url","duration","file_size","size","localMetadata","id","mime_type","title","name","VOICE_RECORDING","waveform_data","amplitudeRecorder","amplitudes","value","amplitudeRecorderConfig","sampleCount","handleErrorEvent","next","text","handleDataavailableEvent","data","_this$signalRecording","push","signalRecordingReady","call","resetRecordingState","startTime","cleanUp","_this$amplitudeRecord3","close","mediaRecorder","removeEventListener","start","RECORDING","PAUSED","includes","Error","navigator","mediaDevices","permission","state","check","getUserMedia","MediaRecorder","addEventListener","getTime","cancel","pause","_this$mediaRecorder","_this$amplitudeRecord4","resume","_this$mediaRecorder2","_this$amplitudeRecord5","_this$mediaRecorder3","_this$mediaRecorder4","_this$amplitudeRecord6","Promise","resolve","result","res","STOPPED","isTypeSupported","reduce","acc","val"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MediaRecorder/classes/MediaRecorderController.js"],"sourcesContent":["import fixWebmDuration from 'fix-webm-duration';\nimport { nanoid } from 'nanoid';\nimport { AmplitudeRecorder, DEFAULT_AMPLITUDE_RECORDER_CONFIG, } from './AmplitudeRecorder';\nimport { BrowserPermission } from './BrowserPermission';\nimport { BehaviorSubject, Subject } from '../observable';\nimport { transcode } from '../transcode';\nimport { resampleWaveformData } from '../../Attachment';\nimport { createFileFromBlobs, getExtensionFromMimeType, getRecordedMediaTypeFromMimeType, } from '../../ReactFileUtilities';\nimport { defaultTranslatorFunction } from '../../../i18n';\nimport { mergeDeepUndefined } from '../../../utils/mergeDeep';\nexport const RECORDED_MIME_TYPE_BY_BROWSER = {\n    audio: {\n        others: 'audio/webm',\n        safari: 'audio/mp4;codecs=mp4a.40.2',\n    },\n};\nexport const DEFAULT_AUDIO_TRANSCODER_CONFIG = {\n    sampleRate: 16000,\n};\nconst disposeOfMediaStream = (stream) => {\n    if (!stream?.active)\n        return;\n    stream.getTracks().forEach((track) => {\n        track.stop();\n        stream.removeTrack(track);\n    });\n};\nconst logError = (e) => e && console.error('[MEDIA RECORDER ERROR]', e);\nexport var MediaRecordingState;\n(function (MediaRecordingState) {\n    MediaRecordingState[\"PAUSED\"] = \"paused\";\n    MediaRecordingState[\"RECORDING\"] = \"recording\";\n    MediaRecordingState[\"STOPPED\"] = \"stopped\";\n})(MediaRecordingState || (MediaRecordingState = {}));\nexport var RecordingAttachmentType;\n(function (RecordingAttachmentType) {\n    RecordingAttachmentType[\"VOICE_RECORDING\"] = \"voiceRecording\";\n})(RecordingAttachmentType || (RecordingAttachmentType = {}));\nexport class MediaRecorderController {\n    constructor({ config, generateRecordingTitle, t } = {}) {\n        this.recordedChunkDurations = [];\n        this.recordedData = [];\n        this.recordingState = new BehaviorSubject(undefined);\n        this.recording = new BehaviorSubject(undefined);\n        this.error = new Subject();\n        this.notification = new Subject();\n        this.generateRecordingTitle = (mimeType) => {\n            if (this.customGenerateRecordingTitle) {\n                return this.customGenerateRecordingTitle(mimeType);\n            }\n            return `${this.mediaType}_recording_${new Date().toISOString()}.${getExtensionFromMimeType(mimeType)}`; // extension needed so that desktop Safari can play the asset\n        };\n        this.makeVoiceRecording = async () => {\n            if (this.recordingUri)\n                URL.revokeObjectURL(this.recordingUri);\n            if (!this.recordedData.length)\n                return;\n            const { mimeType } = this.mediaRecorderConfig;\n            let blob = new Blob(this.recordedData, { type: mimeType });\n            if (mimeType.match('audio/webm')) {\n                // The browser does not include duration metadata with the recorded blob\n                blob = await fixWebmDuration(blob, this.durationMs, {\n                    logger: () => null, // prevents polluting the browser console\n                });\n            }\n            if (!mimeType.match('audio/mp4')) {\n                blob = await transcode({\n                    blob,\n                    ...this.transcoderConfig,\n                });\n            }\n            if (!blob)\n                return;\n            this.recordingUri = URL.createObjectURL(blob);\n            const file = createFileFromBlobs({\n                blobsArray: [blob],\n                fileName: this.generateRecordingTitle(blob.type),\n                mimeType: blob.type,\n            });\n            return {\n                asset_url: this.recordingUri,\n                duration: this.durationMs / 1000,\n                file_size: blob.size,\n                localMetadata: {\n                    file,\n                    id: nanoid(),\n                },\n                mime_type: blob.type,\n                title: file.name,\n                type: RecordingAttachmentType.VOICE_RECORDING,\n                waveform_data: resampleWaveformData(this.amplitudeRecorder?.amplitudes.value ?? [], this.amplitudeRecorderConfig.sampleCount),\n            };\n        };\n        this.handleErrorEvent = (e) => {\n            const { error } = e;\n            logError(error);\n            this.error.next(error);\n            this.notification.next({\n                text: this.t('An error has occurred during recording'),\n                type: 'error',\n            });\n        };\n        this.handleDataavailableEvent = async (e) => {\n            if (!e.data.size)\n                return;\n            if (this.mediaType !== 'audio')\n                return;\n            try {\n                this.recordedData.push(e.data);\n                const recording = await this.makeVoiceRecording();\n                if (!recording)\n                    return;\n                this.signalRecordingReady?.(recording);\n                this.recording.next(recording);\n            }\n            catch (e) {\n                logError(e);\n                this.error.next(e);\n                this.notification.next({\n                    text: this.t('An error has occurred during the recording processing'),\n                    type: 'error',\n                });\n            }\n        };\n        this.resetRecordingState = () => {\n            this.recordedData = [];\n            this.recording.next(undefined);\n            this.recordingState.next(undefined);\n            this.recordedChunkDurations = [];\n            this.startTime = undefined;\n        };\n        this.cleanUp = () => {\n            this.resetRecordingState();\n            if (this.recordingUri)\n                URL.revokeObjectURL(this.recordingUri);\n            this.amplitudeRecorder?.close();\n            if (this.mediaRecorder) {\n                disposeOfMediaStream(this.mediaRecorder.stream);\n                this.mediaRecorder.removeEventListener('dataavailable', this.handleDataavailableEvent);\n                this.mediaRecorder.removeEventListener('error', this.handleErrorEvent);\n            }\n        };\n        this.start = async () => {\n            if ([MediaRecordingState.RECORDING, MediaRecordingState.PAUSED].includes(this.recordingState.value)) {\n                const error = new Error('Cannot start recording. Recording already in progress');\n                logError(error);\n                this.error.next(error);\n                return;\n            }\n            // account for requirement on iOS as per this bug report: https://bugs.webkit.org/show_bug.cgi?id=252303\n            if (!navigator.mediaDevices) {\n                const error = new Error('Media recording is not supported');\n                logError(error);\n                this.error.next(error);\n                this.notification.next({ text: this.t('Error starting recording'), type: 'error' });\n                return;\n            }\n            if (this.mediaType === 'video') {\n                const error = new Error(`Video recording is not supported. Provided MIME type: ${this.mediaRecorderConfig.mimeType}`);\n                logError(error);\n                this.error.next(error);\n                this.notification.next({ text: this.t('Error starting recording'), type: 'error' });\n                return;\n            }\n            if (!this.permission.state.value) {\n                await this.permission.check();\n            }\n            if (this.permission.state.value === 'denied') {\n                logError(new Error('Permission denied'));\n                return;\n            }\n            try {\n                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n                this.mediaRecorder = new MediaRecorder(stream, this.mediaRecorderConfig);\n                this.mediaRecorder.addEventListener('dataavailable', this.handleDataavailableEvent);\n                this.mediaRecorder.addEventListener('error', this.handleErrorEvent);\n                this.startTime = new Date().getTime();\n                this.mediaRecorder.start();\n                if (this.mediaType === 'audio' && stream) {\n                    this.amplitudeRecorder = new AmplitudeRecorder({\n                        config: this.amplitudeRecorderConfig,\n                        stream,\n                    });\n                    this.amplitudeRecorder.start();\n                }\n                this.recordingState.next(MediaRecordingState.RECORDING);\n            }\n            catch (error) {\n                logError(error);\n                this.cancel();\n                this.error.next(error);\n                this.notification.next({ text: this.t('Error starting recording'), type: 'error' });\n            }\n        };\n        this.pause = () => {\n            if (this.recordingState.value !== MediaRecordingState.RECORDING)\n                return;\n            if (this.startTime) {\n                this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n                this.startTime = undefined;\n            }\n            this.mediaRecorder?.pause();\n            this.amplitudeRecorder?.stop();\n            this.recordingState.next(MediaRecordingState.PAUSED);\n        };\n        this.resume = () => {\n            if (this.recordingState.value !== MediaRecordingState.PAUSED)\n                return;\n            this.startTime = new Date().getTime();\n            this.mediaRecorder?.resume();\n            this.amplitudeRecorder?.start();\n            this.recordingState.next(MediaRecordingState.RECORDING);\n        };\n        this.stop = () => {\n            const recording = this.recording.value;\n            if (recording)\n                return Promise.resolve(recording);\n            if (![MediaRecordingState.PAUSED, MediaRecordingState.RECORDING].includes((this.mediaRecorder?.state || '')))\n                return Promise.resolve(undefined);\n            if (this.startTime) {\n                this.recordedChunkDurations.push(new Date().getTime() - this.startTime);\n                this.startTime = undefined;\n            }\n            const result = new Promise((res) => {\n                this.signalRecordingReady = res;\n            });\n            this.mediaRecorder?.stop();\n            this.amplitudeRecorder?.stop();\n            this.recordingState.next(MediaRecordingState.STOPPED);\n            return result;\n        };\n        this.cancel = () => {\n            this.stop();\n            this.cleanUp();\n        };\n        this.t = t || defaultTranslatorFunction;\n        this.amplitudeRecorderConfig = mergeDeepUndefined({ ...config?.amplitudeRecorderConfig }, DEFAULT_AMPLITUDE_RECORDER_CONFIG);\n        this.mediaRecorderConfig = mergeDeepUndefined({ ...config?.mediaRecorderConfig }, {\n            mimeType: MediaRecorder.isTypeSupported('audio/webm')\n                ? RECORDED_MIME_TYPE_BY_BROWSER.audio.others\n                : RECORDED_MIME_TYPE_BY_BROWSER.audio.safari,\n        });\n        this.transcoderConfig = mergeDeepUndefined({ ...config?.transcoderConfig }, DEFAULT_AUDIO_TRANSCODER_CONFIG);\n        const mediaType = getRecordedMediaTypeFromMimeType(this.mediaRecorderConfig.mimeType);\n        if (!mediaType) {\n            throw new Error(`Unsupported media type (supported audio or video only). Provided mimeType: ${this.mediaRecorderConfig.mimeType}`);\n        }\n        this.mediaType = mediaType;\n        this.permission = new BrowserPermission({ mediaType });\n        this.customGenerateRecordingTitle = generateRecordingTitle;\n    }\n    get durationMs() {\n        return this.recordedChunkDurations.reduce((acc, val) => acc + val, 0);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}