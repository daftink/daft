{"ast":null,"code":"import _objectWithoutProperties from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"messages\", \"reviewProcessedMessage\", \"setGiphyPreviewMessage\"];\nimport { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isMessageEdited } from '../Message/utils';\nimport { isDate } from '../../i18n';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {LocalMessage[]} Transformed list of messages\n */\nexport const processMessages = params => {\n  const {\n      messages,\n      reviewProcessedMessage,\n      setGiphyPreviewMessage\n    } = params,\n    context = _objectWithoutProperties(params, _excluded);\n  const {\n    enableDateSeparator,\n    hideDeletedMessages,\n    hideNewMessageSeparator,\n    lastRead,\n    userId\n  } = context;\n  let unread = false;\n  let ephemeralMessagePresent = false;\n  let lastDateSeparator;\n  const newMessages = [];\n  for (let i = 0; i < messages.length; i += 1) {\n    const message = messages[i];\n    if (hideDeletedMessages && message.type === 'deleted') {\n      continue;\n    }\n    if (setGiphyPreviewMessage && message.type === 'ephemeral' && message.command === 'giphy') {\n      ephemeralMessagePresent = true;\n      setGiphyPreviewMessage(message);\n      continue;\n    }\n    const changes = [];\n    const messageDate = message.created_at && isDate(message.created_at) && message.created_at.toDateString() || '';\n    const previousMessage = messages[i - 1];\n    let prevMessageDate = messageDate;\n    if (enableDateSeparator && previousMessage !== null && previousMessage !== void 0 && previousMessage.created_at && isDate(previousMessage.created_at)) {\n      prevMessageDate = previousMessage.created_at.toDateString();\n    }\n    if (!unread && !hideNewMessageSeparator) {\n      var _message$user;\n      unread = lastRead && message.created_at && new Date(lastRead) < message.created_at || false;\n      // do not show date separator for current user's messages\n      if (enableDateSeparator && unread && ((_message$user = message.user) === null || _message$user === void 0 ? void 0 : _message$user.id) !== userId) {\n        changes.push({\n          customType: CUSTOM_MESSAGE_TYPE.date,\n          date: message.created_at,\n          id: makeDateMessageId(message.created_at),\n          unread\n        });\n      }\n    }\n    if (enableDateSeparator && (i === 0 ||\n    // always put date separator before the first message\n    messageDate !== prevMessageDate ||\n    // add date separator btw. 2 messages created on different date\n    // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n    hideDeletedMessages && (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.type) === 'deleted' && lastDateSeparator !== messageDate) && !isDateSeparatorMessage(changes[changes.length - 1]) // do not show two date separators in a row)\n    ) {\n      lastDateSeparator = messageDate;\n      changes.push({\n        customType: CUSTOM_MESSAGE_TYPE.date,\n        date: message.created_at,\n        id: makeDateMessageId(message.created_at)\n      }, message);\n    } else {\n      changes.push(message);\n    }\n    newMessages.push(...((reviewProcessedMessage === null || reviewProcessedMessage === void 0 ? void 0 : reviewProcessedMessage({\n      changes,\n      context,\n      index: i,\n      messages,\n      processedMessages: newMessages\n    })) || changes));\n  }\n  // clean up the giphy preview component state after a Cancel action\n  if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n    setGiphyPreviewMessage(undefined);\n  }\n  return newMessages;\n};\nexport const makeIntroMessage = () => ({\n  customType: CUSTOM_MESSAGE_TYPE.intro,\n  id: nanoid()\n});\nexport const makeDateMessageId = date => {\n  let idSuffix;\n  try {\n    idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n  } catch (e) {\n    idSuffix = nanoid();\n  }\n  return \"\".concat(CUSTOM_MESSAGE_TYPE.date, \"-\").concat(idSuffix);\n};\n// fast since it usually iterates just the last few messages\nexport const getLastReceived = messages => {\n  for (let i = messages.length - 1; i > 0; i -= 1) {\n    if (messages[i].status === 'received') {\n      return messages[i].id;\n    }\n  }\n  return null;\n};\nexport const getReadStates = function (messages) {\n  let read = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let returnAllReadData = arguments.length > 2 ? arguments[2] : undefined;\n  // create object with empty array for each message id\n  const readData = {};\n  Object.values(read).forEach(readState => {\n    if (!readState.last_read) return;\n    let userLastReadMsgId;\n    // loop messages sent by current user and add read data for other users in channel\n    messages.forEach(msg => {\n      if (msg.created_at && msg.created_at < readState.last_read) {\n        userLastReadMsgId = msg.id;\n        // if true, save other user's read data for all messages they've read\n        if (returnAllReadData) {\n          if (!readData[userLastReadMsgId]) {\n            readData[userLastReadMsgId] = [];\n          }\n          readData[userLastReadMsgId].push(readState.user);\n        }\n      }\n    });\n    // if true, only save read data for other user's last read message\n    if (userLastReadMsgId && !returnAllReadData) {\n      if (!readData[userLastReadMsgId]) {\n        readData[userLastReadMsgId] = [];\n      }\n      readData[userLastReadMsgId].push(readState.user);\n    }\n  });\n  return readData;\n};\nexport const insertIntro = (messages, headerPosition) => {\n  const newMessages = messages;\n  const intro = makeIntroMessage();\n  // if no headerPosition is set, HeaderComponent will go at the top\n  if (!headerPosition) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // if no messages, intro gets inserted\n  if (!newMessages.length) {\n    newMessages.unshift(intro);\n    return newMessages;\n  }\n  // else loop over the messages\n  for (let i = 0; i < messages.length; i += 1) {\n    const messageTime = isDate(messages[i].created_at) ? messages[i].created_at.getTime() : null;\n    const nextMessageTime = isDate(messages[i + 1].created_at) ? messages[i + 1].created_at.getTime() : null;\n    // header position is smaller than message time so comes after;\n    if (messageTime && messageTime < headerPosition) {\n      // if header position is also smaller than message time continue;\n      if (nextMessageTime && nextMessageTime < headerPosition) {\n        if (messages[i + 1] && isDateSeparatorMessage(messages[i + 1])) continue;\n        if (!nextMessageTime) {\n          newMessages.push(intro);\n          return newMessages;\n        }\n      } else {\n        newMessages.splice(i + 1, 0, intro);\n        return newMessages;\n      }\n    }\n  }\n  return newMessages;\n};\nexport const getGroupStyles = (message, previousMessage, nextMessage, noGroupByUser, maxTimeBetweenGroupedMessages) => {\n  var _message$attachments, _previousMessage$atta, _message$user2, _previousMessage$user, _nextMessage$attachme, _message$user3, _nextMessage$user;\n  if (isDateSeparatorMessage(message) || isIntroMessage(message)) return '';\n  if (noGroupByUser || ((_message$attachments = message.attachments) === null || _message$attachments === void 0 ? void 0 : _message$attachments.length) !== 0) return 'single';\n  const isTopMessage = !previousMessage || isIntroMessage(previousMessage) || isDateSeparatorMessage(previousMessage) || previousMessage.type === 'system' || previousMessage.type === 'error' || ((_previousMessage$atta = previousMessage.attachments) === null || _previousMessage$atta === void 0 ? void 0 : _previousMessage$atta.length) !== 0 || ((_message$user2 = message.user) === null || _message$user2 === void 0 ? void 0 : _message$user2.id) !== ((_previousMessage$user = previousMessage.user) === null || _previousMessage$user === void 0 ? void 0 : _previousMessage$user.id) || previousMessage.deleted_at || message.reaction_groups && Object.keys(message.reaction_groups).length > 0 || isMessageEdited(previousMessage) || maxTimeBetweenGroupedMessages !== undefined && previousMessage.created_at && message.created_at && new Date(message.created_at).getTime() - new Date(previousMessage.created_at).getTime() > maxTimeBetweenGroupedMessages;\n  const isBottomMessage = !nextMessage || isIntroMessage(nextMessage) || isDateSeparatorMessage(nextMessage) || nextMessage.type === 'system' || nextMessage.type === 'error' || ((_nextMessage$attachme = nextMessage.attachments) === null || _nextMessage$attachme === void 0 ? void 0 : _nextMessage$attachme.length) !== 0 || ((_message$user3 = message.user) === null || _message$user3 === void 0 ? void 0 : _message$user3.id) !== ((_nextMessage$user = nextMessage.user) === null || _nextMessage$user === void 0 ? void 0 : _nextMessage$user.id) || nextMessage.deleted_at || nextMessage.reaction_groups && Object.keys(nextMessage.reaction_groups).length > 0 || isMessageEdited(message) || maxTimeBetweenGroupedMessages !== undefined && nextMessage.created_at && message.created_at && new Date(nextMessage.created_at).getTime() - new Date(message.created_at).getTime() > maxTimeBetweenGroupedMessages;\n  if (!isTopMessage && !isBottomMessage) {\n    if (message.deleted_at || message.type === 'error') return 'single';\n    return 'middle';\n  }\n  if (isBottomMessage) {\n    if (isTopMessage || message.deleted_at || message.type === 'error') return 'single';\n    return 'bottom';\n  }\n  if (isTopMessage) return 'top';\n  return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport const hasMoreMessagesProbably = (returnedCountMessages, limit) => returnedCountMessages >= limit;\n// @deprecated\nexport const hasNotMoreMessages = (returnedCountMessages, limit) => returnedCountMessages < limit;\nexport function isIntroMessage(message) {\n  return message.customType === CUSTOM_MESSAGE_TYPE.intro;\n}\nexport function isDateSeparatorMessage(message) {\n  return message !== null && typeof message === 'object' && message.customType === CUSTOM_MESSAGE_TYPE.date && isDate(message.date);\n}\nexport function isLocalMessage(message) {\n  return !isDateSeparatorMessage(message) && !isIntroMessage(message);\n}\nexport const getIsFirstUnreadMessage = _ref => {\n  let {\n    firstUnreadMessageId,\n    isFirstMessage,\n    lastReadDate,\n    lastReadMessageId,\n    message,\n    previousMessage,\n    unreadMessageCount = 0\n  } = _ref;\n  // prevent showing unread indicator in threads\n  if (message.parent_id) return false;\n  const createdAtTimestamp = message.created_at && new Date(message.created_at).getTime();\n  const lastReadTimestamp = lastReadDate === null || lastReadDate === void 0 ? void 0 : lastReadDate.getTime();\n  const messageIsUnread = !!createdAtTimestamp && !!lastReadTimestamp && createdAtTimestamp > lastReadTimestamp;\n  const previousMessageIsLastRead = !!lastReadMessageId && lastReadMessageId === (previousMessage === null || previousMessage === void 0 ? void 0 : previousMessage.id);\n  return firstUnreadMessageId === message.id || !!unreadMessageCount && messageIsUnread && (isFirstMessage || previousMessageIsLastRead);\n};","map":{"version":3,"names":["nanoid","CUSTOM_MESSAGE_TYPE","isMessageEdited","isDate","processMessages","params","messages","reviewProcessedMessage","setGiphyPreviewMessage","context","_objectWithoutProperties","_excluded","enableDateSeparator","hideDeletedMessages","hideNewMessageSeparator","lastRead","userId","unread","ephemeralMessagePresent","lastDateSeparator","newMessages","i","length","message","type","command","changes","messageDate","created_at","toDateString","previousMessage","prevMessageDate","_message$user","Date","user","id","push","customType","date","makeDateMessageId","isDateSeparatorMessage","index","processedMessages","undefined","makeIntroMessage","intro","idSuffix","toISOString","e","concat","getLastReceived","status","getReadStates","read","arguments","returnAllReadData","readData","Object","values","forEach","readState","last_read","userLastReadMsgId","msg","insertIntro","headerPosition","unshift","messageTime","getTime","nextMessageTime","splice","getGroupStyles","nextMessage","noGroupByUser","maxTimeBetweenGroupedMessages","_message$attachments","_previousMessage$atta","_message$user2","_previousMessage$user","_nextMessage$attachme","_message$user3","_nextMessage$user","isIntroMessage","attachments","isTopMessage","deleted_at","reaction_groups","keys","isBottomMessage","hasMoreMessagesProbably","returnedCountMessages","limit","hasNotMoreMessages","isLocalMessage","getIsFirstUnreadMessage","_ref","firstUnreadMessageId","isFirstMessage","lastReadDate","lastReadMessageId","unreadMessageCount","parent_id","createdAtTimestamp","lastReadTimestamp","messageIsUnread","previousMessageIsLastRead"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MessageList/utils.js"],"sourcesContent":["import { nanoid } from 'nanoid';\nimport { CUSTOM_MESSAGE_TYPE } from '../../constants/messageTypes';\nimport { isMessageEdited } from '../Message/utils';\nimport { isDate } from '../../i18n';\n/**\n * processMessages - Transform the input message list according to config parameters\n *\n * Inserts date separators btw. messages created on different dates or before unread incoming messages. By default:\n * - enabled in main message list\n * - disabled in virtualized message list\n * - disabled in thread\n *\n * Allows to filter out deleted messages, contolled by hideDeletedMessages param. This is disabled by default.\n *\n * Sets Giphy preview message for VirtualizedMessageList\n *\n * The only required params are messages and userId, the rest are config params:\n *\n * @return {LocalMessage[]} Transformed list of messages\n */\nexport const processMessages = (params) => {\n    const { messages, reviewProcessedMessage, setGiphyPreviewMessage, ...context } = params;\n    const { enableDateSeparator, hideDeletedMessages, hideNewMessageSeparator, lastRead, userId, } = context;\n    let unread = false;\n    let ephemeralMessagePresent = false;\n    let lastDateSeparator;\n    const newMessages = [];\n    for (let i = 0; i < messages.length; i += 1) {\n        const message = messages[i];\n        if (hideDeletedMessages && message.type === 'deleted') {\n            continue;\n        }\n        if (setGiphyPreviewMessage &&\n            message.type === 'ephemeral' &&\n            message.command === 'giphy') {\n            ephemeralMessagePresent = true;\n            setGiphyPreviewMessage(message);\n            continue;\n        }\n        const changes = [];\n        const messageDate = (message.created_at &&\n            isDate(message.created_at) &&\n            message.created_at.toDateString()) ||\n            '';\n        const previousMessage = messages[i - 1];\n        let prevMessageDate = messageDate;\n        if (enableDateSeparator &&\n            previousMessage?.created_at &&\n            isDate(previousMessage.created_at)) {\n            prevMessageDate = previousMessage.created_at.toDateString();\n        }\n        if (!unread && !hideNewMessageSeparator) {\n            unread =\n                (lastRead && message.created_at && new Date(lastRead) < message.created_at) ||\n                    false;\n            // do not show date separator for current user's messages\n            if (enableDateSeparator && unread && message.user?.id !== userId) {\n                changes.push({\n                    customType: CUSTOM_MESSAGE_TYPE.date,\n                    date: message.created_at,\n                    id: makeDateMessageId(message.created_at),\n                    unread,\n                });\n            }\n        }\n        if (enableDateSeparator &&\n            (i === 0 || // always put date separator before the first message\n                messageDate !== prevMessageDate || // add date separator btw. 2 messages created on different date\n                // if hiding deleted messages replace the previous deleted message(s) with A separator if the last rendered message was created on different date\n                (hideDeletedMessages &&\n                    previousMessage?.type === 'deleted' &&\n                    lastDateSeparator !== messageDate)) &&\n            !isDateSeparatorMessage(changes[changes.length - 1]) // do not show two date separators in a row)\n        ) {\n            lastDateSeparator = messageDate;\n            changes.push({\n                customType: CUSTOM_MESSAGE_TYPE.date,\n                date: message.created_at,\n                id: makeDateMessageId(message.created_at),\n            }, message);\n        }\n        else {\n            changes.push(message);\n        }\n        newMessages.push(...(reviewProcessedMessage?.({\n            changes,\n            context,\n            index: i,\n            messages,\n            processedMessages: newMessages,\n        }) || changes));\n    }\n    // clean up the giphy preview component state after a Cancel action\n    if (setGiphyPreviewMessage && !ephemeralMessagePresent) {\n        setGiphyPreviewMessage(undefined);\n    }\n    return newMessages;\n};\nexport const makeIntroMessage = () => ({\n    customType: CUSTOM_MESSAGE_TYPE.intro,\n    id: nanoid(),\n});\nexport const makeDateMessageId = (date) => {\n    let idSuffix;\n    try {\n        idSuffix = !date ? nanoid() : date instanceof Date ? date.toISOString() : date;\n    }\n    catch (e) {\n        idSuffix = nanoid();\n    }\n    return `${CUSTOM_MESSAGE_TYPE.date}-${idSuffix}`;\n};\n// fast since it usually iterates just the last few messages\nexport const getLastReceived = (messages) => {\n    for (let i = messages.length - 1; i > 0; i -= 1) {\n        if (messages[i].status === 'received') {\n            return messages[i].id;\n        }\n    }\n    return null;\n};\nexport const getReadStates = (messages, read = {}, returnAllReadData) => {\n    // create object with empty array for each message id\n    const readData = {};\n    Object.values(read).forEach((readState) => {\n        if (!readState.last_read)\n            return;\n        let userLastReadMsgId;\n        // loop messages sent by current user and add read data for other users in channel\n        messages.forEach((msg) => {\n            if (msg.created_at && msg.created_at < readState.last_read) {\n                userLastReadMsgId = msg.id;\n                // if true, save other user's read data for all messages they've read\n                if (returnAllReadData) {\n                    if (!readData[userLastReadMsgId]) {\n                        readData[userLastReadMsgId] = [];\n                    }\n                    readData[userLastReadMsgId].push(readState.user);\n                }\n            }\n        });\n        // if true, only save read data for other user's last read message\n        if (userLastReadMsgId && !returnAllReadData) {\n            if (!readData[userLastReadMsgId]) {\n                readData[userLastReadMsgId] = [];\n            }\n            readData[userLastReadMsgId].push(readState.user);\n        }\n    });\n    return readData;\n};\nexport const insertIntro = (messages, headerPosition) => {\n    const newMessages = messages;\n    const intro = makeIntroMessage();\n    // if no headerPosition is set, HeaderComponent will go at the top\n    if (!headerPosition) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // if no messages, intro gets inserted\n    if (!newMessages.length) {\n        newMessages.unshift(intro);\n        return newMessages;\n    }\n    // else loop over the messages\n    for (let i = 0; i < messages.length; i += 1) {\n        const messageTime = isDate(messages[i].created_at)\n            ? messages[i].created_at.getTime()\n            : null;\n        const nextMessageTime = isDate(messages[i + 1].created_at)\n            ? messages[i + 1].created_at.getTime()\n            : null;\n        // header position is smaller than message time so comes after;\n        if (messageTime && messageTime < headerPosition) {\n            // if header position is also smaller than message time continue;\n            if (nextMessageTime && nextMessageTime < headerPosition) {\n                if (messages[i + 1] && isDateSeparatorMessage(messages[i + 1]))\n                    continue;\n                if (!nextMessageTime) {\n                    newMessages.push(intro);\n                    return newMessages;\n                }\n            }\n            else {\n                newMessages.splice(i + 1, 0, intro);\n                return newMessages;\n            }\n        }\n    }\n    return newMessages;\n};\nexport const getGroupStyles = (message, previousMessage, nextMessage, noGroupByUser, maxTimeBetweenGroupedMessages) => {\n    if (isDateSeparatorMessage(message) || isIntroMessage(message))\n        return '';\n    if (noGroupByUser || message.attachments?.length !== 0)\n        return 'single';\n    const isTopMessage = !previousMessage ||\n        isIntroMessage(previousMessage) ||\n        isDateSeparatorMessage(previousMessage) ||\n        previousMessage.type === 'system' ||\n        previousMessage.type === 'error' ||\n        previousMessage.attachments?.length !== 0 ||\n        message.user?.id !== previousMessage.user?.id ||\n        previousMessage.deleted_at ||\n        (message.reaction_groups && Object.keys(message.reaction_groups).length > 0) ||\n        isMessageEdited(previousMessage) ||\n        (maxTimeBetweenGroupedMessages !== undefined &&\n            previousMessage.created_at &&\n            message.created_at &&\n            new Date(message.created_at).getTime() -\n                new Date(previousMessage.created_at).getTime() >\n                maxTimeBetweenGroupedMessages);\n    const isBottomMessage = !nextMessage ||\n        isIntroMessage(nextMessage) ||\n        isDateSeparatorMessage(nextMessage) ||\n        nextMessage.type === 'system' ||\n        nextMessage.type === 'error' ||\n        nextMessage.attachments?.length !== 0 ||\n        message.user?.id !== nextMessage.user?.id ||\n        nextMessage.deleted_at ||\n        (nextMessage.reaction_groups &&\n            Object.keys(nextMessage.reaction_groups).length > 0) ||\n        isMessageEdited(message) ||\n        (maxTimeBetweenGroupedMessages !== undefined &&\n            nextMessage.created_at &&\n            message.created_at &&\n            new Date(nextMessage.created_at).getTime() -\n                new Date(message.created_at).getTime() >\n                maxTimeBetweenGroupedMessages);\n    if (!isTopMessage && !isBottomMessage) {\n        if (message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'middle';\n    }\n    if (isBottomMessage) {\n        if (isTopMessage || message.deleted_at || message.type === 'error')\n            return 'single';\n        return 'bottom';\n    }\n    if (isTopMessage)\n        return 'top';\n    return '';\n};\n// \"Probably\" included, because it may happen that the last page was returned and it has exactly the size of the limit\n// but the back-end cannot provide us with information on whether it has still more messages in the DB\n// FIXME: once the pagination state is moved from Channel to MessageList, these should be moved as well.\n//  The MessageList should have configurable the limit for performing the requests.\n//  This parameter would then be used within these functions\nexport const hasMoreMessagesProbably = (returnedCountMessages, limit) => returnedCountMessages >= limit;\n// @deprecated\nexport const hasNotMoreMessages = (returnedCountMessages, limit) => returnedCountMessages < limit;\nexport function isIntroMessage(message) {\n    return message.customType === CUSTOM_MESSAGE_TYPE.intro;\n}\nexport function isDateSeparatorMessage(message) {\n    return (message !== null &&\n        typeof message === 'object' &&\n        message.customType === CUSTOM_MESSAGE_TYPE.date &&\n        isDate(message.date));\n}\nexport function isLocalMessage(message) {\n    return !isDateSeparatorMessage(message) && !isIntroMessage(message);\n}\nexport const getIsFirstUnreadMessage = ({ firstUnreadMessageId, isFirstMessage, lastReadDate, lastReadMessageId, message, previousMessage, unreadMessageCount = 0, }) => {\n    // prevent showing unread indicator in threads\n    if (message.parent_id)\n        return false;\n    const createdAtTimestamp = message.created_at && new Date(message.created_at).getTime();\n    const lastReadTimestamp = lastReadDate?.getTime();\n    const messageIsUnread = !!createdAtTimestamp && !!lastReadTimestamp && createdAtTimestamp > lastReadTimestamp;\n    const previousMessageIsLastRead = !!lastReadMessageId && lastReadMessageId === previousMessage?.id;\n    return (firstUnreadMessageId === message.id ||\n        (!!unreadMessageCount &&\n            messageIsUnread &&\n            (isFirstMessage || previousMessageIsLastRead)));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}