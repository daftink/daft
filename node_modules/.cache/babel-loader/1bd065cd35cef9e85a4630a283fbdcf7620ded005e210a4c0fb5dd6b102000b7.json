{"ast":null,"code":"import throttle from 'lodash.throttle';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useChannelActionContext, useTranslationContext } from '../../../context';\nconst isSeekable = audioElement => !(audioElement.duration === Infinity || isNaN(audioElement.duration));\nexport const elementIsPlaying = audioElement => audioElement && !(audioElement.paused || audioElement.ended);\nconst logError = e => console.error('[AUDIO PLAYER]', e);\nconst DEFAULT_PLAYBACK_RATES = [1.0, 1.5, 2.0];\nexport const useAudioController = function () {\n  let {\n    durationSeconds,\n    mimeType,\n    playbackRates = DEFAULT_PLAYBACK_RATES\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    addNotification\n  } = useChannelActionContext('useAudioController');\n  const {\n    t\n  } = useTranslationContext('useAudioController');\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [playbackError, setPlaybackError] = useState();\n  const [canPlayRecord, setCanPlayRecord] = useState(true);\n  const [secondsElapsed, setSecondsElapsed] = useState(0);\n  const [playbackRateIndex, setPlaybackRateIndex] = useState(0);\n  const playTimeout = useRef(undefined);\n  const audioRef = useRef(null);\n  const registerError = useCallback(e => {\n    logError(e);\n    setPlaybackError(e);\n    addNotification(e.message, 'error');\n  }, [addNotification]);\n  const togglePlay = useCallback(async () => {\n    if (!audioRef.current) return;\n    clearTimeout(playTimeout.current);\n    playTimeout.current = undefined;\n    if (mimeType && !audioRef.current.canPlayType(mimeType)) {\n      registerError(new Error(t('Recording format is not supported and cannot be reproduced')));\n      setCanPlayRecord(false);\n      return;\n    }\n    if (elementIsPlaying(audioRef.current)) {\n      audioRef.current.pause();\n      setIsPlaying(false);\n    } else {\n      playTimeout.current = setTimeout(() => {\n        if (!audioRef.current) return;\n        try {\n          audioRef.current.pause();\n          setIsPlaying(false);\n        } catch (e) {\n          registerError(new Error(t('Failed to play the recording')));\n        }\n      }, 2000);\n      try {\n        await audioRef.current.play();\n        setIsPlaying(true);\n      } catch (e) {\n        registerError(e);\n        setIsPlaying(false);\n      } finally {\n        clearTimeout(playTimeout.current);\n        playTimeout.current = undefined;\n      }\n    }\n  }, [mimeType, registerError, t]);\n  const increasePlaybackRate = () => {\n    setPlaybackRateIndex(prev => {\n      if (!audioRef.current) return prev;\n      const nextIndex = prev === playbackRates.length - 1 ? 0 : prev + 1;\n      audioRef.current.playbackRate = playbackRates[nextIndex];\n      return nextIndex;\n    });\n  };\n  const seek = useMemo(() => throttle(_ref => {\n    let {\n      clientX,\n      currentTarget\n    } = _ref;\n    if (!(currentTarget && audioRef.current)) return;\n    if (!isSeekable(audioRef.current)) {\n      registerError(new Error(t('Cannot seek in the recording')));\n      return;\n    }\n    const {\n      width,\n      x\n    } = currentTarget.getBoundingClientRect();\n    const ratio = (clientX - x) / width;\n    if (ratio > 1 || ratio < 0) return;\n    const currentTime = ratio * audioRef.current.duration;\n    setSecondsElapsed(currentTime);\n    audioRef.current.currentTime = currentTime;\n  }, 16), [registerError, t]);\n  useEffect(() => {\n    if (!audioRef.current) return;\n    const audioElement = audioRef.current;\n    const handleEnded = () => {\n      var _ref2, _audioElement$duratio;\n      setSecondsElapsed((_ref2 = (_audioElement$duratio = audioElement === null || audioElement === void 0 ? void 0 : audioElement.duration) !== null && _audioElement$duratio !== void 0 ? _audioElement$duratio : durationSeconds) !== null && _ref2 !== void 0 ? _ref2 : 0);\n      setIsPlaying(false);\n    };\n    audioElement.addEventListener('ended', handleEnded);\n    const handleError = () => {\n      addNotification(t('Error reproducing the recording'), 'error');\n      setIsPlaying(false);\n    };\n    audioElement.addEventListener('error', handleError);\n    const handleTimeupdate = () => {\n      setSecondsElapsed(audioElement === null || audioElement === void 0 ? void 0 : audioElement.currentTime);\n    };\n    audioElement.addEventListener('timeupdate', handleTimeupdate);\n    return () => {\n      audioElement.pause();\n      audioElement.removeEventListener('ended', handleEnded);\n      audioElement.removeEventListener('error', handleError);\n      audioElement.removeEventListener('timeupdate', handleTimeupdate);\n    };\n  }, [addNotification, durationSeconds, t]);\n  return {\n    audioRef,\n    canPlayRecord,\n    increasePlaybackRate,\n    isPlaying,\n    playbackError,\n    playbackRate: playbackRates[playbackRateIndex],\n    progress: audioRef.current && secondsElapsed ? secondsElapsed / audioRef.current.duration * 100 : 0,\n    secondsElapsed,\n    seek,\n    togglePlay\n  };\n};","map":{"version":3,"names":["throttle","useCallback","useEffect","useMemo","useRef","useState","useChannelActionContext","useTranslationContext","isSeekable","audioElement","duration","Infinity","isNaN","elementIsPlaying","paused","ended","logError","e","console","error","DEFAULT_PLAYBACK_RATES","useAudioController","durationSeconds","mimeType","playbackRates","arguments","length","undefined","addNotification","t","isPlaying","setIsPlaying","playbackError","setPlaybackError","canPlayRecord","setCanPlayRecord","secondsElapsed","setSecondsElapsed","playbackRateIndex","setPlaybackRateIndex","playTimeout","audioRef","registerError","message","togglePlay","current","clearTimeout","canPlayType","Error","pause","setTimeout","play","increasePlaybackRate","prev","nextIndex","playbackRate","seek","_ref","clientX","currentTarget","width","x","getBoundingClientRect","ratio","currentTime","handleEnded","_ref2","_audioElement$duratio","addEventListener","handleError","handleTimeupdate","removeEventListener","progress"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/Attachment/hooks/useAudioController.js"],"sourcesContent":["import throttle from 'lodash.throttle';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useChannelActionContext, useTranslationContext } from '../../../context';\nconst isSeekable = (audioElement) => !(audioElement.duration === Infinity || isNaN(audioElement.duration));\nexport const elementIsPlaying = (audioElement) => audioElement && !(audioElement.paused || audioElement.ended);\nconst logError = (e) => console.error('[AUDIO PLAYER]', e);\nconst DEFAULT_PLAYBACK_RATES = [1.0, 1.5, 2.0];\nexport const useAudioController = ({ durationSeconds, mimeType, playbackRates = DEFAULT_PLAYBACK_RATES, } = {}) => {\n    const { addNotification } = useChannelActionContext('useAudioController');\n    const { t } = useTranslationContext('useAudioController');\n    const [isPlaying, setIsPlaying] = useState(false);\n    const [playbackError, setPlaybackError] = useState();\n    const [canPlayRecord, setCanPlayRecord] = useState(true);\n    const [secondsElapsed, setSecondsElapsed] = useState(0);\n    const [playbackRateIndex, setPlaybackRateIndex] = useState(0);\n    const playTimeout = useRef(undefined);\n    const audioRef = useRef(null);\n    const registerError = useCallback((e) => {\n        logError(e);\n        setPlaybackError(e);\n        addNotification(e.message, 'error');\n    }, [addNotification]);\n    const togglePlay = useCallback(async () => {\n        if (!audioRef.current)\n            return;\n        clearTimeout(playTimeout.current);\n        playTimeout.current = undefined;\n        if (mimeType && !audioRef.current.canPlayType(mimeType)) {\n            registerError(new Error(t('Recording format is not supported and cannot be reproduced')));\n            setCanPlayRecord(false);\n            return;\n        }\n        if (elementIsPlaying(audioRef.current)) {\n            audioRef.current.pause();\n            setIsPlaying(false);\n        }\n        else {\n            playTimeout.current = setTimeout(() => {\n                if (!audioRef.current)\n                    return;\n                try {\n                    audioRef.current.pause();\n                    setIsPlaying(false);\n                }\n                catch (e) {\n                    registerError(new Error(t('Failed to play the recording')));\n                }\n            }, 2000);\n            try {\n                await audioRef.current.play();\n                setIsPlaying(true);\n            }\n            catch (e) {\n                registerError(e);\n                setIsPlaying(false);\n            }\n            finally {\n                clearTimeout(playTimeout.current);\n                playTimeout.current = undefined;\n            }\n        }\n    }, [mimeType, registerError, t]);\n    const increasePlaybackRate = () => {\n        setPlaybackRateIndex((prev) => {\n            if (!audioRef.current)\n                return prev;\n            const nextIndex = prev === playbackRates.length - 1 ? 0 : prev + 1;\n            audioRef.current.playbackRate = playbackRates[nextIndex];\n            return nextIndex;\n        });\n    };\n    const seek = useMemo(() => throttle(({ clientX, currentTarget }) => {\n        if (!(currentTarget && audioRef.current))\n            return;\n        if (!isSeekable(audioRef.current)) {\n            registerError(new Error(t('Cannot seek in the recording')));\n            return;\n        }\n        const { width, x } = currentTarget.getBoundingClientRect();\n        const ratio = (clientX - x) / width;\n        if (ratio > 1 || ratio < 0)\n            return;\n        const currentTime = ratio * audioRef.current.duration;\n        setSecondsElapsed(currentTime);\n        audioRef.current.currentTime = currentTime;\n    }, 16), [registerError, t]);\n    useEffect(() => {\n        if (!audioRef.current)\n            return;\n        const audioElement = audioRef.current;\n        const handleEnded = () => {\n            setSecondsElapsed(audioElement?.duration ?? durationSeconds ?? 0);\n            setIsPlaying(false);\n        };\n        audioElement.addEventListener('ended', handleEnded);\n        const handleError = () => {\n            addNotification(t('Error reproducing the recording'), 'error');\n            setIsPlaying(false);\n        };\n        audioElement.addEventListener('error', handleError);\n        const handleTimeupdate = () => {\n            setSecondsElapsed(audioElement?.currentTime);\n        };\n        audioElement.addEventListener('timeupdate', handleTimeupdate);\n        return () => {\n            audioElement.pause();\n            audioElement.removeEventListener('ended', handleEnded);\n            audioElement.removeEventListener('error', handleError);\n            audioElement.removeEventListener('timeupdate', handleTimeupdate);\n        };\n    }, [addNotification, durationSeconds, t]);\n    return {\n        audioRef,\n        canPlayRecord,\n        increasePlaybackRate,\n        isPlaying,\n        playbackError,\n        playbackRate: playbackRates[playbackRateIndex],\n        progress: audioRef.current && secondsElapsed\n            ? (secondsElapsed / audioRef.current.duration) * 100\n            : 0,\n        secondsElapsed,\n        seek,\n        togglePlay,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}