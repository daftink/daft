{"ast":null,"code":"import { useCallback } from 'react';\nexport const useHandleFileChangeWrapper = function () {\n  let resetOnChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  let handler = arguments.length > 1 ? arguments[1] : undefined;\n  return useCallback(_ref => {\n    let {\n      currentTarget\n    } = _ref;\n    const {\n      files\n    } = currentTarget;\n    if (!files) return;\n    try {\n      handler === null || handler === void 0 || handler(Array.from(files));\n    } catch (error) {\n      console.error(error);\n    }\n    if (resetOnChange) currentTarget.value = '';\n  }, [handler, resetOnChange]);\n};\nexport function dataTransferItemsHaveFiles(items) {\n  if (!items || !items.length) {\n    return false;\n  }\n  for (const item of items) {\n    if (item.kind === 'file' || item.type === 'text/html') {\n      return true;\n    }\n  }\n  return false;\n}\nexport async function dataTransferItemsToFiles(items) {\n  if (!items || !items.length) {\n    return [];\n  }\n  // If there are files inside the DataTransferItem prefer those\n  const fileLikes = getFileLikes(items);\n  if (fileLikes.length) {\n    return fileLikes;\n  }\n  // Otherwise extract images from html\n  const blobPromises = [];\n  for (const item of items) {\n    if (item.type === 'text/html') {\n      blobPromises.push(new Promise(accept => {\n        item.getAsString(async s => {\n          const imagePromises = extractImageSources(s).map(src => getImageSource(fileLikes, src));\n          await Promise.all(imagePromises);\n          accept();\n        });\n      }));\n    }\n  }\n  await Promise.all(blobPromises);\n  return fileLikes;\n}\nfunction getFileLikes(items) {\n  const fileLikes = [];\n  for (const item of items) {\n    if (item.kind === 'file') {\n      const file = item.getAsFile();\n      if (file) {\n        fileLikes.push(file);\n      }\n    }\n  }\n  return fileLikes;\n}\nasync function getImageSource(fileLikes, src) {\n  let res;\n  try {\n    res = await fetch(src);\n  } catch (e) {\n    return;\n  }\n  const contentType = res.headers.get('Content-type') || 'application/octet-stream';\n  const buf = await res.arrayBuffer();\n  const blob = new Blob([buf], {\n    type: contentType\n  });\n  fileLikes.push(blob);\n}\nconst extractImageSources = s => {\n  const imageTags = new DOMParser().parseFromString(s, 'text/html').getElementsByTagName('img');\n  return Array.from(imageTags, tag => tag.src).filter(tag => tag);\n};\nexport const isBlobButNotFile = obj => obj instanceof Blob && !(obj instanceof File);\nexport const createFileFromBlobs = _ref2 => {\n  let {\n    blobsArray,\n    fileName,\n    mimeType\n  } = _ref2;\n  const concatenatedBlob = new Blob(blobsArray, {\n    type: mimeType\n  });\n  return new File([concatenatedBlob], fileName, {\n    type: concatenatedBlob.type\n  });\n};\nexport const getExtensionFromMimeType = mimeType => {\n  const match = mimeType.match(/\\/([^/;]+)/);\n  return match && match[1];\n};\nexport const getRecordedMediaTypeFromMimeType = mimeType => {\n  const match = mimeType.match(/^(audio|video)\\/.*$/);\n  return match && match[1];\n};\nexport const readFileAsArrayBuffer = file => new Promise((resolve, reject) => {\n  const fileReader = new FileReader();\n  fileReader.onload = () => {\n    resolve(fileReader.result);\n  };\n  fileReader.onerror = () => {\n    reject(fileReader.error);\n  };\n  fileReader.readAsArrayBuffer(file);\n});\nexport const generateFileName = mimeType => \"file_\".concat(new Date().toISOString(), \".\").concat(getExtensionFromMimeType(mimeType));","map":{"version":3,"names":["useCallback","useHandleFileChangeWrapper","resetOnChange","arguments","length","undefined","handler","_ref","currentTarget","files","Array","from","error","console","value","dataTransferItemsHaveFiles","items","item","kind","type","dataTransferItemsToFiles","fileLikes","getFileLikes","blobPromises","push","Promise","accept","getAsString","s","imagePromises","extractImageSources","map","src","getImageSource","all","file","getAsFile","res","fetch","e","contentType","headers","get","buf","arrayBuffer","blob","Blob","imageTags","DOMParser","parseFromString","getElementsByTagName","tag","filter","isBlobButNotFile","obj","File","createFileFromBlobs","_ref2","blobsArray","fileName","mimeType","concatenatedBlob","getExtensionFromMimeType","match","getRecordedMediaTypeFromMimeType","readFileAsArrayBuffer","resolve","reject","fileReader","FileReader","onload","result","onerror","readAsArrayBuffer","generateFileName","concat","Date","toISOString"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/ReactFileUtilities/utils.js"],"sourcesContent":["import { useCallback } from 'react';\nexport const useHandleFileChangeWrapper = (resetOnChange = false, handler) => useCallback(({ currentTarget }) => {\n    const { files } = currentTarget;\n    if (!files)\n        return;\n    try {\n        handler?.(Array.from(files));\n    }\n    catch (error) {\n        console.error(error);\n    }\n    if (resetOnChange)\n        currentTarget.value = '';\n}, [handler, resetOnChange]);\nexport function dataTransferItemsHaveFiles(items) {\n    if (!items || !items.length) {\n        return false;\n    }\n    for (const item of items) {\n        if (item.kind === 'file' || item.type === 'text/html') {\n            return true;\n        }\n    }\n    return false;\n}\nexport async function dataTransferItemsToFiles(items) {\n    if (!items || !items.length) {\n        return [];\n    }\n    // If there are files inside the DataTransferItem prefer those\n    const fileLikes = getFileLikes(items);\n    if (fileLikes.length) {\n        return fileLikes;\n    }\n    // Otherwise extract images from html\n    const blobPromises = [];\n    for (const item of items) {\n        if (item.type === 'text/html') {\n            blobPromises.push(new Promise((accept) => {\n                item.getAsString(async (s) => {\n                    const imagePromises = extractImageSources(s).map((src) => getImageSource(fileLikes, src));\n                    await Promise.all(imagePromises);\n                    accept();\n                });\n            }));\n        }\n    }\n    await Promise.all(blobPromises);\n    return fileLikes;\n}\nfunction getFileLikes(items) {\n    const fileLikes = [];\n    for (const item of items) {\n        if (item.kind === 'file') {\n            const file = item.getAsFile();\n            if (file) {\n                fileLikes.push(file);\n            }\n        }\n    }\n    return fileLikes;\n}\nasync function getImageSource(fileLikes, src) {\n    let res;\n    try {\n        res = await fetch(src);\n    }\n    catch (e) {\n        return;\n    }\n    const contentType = res.headers.get('Content-type') || 'application/octet-stream';\n    const buf = await res.arrayBuffer();\n    const blob = new Blob([buf], { type: contentType });\n    fileLikes.push(blob);\n}\nconst extractImageSources = (s) => {\n    const imageTags = new DOMParser()\n        .parseFromString(s, 'text/html')\n        .getElementsByTagName('img');\n    return Array.from(imageTags, (tag) => tag.src).filter((tag) => tag);\n};\nexport const isBlobButNotFile = (obj) => obj instanceof Blob && !(obj instanceof File);\nexport const createFileFromBlobs = ({ blobsArray, fileName, mimeType, }) => {\n    const concatenatedBlob = new Blob(blobsArray, { type: mimeType });\n    return new File([concatenatedBlob], fileName, { type: concatenatedBlob.type });\n};\nexport const getExtensionFromMimeType = (mimeType) => {\n    const match = mimeType.match(/\\/([^/;]+)/);\n    return match && match[1];\n};\nexport const getRecordedMediaTypeFromMimeType = (mimeType) => {\n    const match = mimeType.match(/^(audio|video)\\/.*$/);\n    return match && match[1];\n};\nexport const readFileAsArrayBuffer = (file) => new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n        resolve(fileReader.result);\n    };\n    fileReader.onerror = () => {\n        reject(fileReader.error);\n    };\n    fileReader.readAsArrayBuffer(file);\n});\nexport const generateFileName = (mimeType) => `file_${new Date().toISOString()}.${getExtensionFromMimeType(mimeType)}`;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}