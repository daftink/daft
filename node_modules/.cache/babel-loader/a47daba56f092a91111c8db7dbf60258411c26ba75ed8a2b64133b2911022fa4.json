{"ast":null,"code":"import { divMod } from './utils';\nexport const resampleWaveformData = (waveformData, amplitudesCount) => waveformData.length === amplitudesCount ? waveformData : waveformData.length > amplitudesCount ? downSample(waveformData, amplitudesCount) : upSample(waveformData, amplitudesCount);\n/**\n * The downSample function uses the Largest-Triangle-Three-Buckets (LTTB) algorithm.\n * See the thesis Downsampling Time Series for Visual Representation by Sveinn Steinarsson for more (https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n * @param data\n * @param targetOutputSize\n */\nexport function downSample(data, targetOutputSize) {\n  if (data.length <= targetOutputSize || targetOutputSize === 0) {\n    return data;\n  }\n  if (targetOutputSize === 1) return [mean(data)];\n  const result = [];\n  // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output\n  const bucketSize = (data.length - 2) / (targetOutputSize - 2);\n  let lastSelectedPointIndex = 0;\n  result.push(data[lastSelectedPointIndex]); // Always add the first point\n  let maxAreaPoint, maxArea, triangleArea;\n  for (let bucketIndex = 1; bucketIndex < targetOutputSize - 1; bucketIndex++) {\n    const previousBucketRefPoint = data[lastSelectedPointIndex];\n    const nextBucketMean = getNextBucketMean(data, bucketIndex, bucketSize);\n    const currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;\n    const nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;\n    const countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;\n    maxArea = triangleArea = -1;\n    for (let currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {\n      const countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;\n      const countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;\n      const currentPointValue = data[currentPointIndex];\n      triangleArea = triangleAreaHeron(triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));\n      if (triangleArea > maxArea) {\n        maxArea = triangleArea;\n        maxAreaPoint = data[currentPointIndex];\n        lastSelectedPointIndex = currentPointIndex;\n      }\n    }\n    if (typeof maxAreaPoint !== 'undefined') result.push(maxAreaPoint);\n  }\n  result.push(data[data.length - 1]); // Always add the last point\n  return result;\n}\nconst triangleAreaHeron = (a, b, c) => {\n  const s = (a + b + c) / 2;\n  return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n};\nconst triangleBase = (a, b) => Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\nconst mean = values => values.reduce((acc, value) => acc + value, 0) / values.length;\nconst getNextBucketMean = (data, currentBucketIndex, bucketSize) => {\n  const nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;\n  let nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;\n  nextNextBucketStartIndex = nextNextBucketStartIndex < data.length ? nextNextBucketStartIndex : data.length;\n  return mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));\n};\nexport const upSample = (values, targetSize) => {\n  if (!values.length) {\n    console.warn('Cannot extend empty array of amplitudes.');\n    return values;\n  }\n  if (values.length > targetSize) {\n    console.warn('Requested to extend the waveformData that is longer than the target list size');\n    return values;\n  }\n  if (targetSize === values.length) return values;\n  // eslint-disable-next-line prefer-const\n  let [bucketSize, remainder] = divMod(targetSize, values.length);\n  const result = [];\n  for (let i = 0; i < values.length; i++) {\n    const extra = remainder && remainder-- ? 1 : 0;\n    result.push(...Array(bucketSize + extra).fill(values[i]));\n  }\n  return result;\n};","map":{"version":3,"names":["divMod","resampleWaveformData","waveformData","amplitudesCount","length","downSample","upSample","data","targetOutputSize","mean","result","bucketSize","lastSelectedPointIndex","push","maxAreaPoint","maxArea","triangleArea","bucketIndex","previousBucketRefPoint","nextBucketMean","getNextBucketMean","currentBucketStartIndex","Math","floor","nextBucketStartIndex","countUnitsBetweenAtoC","currentPointIndex","countUnitsBetweenAtoB","abs","countUnitsBetweenBtoC","currentPointValue","triangleAreaHeron","triangleBase","a","b","c","s","sqrt","pow","values","reduce","acc","value","currentBucketIndex","nextNextBucketStartIndex","slice","targetSize","console","warn","remainder","i","extra","Array","fill"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/Attachment/audioSampling.js"],"sourcesContent":["import { divMod } from './utils';\nexport const resampleWaveformData = (waveformData, amplitudesCount) => waveformData.length === amplitudesCount\n    ? waveformData\n    : waveformData.length > amplitudesCount\n        ? downSample(waveformData, amplitudesCount)\n        : upSample(waveformData, amplitudesCount);\n/**\n * The downSample function uses the Largest-Triangle-Three-Buckets (LTTB) algorithm.\n * See the thesis Downsampling Time Series for Visual Representation by Sveinn Steinarsson for more (https://skemman.is/bitstream/1946/15343/3/SS_MSthesis.pdf)\n * @param data\n * @param targetOutputSize\n */\nexport function downSample(data, targetOutputSize) {\n    if (data.length <= targetOutputSize || targetOutputSize === 0) {\n        return data;\n    }\n    if (targetOutputSize === 1)\n        return [mean(data)];\n    const result = [];\n    // bucket size adjusted due to the fact that the first and the last item in the original data array is kept in target output\n    const bucketSize = (data.length - 2) / (targetOutputSize - 2);\n    let lastSelectedPointIndex = 0;\n    result.push(data[lastSelectedPointIndex]); // Always add the first point\n    let maxAreaPoint, maxArea, triangleArea;\n    for (let bucketIndex = 1; bucketIndex < targetOutputSize - 1; bucketIndex++) {\n        const previousBucketRefPoint = data[lastSelectedPointIndex];\n        const nextBucketMean = getNextBucketMean(data, bucketIndex, bucketSize);\n        const currentBucketStartIndex = Math.floor((bucketIndex - 1) * bucketSize) + 1;\n        const nextBucketStartIndex = Math.floor(bucketIndex * bucketSize) + 1;\n        const countUnitsBetweenAtoC = 1 + nextBucketStartIndex - currentBucketStartIndex;\n        maxArea = triangleArea = -1;\n        for (let currentPointIndex = currentBucketStartIndex; currentPointIndex < nextBucketStartIndex; currentPointIndex++) {\n            const countUnitsBetweenAtoB = Math.abs(currentPointIndex - currentBucketStartIndex) + 1;\n            const countUnitsBetweenBtoC = countUnitsBetweenAtoC - countUnitsBetweenAtoB;\n            const currentPointValue = data[currentPointIndex];\n            triangleArea = triangleAreaHeron(triangleBase(Math.abs(previousBucketRefPoint - currentPointValue), countUnitsBetweenAtoB), triangleBase(Math.abs(currentPointValue - nextBucketMean), countUnitsBetweenBtoC), triangleBase(Math.abs(previousBucketRefPoint - nextBucketMean), countUnitsBetweenAtoC));\n            if (triangleArea > maxArea) {\n                maxArea = triangleArea;\n                maxAreaPoint = data[currentPointIndex];\n                lastSelectedPointIndex = currentPointIndex;\n            }\n        }\n        if (typeof maxAreaPoint !== 'undefined')\n            result.push(maxAreaPoint);\n    }\n    result.push(data[data.length - 1]); // Always add the last point\n    return result;\n}\nconst triangleAreaHeron = (a, b, c) => {\n    const s = (a + b + c) / 2;\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n};\nconst triangleBase = (a, b) => Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\nconst mean = (values) => values.reduce((acc, value) => acc + value, 0) / values.length;\nconst getNextBucketMean = (data, currentBucketIndex, bucketSize) => {\n    const nextBucketStartIndex = Math.floor(currentBucketIndex * bucketSize) + 1;\n    let nextNextBucketStartIndex = Math.floor((currentBucketIndex + 1) * bucketSize) + 1;\n    nextNextBucketStartIndex =\n        nextNextBucketStartIndex < data.length ? nextNextBucketStartIndex : data.length;\n    return mean(data.slice(nextBucketStartIndex, nextNextBucketStartIndex));\n};\nexport const upSample = (values, targetSize) => {\n    if (!values.length) {\n        console.warn('Cannot extend empty array of amplitudes.');\n        return values;\n    }\n    if (values.length > targetSize) {\n        console.warn('Requested to extend the waveformData that is longer than the target list size');\n        return values;\n    }\n    if (targetSize === values.length)\n        return values;\n    // eslint-disable-next-line prefer-const\n    let [bucketSize, remainder] = divMod(targetSize, values.length);\n    const result = [];\n    for (let i = 0; i < values.length; i++) {\n        const extra = remainder && remainder-- ? 1 : 0;\n        result.push(...Array(bucketSize + extra).fill(values[i]));\n    }\n    return result;\n};\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,SAAS;AAChC,OAAO,MAAMC,oBAAoB,GAAGA,CAACC,YAAY,EAAEC,eAAe,KAAKD,YAAY,CAACE,MAAM,KAAKD,eAAe,GACxGD,YAAY,GACZA,YAAY,CAACE,MAAM,GAAGD,eAAe,GACjCE,UAAU,CAACH,YAAY,EAAEC,eAAe,CAAC,GACzCG,QAAQ,CAACJ,YAAY,EAAEC,eAAe,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,UAAUA,CAACE,IAAI,EAAEC,gBAAgB,EAAE;EAC/C,IAAID,IAAI,CAACH,MAAM,IAAII,gBAAgB,IAAIA,gBAAgB,KAAK,CAAC,EAAE;IAC3D,OAAOD,IAAI;EACf;EACA,IAAIC,gBAAgB,KAAK,CAAC,EACtB,OAAO,CAACC,IAAI,CAACF,IAAI,CAAC,CAAC;EACvB,MAAMG,MAAM,GAAG,EAAE;EACjB;EACA,MAAMC,UAAU,GAAG,CAACJ,IAAI,CAACH,MAAM,GAAG,CAAC,KAAKI,gBAAgB,GAAG,CAAC,CAAC;EAC7D,IAAII,sBAAsB,GAAG,CAAC;EAC9BF,MAAM,CAACG,IAAI,CAACN,IAAI,CAACK,sBAAsB,CAAC,CAAC,CAAC,CAAC;EAC3C,IAAIE,YAAY,EAAEC,OAAO,EAAEC,YAAY;EACvC,KAAK,IAAIC,WAAW,GAAG,CAAC,EAAEA,WAAW,GAAGT,gBAAgB,GAAG,CAAC,EAAES,WAAW,EAAE,EAAE;IACzE,MAAMC,sBAAsB,GAAGX,IAAI,CAACK,sBAAsB,CAAC;IAC3D,MAAMO,cAAc,GAAGC,iBAAiB,CAACb,IAAI,EAAEU,WAAW,EAAEN,UAAU,CAAC;IACvE,MAAMU,uBAAuB,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACN,WAAW,GAAG,CAAC,IAAIN,UAAU,CAAC,GAAG,CAAC;IAC9E,MAAMa,oBAAoB,GAAGF,IAAI,CAACC,KAAK,CAACN,WAAW,GAAGN,UAAU,CAAC,GAAG,CAAC;IACrE,MAAMc,qBAAqB,GAAG,CAAC,GAAGD,oBAAoB,GAAGH,uBAAuB;IAChFN,OAAO,GAAGC,YAAY,GAAG,CAAC,CAAC;IAC3B,KAAK,IAAIU,iBAAiB,GAAGL,uBAAuB,EAAEK,iBAAiB,GAAGF,oBAAoB,EAAEE,iBAAiB,EAAE,EAAE;MACjH,MAAMC,qBAAqB,GAAGL,IAAI,CAACM,GAAG,CAACF,iBAAiB,GAAGL,uBAAuB,CAAC,GAAG,CAAC;MACvF,MAAMQ,qBAAqB,GAAGJ,qBAAqB,GAAGE,qBAAqB;MAC3E,MAAMG,iBAAiB,GAAGvB,IAAI,CAACmB,iBAAiB,CAAC;MACjDV,YAAY,GAAGe,iBAAiB,CAACC,YAAY,CAACV,IAAI,CAACM,GAAG,CAACV,sBAAsB,GAAGY,iBAAiB,CAAC,EAAEH,qBAAqB,CAAC,EAAEK,YAAY,CAACV,IAAI,CAACM,GAAG,CAACE,iBAAiB,GAAGX,cAAc,CAAC,EAAEU,qBAAqB,CAAC,EAAEG,YAAY,CAACV,IAAI,CAACM,GAAG,CAACV,sBAAsB,GAAGC,cAAc,CAAC,EAAEM,qBAAqB,CAAC,CAAC;MACtS,IAAIT,YAAY,GAAGD,OAAO,EAAE;QACxBA,OAAO,GAAGC,YAAY;QACtBF,YAAY,GAAGP,IAAI,CAACmB,iBAAiB,CAAC;QACtCd,sBAAsB,GAAGc,iBAAiB;MAC9C;IACJ;IACA,IAAI,OAAOZ,YAAY,KAAK,WAAW,EACnCJ,MAAM,CAACG,IAAI,CAACC,YAAY,CAAC;EACjC;EACAJ,MAAM,CAACG,IAAI,CAACN,IAAI,CAACA,IAAI,CAACH,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;EACpC,OAAOM,MAAM;AACjB;AACA,MAAMqB,iBAAiB,GAAGA,CAACE,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAK;EACnC,MAAMC,CAAC,GAAG,CAACH,CAAC,GAAGC,CAAC,GAAGC,CAAC,IAAI,CAAC;EACzB,OAAOb,IAAI,CAACe,IAAI,CAACD,CAAC,IAAIA,CAAC,GAAGH,CAAC,CAAC,IAAIG,CAAC,GAAGF,CAAC,CAAC,IAAIE,CAAC,GAAGD,CAAC,CAAC,CAAC;AACrD,CAAC;AACD,MAAMH,YAAY,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAKZ,IAAI,CAACe,IAAI,CAACf,IAAI,CAACgB,GAAG,CAACL,CAAC,EAAE,CAAC,CAAC,GAAGX,IAAI,CAACgB,GAAG,CAACJ,CAAC,EAAE,CAAC,CAAC,CAAC;AACzE,MAAMzB,IAAI,GAAI8B,MAAM,IAAKA,MAAM,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,KAAK,KAAKD,GAAG,GAAGC,KAAK,EAAE,CAAC,CAAC,GAAGH,MAAM,CAACnC,MAAM;AACtF,MAAMgB,iBAAiB,GAAGA,CAACb,IAAI,EAAEoC,kBAAkB,EAAEhC,UAAU,KAAK;EAChE,MAAMa,oBAAoB,GAAGF,IAAI,CAACC,KAAK,CAACoB,kBAAkB,GAAGhC,UAAU,CAAC,GAAG,CAAC;EAC5E,IAAIiC,wBAAwB,GAAGtB,IAAI,CAACC,KAAK,CAAC,CAACoB,kBAAkB,GAAG,CAAC,IAAIhC,UAAU,CAAC,GAAG,CAAC;EACpFiC,wBAAwB,GACpBA,wBAAwB,GAAGrC,IAAI,CAACH,MAAM,GAAGwC,wBAAwB,GAAGrC,IAAI,CAACH,MAAM;EACnF,OAAOK,IAAI,CAACF,IAAI,CAACsC,KAAK,CAACrB,oBAAoB,EAAEoB,wBAAwB,CAAC,CAAC;AAC3E,CAAC;AACD,OAAO,MAAMtC,QAAQ,GAAGA,CAACiC,MAAM,EAAEO,UAAU,KAAK;EAC5C,IAAI,CAACP,MAAM,CAACnC,MAAM,EAAE;IAChB2C,OAAO,CAACC,IAAI,CAAC,0CAA0C,CAAC;IACxD,OAAOT,MAAM;EACjB;EACA,IAAIA,MAAM,CAACnC,MAAM,GAAG0C,UAAU,EAAE;IAC5BC,OAAO,CAACC,IAAI,CAAC,+EAA+E,CAAC;IAC7F,OAAOT,MAAM;EACjB;EACA,IAAIO,UAAU,KAAKP,MAAM,CAACnC,MAAM,EAC5B,OAAOmC,MAAM;EACjB;EACA,IAAI,CAAC5B,UAAU,EAAEsC,SAAS,CAAC,GAAGjD,MAAM,CAAC8C,UAAU,EAAEP,MAAM,CAACnC,MAAM,CAAC;EAC/D,MAAMM,MAAM,GAAG,EAAE;EACjB,KAAK,IAAIwC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,MAAM,CAACnC,MAAM,EAAE8C,CAAC,EAAE,EAAE;IACpC,MAAMC,KAAK,GAAGF,SAAS,IAAIA,SAAS,EAAE,GAAG,CAAC,GAAG,CAAC;IAC9CvC,MAAM,CAACG,IAAI,CAAC,GAAGuC,KAAK,CAACzC,UAAU,GAAGwC,KAAK,CAAC,CAACE,IAAI,CAACd,MAAM,CAACW,CAAC,CAAC,CAAC,CAAC;EAC7D;EACA,OAAOxC,MAAM;AACjB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}