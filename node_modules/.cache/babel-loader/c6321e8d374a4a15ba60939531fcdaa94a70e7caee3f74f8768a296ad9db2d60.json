{"ast":null,"code":"import uniqBy from 'lodash.uniqby';\nexport const MAX_QUERY_CHANNELS_LIMIT = 30;\n/**\n * @deprecated\n */\nexport const moveChannelUp = _ref => {\n  let {\n    activeChannel,\n    channels,\n    cid\n  } = _ref;\n  // get index of channel to move up\n  const channelIndex = channels.findIndex(channel => channel.cid === cid);\n  if (!activeChannel && channelIndex <= 0) return channels;\n  // get channel to move up\n  const channel = activeChannel || channels[channelIndex];\n  return uniqBy([channel, ...channels], 'cid');\n};\n/**\n * Expects channel array sorted by `{ pinned_at: -1 }`.\n *\n * TODO: add support for the `{ pinned_at: 1 }`\n */\nexport function findLastPinnedChannelIndex(_ref2) {\n  let {\n    channels\n  } = _ref2;\n  let lastPinnedChannelIndex = null;\n  for (const channel of channels) {\n    if (!isChannelPinned(channel)) break;\n    if (typeof lastPinnedChannelIndex === 'number') {\n      lastPinnedChannelIndex++;\n    } else {\n      lastPinnedChannelIndex = 0;\n    }\n  }\n  return lastPinnedChannelIndex;\n}\nexport const moveChannelUpwards = _ref3 => {\n  let {\n    channels,\n    channelToMove,\n    channelToMoveIndexWithinChannels,\n    sort\n  } = _ref3;\n  // get index of channel to move up\n  const targetChannelIndex = channelToMoveIndexWithinChannels !== null && channelToMoveIndexWithinChannels !== void 0 ? channelToMoveIndexWithinChannels : channels.findIndex(channel => channel.cid === channelToMove.cid);\n  const targetChannelExistsWithinList = targetChannelIndex >= 0;\n  const targetChannelAlreadyAtTheTop = targetChannelIndex === 0;\n  // pinned channels should not move within the list based on recent activity, channels which\n  // receive messages and are not pinned should move upwards but only under the last pinned channel\n  // in the list\n  const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n  const isTargetChannelPinned = isChannelPinned(channelToMove);\n  if (targetChannelAlreadyAtTheTop || considerPinnedChannels && isTargetChannelPinned) {\n    return channels;\n  }\n  const newChannels = [...channels];\n  // target channel index is known, remove it from the list\n  if (targetChannelExistsWithinList) {\n    newChannels.splice(targetChannelIndex, 1);\n  }\n  // as position of pinned channels has to stay unchanged, we need to\n  // find last pinned channel in the list to move the target channel after\n  let lastPinnedChannelIndex = null;\n  if (considerPinnedChannels) {\n    lastPinnedChannelIndex = findLastPinnedChannelIndex({\n      channels: newChannels\n    });\n  }\n  // re-insert it at the new place (to specific index if pinned channels are considered)\n  newChannels.splice(typeof lastPinnedChannelIndex === 'number' ? lastPinnedChannelIndex + 1 : 0, 0, channelToMove);\n  return newChannels;\n};\n/**\n * Returns `true` only if object with `pinned_at` property is first within the `sort` array\n * or if `pinned_at` key of the `sort` object gets picked first when using `for...in` looping mechanism\n * and value of the `pinned_at` is either `1` or `-1`.\n */\nexport const shouldConsiderPinnedChannels = sort => {\n  const value = extractSortValue({\n    atIndex: 0,\n    sort,\n    targetKey: 'pinned_at'\n  });\n  if (typeof value !== 'number') return false;\n  return Math.abs(value) === 1;\n};\nexport const extractSortValue = _ref4 => {\n  var _option$targetKey, _option;\n  let {\n    atIndex,\n    sort,\n    targetKey\n  } = _ref4;\n  if (!sort) return null;\n  let option = null;\n  if (Array.isArray(sort)) {\n    var _sort$atIndex;\n    option = (_sort$atIndex = sort[atIndex]) !== null && _sort$atIndex !== void 0 ? _sort$atIndex : null;\n  } else {\n    let index = 0;\n    for (const key in sort) {\n      if (index !== atIndex) {\n        index++;\n        continue;\n      }\n      if (key !== targetKey) {\n        return null;\n      }\n      option = sort;\n      break;\n    }\n  }\n  return (_option$targetKey = (_option = option) === null || _option === void 0 ? void 0 : _option[targetKey]) !== null && _option$targetKey !== void 0 ? _option$targetKey : null;\n};\n/**\n * Returns `true` only if `archived` property is of type `boolean` within `filters` object.\n */\nexport const shouldConsiderArchivedChannels = filters => {\n  if (!filters) return false;\n  return typeof filters.archived === 'boolean';\n};\n/**\n * Returns `true` only if `pinned_at` property is of type `string` within `membership` object.\n */\nexport const isChannelPinned = channel => {\n  if (!channel) return false;\n  const membership = channel.state.membership;\n  return typeof membership.pinned_at === 'string';\n};\n/**\n * Returns `true` only if `archived_at` property is of type `string` within `membership` object.\n */\nexport const isChannelArchived = channel => {\n  if (!channel) return false;\n  const membership = channel.state.membership;\n  return typeof membership.archived_at === 'string';\n};","map":{"version":3,"names":["uniqBy","MAX_QUERY_CHANNELS_LIMIT","moveChannelUp","_ref","activeChannel","channels","cid","channelIndex","findIndex","channel","findLastPinnedChannelIndex","_ref2","lastPinnedChannelIndex","isChannelPinned","moveChannelUpwards","_ref3","channelToMove","channelToMoveIndexWithinChannels","sort","targetChannelIndex","targetChannelExistsWithinList","targetChannelAlreadyAtTheTop","considerPinnedChannels","shouldConsiderPinnedChannels","isTargetChannelPinned","newChannels","splice","value","extractSortValue","atIndex","targetKey","Math","abs","_ref4","_option$targetKey","_option","option","Array","isArray","_sort$atIndex","index","key","shouldConsiderArchivedChannels","filters","archived","membership","state","pinned_at","isChannelArchived","archived_at"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/ChannelList/utils.js"],"sourcesContent":["import uniqBy from 'lodash.uniqby';\nexport const MAX_QUERY_CHANNELS_LIMIT = 30;\n/**\n * @deprecated\n */\nexport const moveChannelUp = ({ activeChannel, channels, cid }) => {\n    // get index of channel to move up\n    const channelIndex = channels.findIndex((channel) => channel.cid === cid);\n    if (!activeChannel && channelIndex <= 0)\n        return channels;\n    // get channel to move up\n    const channel = activeChannel || channels[channelIndex];\n    return uniqBy([channel, ...channels], 'cid');\n};\n/**\n * Expects channel array sorted by `{ pinned_at: -1 }`.\n *\n * TODO: add support for the `{ pinned_at: 1 }`\n */\nexport function findLastPinnedChannelIndex({ channels }) {\n    let lastPinnedChannelIndex = null;\n    for (const channel of channels) {\n        if (!isChannelPinned(channel))\n            break;\n        if (typeof lastPinnedChannelIndex === 'number') {\n            lastPinnedChannelIndex++;\n        }\n        else {\n            lastPinnedChannelIndex = 0;\n        }\n    }\n    return lastPinnedChannelIndex;\n}\nexport const moveChannelUpwards = ({ channels, channelToMove, channelToMoveIndexWithinChannels, sort, }) => {\n    // get index of channel to move up\n    const targetChannelIndex = channelToMoveIndexWithinChannels ??\n        channels.findIndex((channel) => channel.cid === channelToMove.cid);\n    const targetChannelExistsWithinList = targetChannelIndex >= 0;\n    const targetChannelAlreadyAtTheTop = targetChannelIndex === 0;\n    // pinned channels should not move within the list based on recent activity, channels which\n    // receive messages and are not pinned should move upwards but only under the last pinned channel\n    // in the list\n    const considerPinnedChannels = shouldConsiderPinnedChannels(sort);\n    const isTargetChannelPinned = isChannelPinned(channelToMove);\n    if (targetChannelAlreadyAtTheTop || (considerPinnedChannels && isTargetChannelPinned)) {\n        return channels;\n    }\n    const newChannels = [...channels];\n    // target channel index is known, remove it from the list\n    if (targetChannelExistsWithinList) {\n        newChannels.splice(targetChannelIndex, 1);\n    }\n    // as position of pinned channels has to stay unchanged, we need to\n    // find last pinned channel in the list to move the target channel after\n    let lastPinnedChannelIndex = null;\n    if (considerPinnedChannels) {\n        lastPinnedChannelIndex = findLastPinnedChannelIndex({ channels: newChannels });\n    }\n    // re-insert it at the new place (to specific index if pinned channels are considered)\n    newChannels.splice(typeof lastPinnedChannelIndex === 'number' ? lastPinnedChannelIndex + 1 : 0, 0, channelToMove);\n    return newChannels;\n};\n/**\n * Returns `true` only if object with `pinned_at` property is first within the `sort` array\n * or if `pinned_at` key of the `sort` object gets picked first when using `for...in` looping mechanism\n * and value of the `pinned_at` is either `1` or `-1`.\n */\nexport const shouldConsiderPinnedChannels = (sort) => {\n    const value = extractSortValue({ atIndex: 0, sort, targetKey: 'pinned_at' });\n    if (typeof value !== 'number')\n        return false;\n    return Math.abs(value) === 1;\n};\nexport const extractSortValue = ({ atIndex, sort, targetKey, }) => {\n    if (!sort)\n        return null;\n    let option = null;\n    if (Array.isArray(sort)) {\n        option = sort[atIndex] ?? null;\n    }\n    else {\n        let index = 0;\n        for (const key in sort) {\n            if (index !== atIndex) {\n                index++;\n                continue;\n            }\n            if (key !== targetKey) {\n                return null;\n            }\n            option = sort;\n            break;\n        }\n    }\n    return option?.[targetKey] ?? null;\n};\n/**\n * Returns `true` only if `archived` property is of type `boolean` within `filters` object.\n */\nexport const shouldConsiderArchivedChannels = (filters) => {\n    if (!filters)\n        return false;\n    return typeof filters.archived === 'boolean';\n};\n/**\n * Returns `true` only if `pinned_at` property is of type `string` within `membership` object.\n */\nexport const isChannelPinned = (channel) => {\n    if (!channel)\n        return false;\n    const membership = channel.state.membership;\n    return typeof membership.pinned_at === 'string';\n};\n/**\n * Returns `true` only if `archived_at` property is of type `string` within `membership` object.\n */\nexport const isChannelArchived = (channel) => {\n    if (!channel)\n        return false;\n    const membership = channel.state.membership;\n    return typeof membership.archived_at === 'string';\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}