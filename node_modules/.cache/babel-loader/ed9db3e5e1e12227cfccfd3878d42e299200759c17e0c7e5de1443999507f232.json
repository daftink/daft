{"ast":null,"code":"import { useEffect, useRef, useState } from 'react';\nexport function useNewMessageNotification(messages, currentUserId, hasMoreNewer) {\n  const [newMessagesNotification, setNewMessagesNotification] = useState(false);\n  const [isMessageListScrolledToBottom, setIsMessageListScrolledToBottom] = useState(true);\n  /**\n   * use the flag to avoid the initial \"new messages\" quick blink\n   */\n  const didMount = useRef(false);\n  const lastMessageId = useRef('');\n  const atBottom = useRef(false);\n  useEffect(() => {\n    var _lastMessage$user;\n    if (hasMoreNewer) {\n      setNewMessagesNotification(true);\n      return;\n    }\n    /* handle scrolling behavior for new messages */\n    if (!(messages !== null && messages !== void 0 && messages.length)) return;\n    const lastMessage = messages[messages.length - 1];\n    const prevMessageId = lastMessageId.current;\n    lastMessageId.current = lastMessage.id || ''; // update last message id\n    /* do nothing if new messages are loaded from top(loadMore)  */\n    if (lastMessage.id === prevMessageId) return;\n    /* if list is already at the bottom return, followOutput will do the job */\n    if (atBottom.current) return;\n    /* if the new message belongs to current user scroll to bottom */\n    if (((_lastMessage$user = lastMessage.user) === null || _lastMessage$user === void 0 ? void 0 : _lastMessage$user.id) !== currentUserId && didMount.current) {\n      /* otherwise just show newMessage notification  */\n      setNewMessagesNotification(true);\n    }\n    didMount.current = true;\n  }, [currentUserId, messages, hasMoreNewer]);\n  return {\n    atBottom,\n    isMessageListScrolledToBottom,\n    newMessagesNotification,\n    setIsMessageListScrolledToBottom,\n    setNewMessagesNotification\n  };\n}","map":{"version":3,"names":["useEffect","useRef","useState","useNewMessageNotification","messages","currentUserId","hasMoreNewer","newMessagesNotification","setNewMessagesNotification","isMessageListScrolledToBottom","setIsMessageListScrolledToBottom","didMount","lastMessageId","atBottom","_lastMessage$user","length","lastMessage","prevMessageId","current","id","user"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MessageList/hooks/VirtualizedMessageList/useNewMessageNotification.js"],"sourcesContent":["import { useEffect, useRef, useState } from 'react';\nexport function useNewMessageNotification(messages, currentUserId, hasMoreNewer) {\n    const [newMessagesNotification, setNewMessagesNotification] = useState(false);\n    const [isMessageListScrolledToBottom, setIsMessageListScrolledToBottom] = useState(true);\n    /**\n     * use the flag to avoid the initial \"new messages\" quick blink\n     */\n    const didMount = useRef(false);\n    const lastMessageId = useRef('');\n    const atBottom = useRef(false);\n    useEffect(() => {\n        if (hasMoreNewer) {\n            setNewMessagesNotification(true);\n            return;\n        }\n        /* handle scrolling behavior for new messages */\n        if (!messages?.length)\n            return;\n        const lastMessage = messages[messages.length - 1];\n        const prevMessageId = lastMessageId.current;\n        lastMessageId.current = lastMessage.id || ''; // update last message id\n        /* do nothing if new messages are loaded from top(loadMore)  */\n        if (lastMessage.id === prevMessageId)\n            return;\n        /* if list is already at the bottom return, followOutput will do the job */\n        if (atBottom.current)\n            return;\n        /* if the new message belongs to current user scroll to bottom */\n        if (lastMessage.user?.id !== currentUserId && didMount.current) {\n            /* otherwise just show newMessage notification  */\n            setNewMessagesNotification(true);\n        }\n        didMount.current = true;\n    }, [currentUserId, messages, hasMoreNewer]);\n    return {\n        atBottom,\n        isMessageListScrolledToBottom,\n        newMessagesNotification,\n        setIsMessageListScrolledToBottom,\n        setNewMessagesNotification,\n    };\n}\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AACnD,OAAO,SAASC,yBAAyBA,CAACC,QAAQ,EAAEC,aAAa,EAAEC,YAAY,EAAE;EAC7E,MAAM,CAACC,uBAAuB,EAAEC,0BAA0B,CAAC,GAAGN,QAAQ,CAAC,KAAK,CAAC;EAC7E,MAAM,CAACO,6BAA6B,EAAEC,gCAAgC,CAAC,GAAGR,QAAQ,CAAC,IAAI,CAAC;EACxF;AACJ;AACA;EACI,MAAMS,QAAQ,GAAGV,MAAM,CAAC,KAAK,CAAC;EAC9B,MAAMW,aAAa,GAAGX,MAAM,CAAC,EAAE,CAAC;EAChC,MAAMY,QAAQ,GAAGZ,MAAM,CAAC,KAAK,CAAC;EAC9BD,SAAS,CAAC,MAAM;IAAA,IAAAc,iBAAA;IACZ,IAAIR,YAAY,EAAE;MACdE,0BAA0B,CAAC,IAAI,CAAC;MAChC;IACJ;IACA;IACA,IAAI,EAACJ,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAEW,MAAM,GACjB;IACJ,MAAMC,WAAW,GAAGZ,QAAQ,CAACA,QAAQ,CAACW,MAAM,GAAG,CAAC,CAAC;IACjD,MAAME,aAAa,GAAGL,aAAa,CAACM,OAAO;IAC3CN,aAAa,CAACM,OAAO,GAAGF,WAAW,CAACG,EAAE,IAAI,EAAE,CAAC,CAAC;IAC9C;IACA,IAAIH,WAAW,CAACG,EAAE,KAAKF,aAAa,EAChC;IACJ;IACA,IAAIJ,QAAQ,CAACK,OAAO,EAChB;IACJ;IACA,IAAI,EAAAJ,iBAAA,GAAAE,WAAW,CAACI,IAAI,cAAAN,iBAAA,uBAAhBA,iBAAA,CAAkBK,EAAE,MAAKd,aAAa,IAAIM,QAAQ,CAACO,OAAO,EAAE;MAC5D;MACAV,0BAA0B,CAAC,IAAI,CAAC;IACpC;IACAG,QAAQ,CAACO,OAAO,GAAG,IAAI;EAC3B,CAAC,EAAE,CAACb,aAAa,EAAED,QAAQ,EAAEE,YAAY,CAAC,CAAC;EAC3C,OAAO;IACHO,QAAQ;IACRJ,6BAA6B;IAC7BF,uBAAuB;IACvBG,gCAAgC;IAChCF;EACJ,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}