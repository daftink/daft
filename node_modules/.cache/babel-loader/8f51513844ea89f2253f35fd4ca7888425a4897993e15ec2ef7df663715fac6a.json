{"ast":null,"code":"/**\n * prevent from duplicate invocation of channel.watch()\n * when events 'notification.message_new' and 'notification.added_to_channel' arrive at the same time\n */\nconst WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL = {};\n/**\n * Calls channel.watch() if it was not already recently called. Waits for watch promise to resolve even if it was invoked previously.\n * @param client\n * @param members\n * @param options\n * @param type\n * @param id\n * @param channel\n */\nexport const getChannel = async _ref => {\n  let {\n    channel,\n    client,\n    id,\n    members,\n    options,\n    type\n  } = _ref;\n  if (!channel && !type) {\n    throw new Error('Channel or channel type have to be provided to query a channel.');\n  }\n  // unfortunately typescript is not able to infer that if (!channel && !type) === false, then channel or type has to be truthy\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  const theChannel = channel || client.channel(type, id, {\n    members\n  });\n  // need to keep as with call to channel.watch the id can be changed from undefined to an actual ID generated server-side\n  const originalCid = theChannel !== null && theChannel !== void 0 && theChannel.id ? theChannel.cid : members && members.length ? generateChannelTempCid(theChannel.type, members) : undefined;\n  if (!originalCid) {\n    throw new Error('Channel ID or channel members array have to be provided to query a channel.');\n  }\n  const queryPromise = WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n  if (queryPromise) {\n    await queryPromise;\n  } else {\n    try {\n      WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid] = theChannel.watch(options);\n      await WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n    } finally {\n      delete WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n    }\n  }\n  return theChannel;\n};\n// Channels created without ID need to be referenced by an identifier until the back-end generates the final ID.\nconst generateChannelTempCid = (channelType, members) => {\n  if (!members) return;\n  const membersStr = [...members].sort().join(',');\n  return \"\".concat(channelType, \":!members-\").concat(membersStr);\n};","map":{"version":3,"names":["WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL","getChannel","_ref","channel","client","id","members","options","type","Error","theChannel","originalCid","cid","length","generateChannelTempCid","undefined","queryPromise","watch","channelType","membersStr","sort","join","concat"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/utils/getChannel.js"],"sourcesContent":["/**\n * prevent from duplicate invocation of channel.watch()\n * when events 'notification.message_new' and 'notification.added_to_channel' arrive at the same time\n */\nconst WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL = {};\n/**\n * Calls channel.watch() if it was not already recently called. Waits for watch promise to resolve even if it was invoked previously.\n * @param client\n * @param members\n * @param options\n * @param type\n * @param id\n * @param channel\n */\nexport const getChannel = async ({ channel, client, id, members, options, type, }) => {\n    if (!channel && !type) {\n        throw new Error('Channel or channel type have to be provided to query a channel.');\n    }\n    // unfortunately typescript is not able to infer that if (!channel && !type) === false, then channel or type has to be truthy\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const theChannel = channel || client.channel(type, id, { members });\n    // need to keep as with call to channel.watch the id can be changed from undefined to an actual ID generated server-side\n    const originalCid = theChannel?.id\n        ? theChannel.cid\n        : members && members.length\n            ? generateChannelTempCid(theChannel.type, members)\n            : undefined;\n    if (!originalCid) {\n        throw new Error('Channel ID or channel members array have to be provided to query a channel.');\n    }\n    const queryPromise = WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n    if (queryPromise) {\n        await queryPromise;\n    }\n    else {\n        try {\n            WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid] = theChannel.watch(options);\n            await WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n        }\n        finally {\n            delete WATCH_QUERY_IN_PROGRESS_FOR_CHANNEL[originalCid];\n        }\n    }\n    return theChannel;\n};\n// Channels created without ID need to be referenced by an identifier until the back-end generates the final ID.\nconst generateChannelTempCid = (channelType, members) => {\n    if (!members)\n        return;\n    const membersStr = [...members].sort().join(',');\n    return `${channelType}:!members-${membersStr}`;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA,MAAMA,mCAAmC,GAAG,CAAC,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,UAAU,GAAG,MAAAC,IAAA,IAA4D;EAAA,IAArD;IAAEC,OAAO;IAAEC,MAAM;IAAEC,EAAE;IAAEC,OAAO;IAAEC,OAAO;IAAEC;EAAM,CAAC,GAAAN,IAAA;EAC7E,IAAI,CAACC,OAAO,IAAI,CAACK,IAAI,EAAE;IACnB,MAAM,IAAIC,KAAK,CAAC,iEAAiE,CAAC;EACtF;EACA;EACA;EACA,MAAMC,UAAU,GAAGP,OAAO,IAAIC,MAAM,CAACD,OAAO,CAACK,IAAI,EAAEH,EAAE,EAAE;IAAEC;EAAQ,CAAC,CAAC;EACnE;EACA,MAAMK,WAAW,GAAGD,UAAU,aAAVA,UAAU,eAAVA,UAAU,CAAEL,EAAE,GAC5BK,UAAU,CAACE,GAAG,GACdN,OAAO,IAAIA,OAAO,CAACO,MAAM,GACrBC,sBAAsB,CAACJ,UAAU,CAACF,IAAI,EAAEF,OAAO,CAAC,GAChDS,SAAS;EACnB,IAAI,CAACJ,WAAW,EAAE;IACd,MAAM,IAAIF,KAAK,CAAC,6EAA6E,CAAC;EAClG;EACA,MAAMO,YAAY,GAAGhB,mCAAmC,CAACW,WAAW,CAAC;EACrE,IAAIK,YAAY,EAAE;IACd,MAAMA,YAAY;EACtB,CAAC,MACI;IACD,IAAI;MACAhB,mCAAmC,CAACW,WAAW,CAAC,GAAGD,UAAU,CAACO,KAAK,CAACV,OAAO,CAAC;MAC5E,MAAMP,mCAAmC,CAACW,WAAW,CAAC;IAC1D,CAAC,SACO;MACJ,OAAOX,mCAAmC,CAACW,WAAW,CAAC;IAC3D;EACJ;EACA,OAAOD,UAAU;AACrB,CAAC;AACD;AACA,MAAMI,sBAAsB,GAAGA,CAACI,WAAW,EAAEZ,OAAO,KAAK;EACrD,IAAI,CAACA,OAAO,EACR;EACJ,MAAMa,UAAU,GAAG,CAAC,GAAGb,OAAO,CAAC,CAACc,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EAChD,UAAAC,MAAA,CAAUJ,WAAW,gBAAAI,MAAA,CAAaH,UAAU;AAChD,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}