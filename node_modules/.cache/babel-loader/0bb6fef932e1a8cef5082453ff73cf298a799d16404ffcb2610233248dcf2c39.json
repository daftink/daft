{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport React, { Fragment } from 'react';\nimport { getIsFirstUnreadMessage, isDateSeparatorMessage, isIntroMessage } from './utils';\nimport { Message } from '../Message';\nimport { DateSeparator as DefaultDateSeparator } from '../DateSeparator';\nimport { EventComponent as DefaultMessageSystem } from '../EventComponent';\nimport { UnreadMessagesSeparator as DefaultUnreadMessagesSeparator } from './UnreadMessagesSeparator';\nexport function defaultRenderMessages(_ref) {\n  let {\n    channelUnreadUiState,\n    components,\n    customClasses,\n    lastReceivedMessageId: lastReceivedId,\n    messageGroupStyles,\n    messages,\n    readData,\n    sharedMessageProps: messageProps\n  } = _ref;\n  const {\n    DateSeparator = DefaultDateSeparator,\n    HeaderComponent,\n    MessageSystem = DefaultMessageSystem,\n    UnreadMessagesSeparator = DefaultUnreadMessagesSeparator\n  } = components;\n  const renderedMessages = [];\n  let firstMessage;\n  let previousMessage = undefined;\n  for (let index = 0; index < messages.length; index++) {\n    const message = messages[index];\n    if (isDateSeparatorMessage(message)) {\n      renderedMessages.push(React.createElement(\"li\", {\n        key: \"\".concat(message.date.toISOString(), \"-i\")\n      }, React.createElement(DateSeparator, {\n        date: message.date,\n        formatDate: messageProps.formatDate,\n        unread: message.unread\n      })));\n    } else if (isIntroMessage(message)) {\n      if (HeaderComponent) {\n        renderedMessages.push(React.createElement(\"li\", {\n          key: 'intro'\n        }, React.createElement(HeaderComponent, null)));\n      }\n    } else if (message.type === 'system') {\n      renderedMessages.push(React.createElement(\"li\", {\n        \"data-message-id\": message.id,\n        key: message.id || message.created_at.toISOString()\n      }, React.createElement(MessageSystem, {\n        message: message\n      })));\n    } else {\n      var _firstMessage;\n      if (!firstMessage) {\n        firstMessage = message;\n      }\n      const groupStyles = messageGroupStyles[message.id] || '';\n      const messageClass = (customClasses === null || customClasses === void 0 ? void 0 : customClasses.message) || \"str-chat__li str-chat__li--\".concat(groupStyles);\n      const isFirstUnreadMessage = getIsFirstUnreadMessage({\n        firstUnreadMessageId: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.first_unread_message_id,\n        isFirstMessage: !!((_firstMessage = firstMessage) !== null && _firstMessage !== void 0 && _firstMessage.id) && firstMessage.id === message.id,\n        lastReadDate: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.last_read,\n        lastReadMessageId: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.last_read_message_id,\n        message,\n        previousMessage,\n        unreadMessageCount: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages\n      });\n      renderedMessages.push(React.createElement(Fragment, {\n        key: message.id || message.created_at.toISOString()\n      }, isFirstUnreadMessage && UnreadMessagesSeparator && React.createElement(\"li\", {\n        className: 'str-chat__li str-chat__unread-messages-separator-wrapper'\n      }, React.createElement(UnreadMessagesSeparator, {\n        unreadCount: channelUnreadUiState === null || channelUnreadUiState === void 0 ? void 0 : channelUnreadUiState.unread_messages\n      })), React.createElement(\"li\", {\n        className: messageClass,\n        \"data-message-id\": message.id,\n        \"data-testid\": messageClass\n      }, React.createElement(Message, _objectSpread({\n        groupStyles: [groupStyles],\n        lastReceivedId: lastReceivedId,\n        message: message,\n        readBy: readData[message.id] || []\n      }, messageProps)))));\n      previousMessage = message;\n    }\n  }\n  return renderedMessages;\n}","map":{"version":3,"names":["React","Fragment","getIsFirstUnreadMessage","isDateSeparatorMessage","isIntroMessage","Message","DateSeparator","DefaultDateSeparator","EventComponent","DefaultMessageSystem","UnreadMessagesSeparator","DefaultUnreadMessagesSeparator","defaultRenderMessages","_ref","channelUnreadUiState","components","customClasses","lastReceivedMessageId","lastReceivedId","messageGroupStyles","messages","readData","sharedMessageProps","messageProps","HeaderComponent","MessageSystem","renderedMessages","firstMessage","previousMessage","undefined","index","length","message","push","createElement","key","concat","date","toISOString","formatDate","unread","type","id","created_at","_firstMessage","groupStyles","messageClass","isFirstUnreadMessage","firstUnreadMessageId","first_unread_message_id","isFirstMessage","lastReadDate","last_read","lastReadMessageId","last_read_message_id","unreadMessageCount","unread_messages","className","unreadCount","_objectSpread","readBy"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MessageList/renderMessages.js"],"sourcesContent":["import React, { Fragment } from 'react';\nimport { getIsFirstUnreadMessage, isDateSeparatorMessage, isIntroMessage } from './utils';\nimport { Message } from '../Message';\nimport { DateSeparator as DefaultDateSeparator } from '../DateSeparator';\nimport { EventComponent as DefaultMessageSystem } from '../EventComponent';\nimport { UnreadMessagesSeparator as DefaultUnreadMessagesSeparator } from './UnreadMessagesSeparator';\nexport function defaultRenderMessages({ channelUnreadUiState, components, customClasses, lastReceivedMessageId: lastReceivedId, messageGroupStyles, messages, readData, sharedMessageProps: messageProps, }) {\n    const { DateSeparator = DefaultDateSeparator, HeaderComponent, MessageSystem = DefaultMessageSystem, UnreadMessagesSeparator = DefaultUnreadMessagesSeparator, } = components;\n    const renderedMessages = [];\n    let firstMessage;\n    let previousMessage = undefined;\n    for (let index = 0; index < messages.length; index++) {\n        const message = messages[index];\n        if (isDateSeparatorMessage(message)) {\n            renderedMessages.push(React.createElement(\"li\", { key: `${message.date.toISOString()}-i` },\n                React.createElement(DateSeparator, { date: message.date, formatDate: messageProps.formatDate, unread: message.unread })));\n        }\n        else if (isIntroMessage(message)) {\n            if (HeaderComponent) {\n                renderedMessages.push(React.createElement(\"li\", { key: 'intro' },\n                    React.createElement(HeaderComponent, null)));\n            }\n        }\n        else if (message.type === 'system') {\n            renderedMessages.push(React.createElement(\"li\", { \"data-message-id\": message.id, key: message.id || message.created_at.toISOString() },\n                React.createElement(MessageSystem, { message: message })));\n        }\n        else {\n            if (!firstMessage) {\n                firstMessage = message;\n            }\n            const groupStyles = messageGroupStyles[message.id] || '';\n            const messageClass = customClasses?.message || `str-chat__li str-chat__li--${groupStyles}`;\n            const isFirstUnreadMessage = getIsFirstUnreadMessage({\n                firstUnreadMessageId: channelUnreadUiState?.first_unread_message_id,\n                isFirstMessage: !!firstMessage?.id && firstMessage.id === message.id,\n                lastReadDate: channelUnreadUiState?.last_read,\n                lastReadMessageId: channelUnreadUiState?.last_read_message_id,\n                message,\n                previousMessage,\n                unreadMessageCount: channelUnreadUiState?.unread_messages,\n            });\n            renderedMessages.push(React.createElement(Fragment, { key: message.id || message.created_at.toISOString() },\n                isFirstUnreadMessage && UnreadMessagesSeparator && (React.createElement(\"li\", { className: 'str-chat__li str-chat__unread-messages-separator-wrapper' },\n                    React.createElement(UnreadMessagesSeparator, { unreadCount: channelUnreadUiState?.unread_messages }))),\n                React.createElement(\"li\", { className: messageClass, \"data-message-id\": message.id, \"data-testid\": messageClass },\n                    React.createElement(Message, { groupStyles: [groupStyles], lastReceivedId: lastReceivedId, message: message, readBy: readData[message.id] || [], ...messageProps }))));\n            previousMessage = message;\n        }\n    }\n    return renderedMessages;\n}\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,QAAQ,QAAQ,OAAO;AACvC,SAASC,uBAAuB,EAAEC,sBAAsB,EAAEC,cAAc,QAAQ,SAAS;AACzF,SAASC,OAAO,QAAQ,YAAY;AACpC,SAASC,aAAa,IAAIC,oBAAoB,QAAQ,kBAAkB;AACxE,SAASC,cAAc,IAAIC,oBAAoB,QAAQ,mBAAmB;AAC1E,SAASC,uBAAuB,IAAIC,8BAA8B,QAAQ,2BAA2B;AACrG,OAAO,SAASC,qBAAqBA,CAAAC,IAAA,EAAwK;EAAA,IAAvK;IAAEC,oBAAoB;IAAEC,UAAU;IAAEC,aAAa;IAAEC,qBAAqB,EAAEC,cAAc;IAAEC,kBAAkB;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,kBAAkB,EAAEC;EAAc,CAAC,GAAAV,IAAA;EACvM,MAAM;IAAEP,aAAa,GAAGC,oBAAoB;IAAEiB,eAAe;IAAEC,aAAa,GAAGhB,oBAAoB;IAAEC,uBAAuB,GAAGC;EAAgC,CAAC,GAAGI,UAAU;EAC7K,MAAMW,gBAAgB,GAAG,EAAE;EAC3B,IAAIC,YAAY;EAChB,IAAIC,eAAe,GAAGC,SAAS;EAC/B,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGV,QAAQ,CAACW,MAAM,EAAED,KAAK,EAAE,EAAE;IAClD,MAAME,OAAO,GAAGZ,QAAQ,CAACU,KAAK,CAAC;IAC/B,IAAI3B,sBAAsB,CAAC6B,OAAO,CAAC,EAAE;MACjCN,gBAAgB,CAACO,IAAI,CAACjC,KAAK,CAACkC,aAAa,CAAC,IAAI,EAAE;QAAEC,GAAG,KAAAC,MAAA,CAAKJ,OAAO,CAACK,IAAI,CAACC,WAAW,CAAC,CAAC;MAAK,CAAC,EACtFtC,KAAK,CAACkC,aAAa,CAAC5B,aAAa,EAAE;QAAE+B,IAAI,EAAEL,OAAO,CAACK,IAAI;QAAEE,UAAU,EAAEhB,YAAY,CAACgB,UAAU;QAAEC,MAAM,EAAER,OAAO,CAACQ;MAAO,CAAC,CAAC,CAAC,CAAC;IACjI,CAAC,MACI,IAAIpC,cAAc,CAAC4B,OAAO,CAAC,EAAE;MAC9B,IAAIR,eAAe,EAAE;QACjBE,gBAAgB,CAACO,IAAI,CAACjC,KAAK,CAACkC,aAAa,CAAC,IAAI,EAAE;UAAEC,GAAG,EAAE;QAAQ,CAAC,EAC5DnC,KAAK,CAACkC,aAAa,CAACV,eAAe,EAAE,IAAI,CAAC,CAAC,CAAC;MACpD;IACJ,CAAC,MACI,IAAIQ,OAAO,CAACS,IAAI,KAAK,QAAQ,EAAE;MAChCf,gBAAgB,CAACO,IAAI,CAACjC,KAAK,CAACkC,aAAa,CAAC,IAAI,EAAE;QAAE,iBAAiB,EAAEF,OAAO,CAACU,EAAE;QAAEP,GAAG,EAAEH,OAAO,CAACU,EAAE,IAAIV,OAAO,CAACW,UAAU,CAACL,WAAW,CAAC;MAAE,CAAC,EAClItC,KAAK,CAACkC,aAAa,CAACT,aAAa,EAAE;QAAEO,OAAO,EAAEA;MAAQ,CAAC,CAAC,CAAC,CAAC;IAClE,CAAC,MACI;MAAA,IAAAY,aAAA;MACD,IAAI,CAACjB,YAAY,EAAE;QACfA,YAAY,GAAGK,OAAO;MAC1B;MACA,MAAMa,WAAW,GAAG1B,kBAAkB,CAACa,OAAO,CAACU,EAAE,CAAC,IAAI,EAAE;MACxD,MAAMI,YAAY,GAAG,CAAA9B,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAEgB,OAAO,mCAAAI,MAAA,CAAkCS,WAAW,CAAE;MAC1F,MAAME,oBAAoB,GAAG7C,uBAAuB,CAAC;QACjD8C,oBAAoB,EAAElC,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEmC,uBAAuB;QACnEC,cAAc,EAAE,CAAC,GAAAN,aAAA,GAACjB,YAAY,cAAAiB,aAAA,eAAZA,aAAA,CAAcF,EAAE,KAAIf,YAAY,CAACe,EAAE,KAAKV,OAAO,CAACU,EAAE;QACpES,YAAY,EAAErC,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEsC,SAAS;QAC7CC,iBAAiB,EAAEvC,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEwC,oBAAoB;QAC7DtB,OAAO;QACPJ,eAAe;QACf2B,kBAAkB,EAAEzC,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAE0C;MAC9C,CAAC,CAAC;MACF9B,gBAAgB,CAACO,IAAI,CAACjC,KAAK,CAACkC,aAAa,CAACjC,QAAQ,EAAE;QAAEkC,GAAG,EAAEH,OAAO,CAACU,EAAE,IAAIV,OAAO,CAACW,UAAU,CAACL,WAAW,CAAC;MAAE,CAAC,EACvGS,oBAAoB,IAAIrC,uBAAuB,IAAKV,KAAK,CAACkC,aAAa,CAAC,IAAI,EAAE;QAAEuB,SAAS,EAAE;MAA2D,CAAC,EACnJzD,KAAK,CAACkC,aAAa,CAACxB,uBAAuB,EAAE;QAAEgD,WAAW,EAAE5C,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAE0C;MAAgB,CAAC,CAAC,CAAE,EAC1GxD,KAAK,CAACkC,aAAa,CAAC,IAAI,EAAE;QAAEuB,SAAS,EAAEX,YAAY;QAAE,iBAAiB,EAAEd,OAAO,CAACU,EAAE;QAAE,aAAa,EAAEI;MAAa,CAAC,EAC7G9C,KAAK,CAACkC,aAAa,CAAC7B,OAAO,EAAAsD,aAAA;QAAId,WAAW,EAAE,CAACA,WAAW,CAAC;QAAE3B,cAAc,EAAEA,cAAc;QAAEc,OAAO,EAAEA,OAAO;QAAE4B,MAAM,EAAEvC,QAAQ,CAACW,OAAO,CAACU,EAAE,CAAC,IAAI;MAAE,GAAKnB,YAAY,CAAE,CAAC,CAAC,CAAC,CAAC;MAC9KK,eAAe,GAAGI,OAAO;IAC7B;EACJ;EACA,OAAON,gBAAgB;AAC3B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}