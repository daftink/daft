{"ast":null,"code":"import { useChannelStateContext } from '../../../../context';\nimport { useEffect, useRef, useState } from 'react';\nimport { MESSAGE_LIST_MAIN_PANEL_CLASS } from '../../MessageListMainPanel';\nimport { UNREAD_MESSAGE_SEPARATOR_CLASS } from '../../UnreadMessagesSeparator';\nconst targetScrolledAboveVisibleContainerArea = element => {\n  const {\n    bottom: targetBottom\n  } = element.getBoundingClientRect();\n  return targetBottom < 0;\n};\nconst targetScrolledBelowVisibleContainerArea = (element, container) => {\n  const {\n    top: targetTop\n  } = element.getBoundingClientRect();\n  const {\n    top: containerBottom\n  } = container.getBoundingClientRect();\n  return targetTop > containerBottom;\n};\nexport const useUnreadMessagesNotification = _ref => {\n  let {\n    isMessageListScrolledToBottom,\n    showAlways,\n    unreadCount\n  } = _ref;\n  const {\n    messages\n  } = useChannelStateContext('UnreadMessagesNotification');\n  const [show, setShow] = useState(false);\n  const isScrolledAboveTargetTop = useRef(false);\n  const intersectionObserverIsSupported = typeof IntersectionObserver !== 'undefined';\n  useEffect(() => {\n    if (!(unreadCount && intersectionObserverIsSupported)) {\n      setShow(false);\n      return;\n    }\n    const [msgListPanel] = document.getElementsByClassName(MESSAGE_LIST_MAIN_PANEL_CLASS);\n    if (!msgListPanel) return;\n    const [observedTarget] = document.getElementsByClassName(UNREAD_MESSAGE_SEPARATOR_CLASS);\n    if (!observedTarget) {\n      setShow(true);\n      return;\n    }\n    const scrolledBelowSeparator = targetScrolledAboveVisibleContainerArea(observedTarget);\n    const scrolledAboveSeparator = targetScrolledBelowVisibleContainerArea(observedTarget, msgListPanel);\n    setShow(showAlways ? scrolledBelowSeparator || scrolledAboveSeparator : scrolledBelowSeparator);\n    const observer = new IntersectionObserver(elements => {\n      if (!elements.length) return;\n      const {\n        boundingClientRect,\n        isIntersecting\n      } = elements[0];\n      if (isIntersecting) {\n        setShow(false);\n        return;\n      }\n      const separatorIsAboveContainerTop = boundingClientRect.bottom < 0;\n      setShow(showAlways || separatorIsAboveContainerTop);\n      isScrolledAboveTargetTop.current = separatorIsAboveContainerTop;\n    }, {\n      root: msgListPanel\n    });\n    observer.observe(observedTarget);\n    return () => {\n      observer.disconnect();\n    };\n  }, [intersectionObserverIsSupported, isMessageListScrolledToBottom, messages, showAlways, unreadCount]);\n  useEffect(() => {\n    /**\n     * Handle situation when scrollToBottom is called from another component when the msg list is scrolled above the observed target (unread separator).\n     * The intersection observer is not triggered when Element.scrollTo() is called. So we end up in a situation when we are scrolled to the bottom\n     * and at the same time scrolled above the observed target.\n     */\n    if (unreadCount && isMessageListScrolledToBottom && isScrolledAboveTargetTop.current) {\n      setShow(true);\n      isScrolledAboveTargetTop.current = false;\n    }\n  }, [isMessageListScrolledToBottom, unreadCount]);\n  return {\n    show: show && intersectionObserverIsSupported\n  };\n};","map":{"version":3,"names":["useChannelStateContext","useEffect","useRef","useState","MESSAGE_LIST_MAIN_PANEL_CLASS","UNREAD_MESSAGE_SEPARATOR_CLASS","targetScrolledAboveVisibleContainerArea","element","bottom","targetBottom","getBoundingClientRect","targetScrolledBelowVisibleContainerArea","container","top","targetTop","containerBottom","useUnreadMessagesNotification","_ref","isMessageListScrolledToBottom","showAlways","unreadCount","messages","show","setShow","isScrolledAboveTargetTop","intersectionObserverIsSupported","IntersectionObserver","msgListPanel","document","getElementsByClassName","observedTarget","scrolledBelowSeparator","scrolledAboveSeparator","observer","elements","length","boundingClientRect","isIntersecting","separatorIsAboveContainerTop","current","root","observe","disconnect"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MessageList/hooks/MessageList/useUnreadMessagesNotification.js"],"sourcesContent":["import { useChannelStateContext } from '../../../../context';\nimport { useEffect, useRef, useState } from 'react';\nimport { MESSAGE_LIST_MAIN_PANEL_CLASS } from '../../MessageListMainPanel';\nimport { UNREAD_MESSAGE_SEPARATOR_CLASS } from '../../UnreadMessagesSeparator';\nconst targetScrolledAboveVisibleContainerArea = (element) => {\n    const { bottom: targetBottom } = element.getBoundingClientRect();\n    return targetBottom < 0;\n};\nconst targetScrolledBelowVisibleContainerArea = (element, container) => {\n    const { top: targetTop } = element.getBoundingClientRect();\n    const { top: containerBottom } = container.getBoundingClientRect();\n    return targetTop > containerBottom;\n};\nexport const useUnreadMessagesNotification = ({ isMessageListScrolledToBottom, showAlways, unreadCount, }) => {\n    const { messages } = useChannelStateContext('UnreadMessagesNotification');\n    const [show, setShow] = useState(false);\n    const isScrolledAboveTargetTop = useRef(false);\n    const intersectionObserverIsSupported = typeof IntersectionObserver !== 'undefined';\n    useEffect(() => {\n        if (!(unreadCount && intersectionObserverIsSupported)) {\n            setShow(false);\n            return;\n        }\n        const [msgListPanel] = document.getElementsByClassName(MESSAGE_LIST_MAIN_PANEL_CLASS);\n        if (!msgListPanel)\n            return;\n        const [observedTarget] = document.getElementsByClassName(UNREAD_MESSAGE_SEPARATOR_CLASS);\n        if (!observedTarget) {\n            setShow(true);\n            return;\n        }\n        const scrolledBelowSeparator = targetScrolledAboveVisibleContainerArea(observedTarget);\n        const scrolledAboveSeparator = targetScrolledBelowVisibleContainerArea(observedTarget, msgListPanel);\n        setShow(showAlways\n            ? scrolledBelowSeparator || scrolledAboveSeparator\n            : scrolledBelowSeparator);\n        const observer = new IntersectionObserver((elements) => {\n            if (!elements.length)\n                return;\n            const { boundingClientRect, isIntersecting } = elements[0];\n            if (isIntersecting) {\n                setShow(false);\n                return;\n            }\n            const separatorIsAboveContainerTop = boundingClientRect.bottom < 0;\n            setShow(showAlways || separatorIsAboveContainerTop);\n            isScrolledAboveTargetTop.current = separatorIsAboveContainerTop;\n        }, { root: msgListPanel });\n        observer.observe(observedTarget);\n        return () => {\n            observer.disconnect();\n        };\n    }, [\n        intersectionObserverIsSupported,\n        isMessageListScrolledToBottom,\n        messages,\n        showAlways,\n        unreadCount,\n    ]);\n    useEffect(() => {\n        /**\n         * Handle situation when scrollToBottom is called from another component when the msg list is scrolled above the observed target (unread separator).\n         * The intersection observer is not triggered when Element.scrollTo() is called. So we end up in a situation when we are scrolled to the bottom\n         * and at the same time scrolled above the observed target.\n         */\n        if (unreadCount &&\n            isMessageListScrolledToBottom &&\n            isScrolledAboveTargetTop.current) {\n            setShow(true);\n            isScrolledAboveTargetTop.current = false;\n        }\n    }, [isMessageListScrolledToBottom, unreadCount]);\n    return { show: show && intersectionObserverIsSupported };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}