{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport React from 'react';\nimport ReactMarkdown, { defaultUrlTransform } from 'react-markdown';\nimport { find } from 'linkifyjs';\nimport uniqBy from 'lodash.uniqby';\nimport remarkGfm from 'remark-gfm';\nimport { Anchor, Emoji, Mention } from './componentRenderers';\nimport { detectHttp, escapeRegExp, matchMarkdownLinks, messageCodeBlocks } from './regex';\nimport { emojiMarkdownPlugin, mentionsMarkdownPlugin } from './rehypePlugins';\nimport { htmlToTextPlugin, keepLineBreaksPlugin } from './remarkPlugins';\nimport { ErrorBoundary } from '../../UtilityComponents';\nexport const defaultAllowedTagNames = ['html', 'text', 'br', 'p', 'em', 'strong', 'a', 'ol', 'ul', 'li', 'code', 'pre', 'blockquote', 'del', 'table', 'thead', 'tbody', 'th', 'tr', 'td', 'tfoot',\n// custom types (tagNames)\n'emoji', 'mention'];\nfunction formatUrlForDisplay(url) {\n  try {\n    return decodeURIComponent(url).replace(detectHttp, '');\n  } catch (e) {\n    return url;\n  }\n}\nfunction encodeDecode(url) {\n  try {\n    return encodeURI(decodeURIComponent(url));\n  } catch (error) {\n    return url;\n  }\n}\nconst urlTransform = uri => uri.startsWith('app://') ? uri : defaultUrlTransform(uri);\nconst getPluginsForward = plugins => plugins;\nexport const markDownRenderers = {\n  a: Anchor,\n  emoji: Emoji,\n  mention: Mention\n};\nexport const renderText = function (text, mentionedUsers) {\n  let {\n    allowedTagNames = defaultAllowedTagNames,\n    customMarkDownRenderers,\n    getRehypePlugins = getPluginsForward,\n    getRemarkPlugins = getPluginsForward\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // take the @ mentions and turn them into markdown?\n  // translate links\n  if (!text) return null;\n  if (text.trim().length === 1) return React.createElement(React.Fragment, null, text);\n  let newText = text;\n  const markdownLinks = matchMarkdownLinks(newText);\n  const codeBlocks = messageCodeBlocks(newText);\n  // extract all valid links/emails within text and replace it with proper markup\n  uniqBy([...find(newText, 'email'), ...find(newText, 'url')], 'value').forEach(_ref => {\n    let {\n      href,\n      type,\n      value\n    } = _ref;\n    const linkIsInBlock = codeBlocks.some(block => block === null || block === void 0 ? void 0 : block.includes(value));\n    // check if message is already  markdown\n    const noParsingNeeded = markdownLinks && markdownLinks.filter(text => {\n      const strippedHref = href === null || href === void 0 ? void 0 : href.replace(detectHttp, '');\n      const strippedText = text === null || text === void 0 ? void 0 : text.replace(detectHttp, '');\n      if (!strippedHref || !strippedText) return false;\n      return strippedHref.includes(strippedText) || strippedText.includes(strippedHref);\n    });\n    if (noParsingNeeded.length > 0 || linkIsInBlock) return;\n    try {\n      // special case for mentions:\n      // it could happen that a user's name matches with an e-mail format pattern.\n      // in that case, we check whether the found e-mail is actually a mention\n      // by naively checking for an existence of @ sign in front of it.\n      if (type === 'email' && mentionedUsers) {\n        const emailMatchesWithName = mentionedUsers.some(u => u.name === value);\n        if (emailMatchesWithName) {\n          newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), (match, position) => {\n            const isMention = newText.charAt(position - 1) === '@';\n            // in case of mention, we leave the match in its original form,\n            // and we let `mentionsMarkdownPlugin` to do its job\n            return isMention ? match : \"[\".concat(match, \"](\").concat(encodeDecode(href), \")\");\n          });\n          return;\n        }\n      }\n      const displayLink = type === 'email' ? value : formatUrlForDisplay(href);\n      newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), \"[\".concat(displayLink, \"](\").concat(encodeDecode(href), \")\"));\n    } catch (e) {\n      void e;\n    }\n  });\n  const remarkPlugins = [htmlToTextPlugin, keepLineBreaksPlugin, [remarkGfm, {\n    singleTilde: false\n  }]];\n  const rehypePlugins = [emojiMarkdownPlugin];\n  if (mentionedUsers !== null && mentionedUsers !== void 0 && mentionedUsers.length) {\n    rehypePlugins.push(mentionsMarkdownPlugin(mentionedUsers));\n  }\n  return React.createElement(ErrorBoundary, {\n    fallback: React.createElement(React.Fragment, null, text)\n  }, React.createElement(ReactMarkdown, {\n    allowedElements: allowedTagNames,\n    components: _objectSpread(_objectSpread({}, markDownRenderers), customMarkDownRenderers),\n    rehypePlugins: getRehypePlugins(rehypePlugins),\n    remarkPlugins: getRemarkPlugins(remarkPlugins),\n    skipHtml: true,\n    unwrapDisallowed: true,\n    urlTransform: urlTransform\n  }, newText));\n};","map":{"version":3,"names":["React","ReactMarkdown","defaultUrlTransform","find","uniqBy","remarkGfm","Anchor","Emoji","Mention","detectHttp","escapeRegExp","matchMarkdownLinks","messageCodeBlocks","emojiMarkdownPlugin","mentionsMarkdownPlugin","htmlToTextPlugin","keepLineBreaksPlugin","ErrorBoundary","defaultAllowedTagNames","formatUrlForDisplay","url","decodeURIComponent","replace","e","encodeDecode","encodeURI","error","urlTransform","uri","startsWith","getPluginsForward","plugins","markDownRenderers","a","emoji","mention","renderText","text","mentionedUsers","allowedTagNames","customMarkDownRenderers","getRehypePlugins","getRemarkPlugins","arguments","length","undefined","trim","createElement","Fragment","newText","markdownLinks","codeBlocks","forEach","_ref","href","type","value","linkIsInBlock","some","block","includes","noParsingNeeded","filter","strippedHref","strippedText","emailMatchesWithName","u","name","RegExp","match","position","isMention","charAt","concat","displayLink","remarkPlugins","singleTilde","rehypePlugins","push","fallback","allowedElements","components","_objectSpread","skipHtml","unwrapDisallowed"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/Message/renderText/renderText.js"],"sourcesContent":["import React from 'react';\nimport ReactMarkdown, { defaultUrlTransform } from 'react-markdown';\nimport { find } from 'linkifyjs';\nimport uniqBy from 'lodash.uniqby';\nimport remarkGfm from 'remark-gfm';\nimport { Anchor, Emoji, Mention } from './componentRenderers';\nimport { detectHttp, escapeRegExp, matchMarkdownLinks, messageCodeBlocks } from './regex';\nimport { emojiMarkdownPlugin, mentionsMarkdownPlugin } from './rehypePlugins';\nimport { htmlToTextPlugin, keepLineBreaksPlugin } from './remarkPlugins';\nimport { ErrorBoundary } from '../../UtilityComponents';\nexport const defaultAllowedTagNames = [\n    'html',\n    'text',\n    'br',\n    'p',\n    'em',\n    'strong',\n    'a',\n    'ol',\n    'ul',\n    'li',\n    'code',\n    'pre',\n    'blockquote',\n    'del',\n    'table',\n    'thead',\n    'tbody',\n    'th',\n    'tr',\n    'td',\n    'tfoot',\n    // custom types (tagNames)\n    'emoji',\n    'mention',\n];\nfunction formatUrlForDisplay(url) {\n    try {\n        return decodeURIComponent(url).replace(detectHttp, '');\n    }\n    catch (e) {\n        return url;\n    }\n}\nfunction encodeDecode(url) {\n    try {\n        return encodeURI(decodeURIComponent(url));\n    }\n    catch (error) {\n        return url;\n    }\n}\nconst urlTransform = (uri) => uri.startsWith('app://') ? uri : defaultUrlTransform(uri);\nconst getPluginsForward = (plugins) => plugins;\nexport const markDownRenderers = {\n    a: Anchor,\n    emoji: Emoji,\n    mention: Mention,\n};\nexport const renderText = (text, mentionedUsers, { allowedTagNames = defaultAllowedTagNames, customMarkDownRenderers, getRehypePlugins = getPluginsForward, getRemarkPlugins = getPluginsForward, } = {}) => {\n    // take the @ mentions and turn them into markdown?\n    // translate links\n    if (!text)\n        return null;\n    if (text.trim().length === 1)\n        return React.createElement(React.Fragment, null, text);\n    let newText = text;\n    const markdownLinks = matchMarkdownLinks(newText);\n    const codeBlocks = messageCodeBlocks(newText);\n    // extract all valid links/emails within text and replace it with proper markup\n    uniqBy([...find(newText, 'email'), ...find(newText, 'url')], 'value').forEach(({ href, type, value }) => {\n        const linkIsInBlock = codeBlocks.some((block) => block?.includes(value));\n        // check if message is already  markdown\n        const noParsingNeeded = markdownLinks &&\n            markdownLinks.filter((text) => {\n                const strippedHref = href?.replace(detectHttp, '');\n                const strippedText = text?.replace(detectHttp, '');\n                if (!strippedHref || !strippedText)\n                    return false;\n                return (strippedHref.includes(strippedText) || strippedText.includes(strippedHref));\n            });\n        if (noParsingNeeded.length > 0 || linkIsInBlock)\n            return;\n        try {\n            // special case for mentions:\n            // it could happen that a user's name matches with an e-mail format pattern.\n            // in that case, we check whether the found e-mail is actually a mention\n            // by naively checking for an existence of @ sign in front of it.\n            if (type === 'email' && mentionedUsers) {\n                const emailMatchesWithName = mentionedUsers.some((u) => u.name === value);\n                if (emailMatchesWithName) {\n                    newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), (match, position) => {\n                        const isMention = newText.charAt(position - 1) === '@';\n                        // in case of mention, we leave the match in its original form,\n                        // and we let `mentionsMarkdownPlugin` to do its job\n                        return isMention ? match : `[${match}](${encodeDecode(href)})`;\n                    });\n                    return;\n                }\n            }\n            const displayLink = type === 'email' ? value : formatUrlForDisplay(href);\n            newText = newText.replace(new RegExp(escapeRegExp(value), 'g'), `[${displayLink}](${encodeDecode(href)})`);\n        }\n        catch (e) {\n            void e;\n        }\n    });\n    const remarkPlugins = [\n        htmlToTextPlugin,\n        keepLineBreaksPlugin,\n        [remarkGfm, { singleTilde: false }],\n    ];\n    const rehypePlugins = [emojiMarkdownPlugin];\n    if (mentionedUsers?.length) {\n        rehypePlugins.push(mentionsMarkdownPlugin(mentionedUsers));\n    }\n    return (React.createElement(ErrorBoundary, { fallback: React.createElement(React.Fragment, null, text) },\n        React.createElement(ReactMarkdown, { allowedElements: allowedTagNames, components: {\n                ...markDownRenderers,\n                ...customMarkDownRenderers,\n            }, rehypePlugins: getRehypePlugins(rehypePlugins), remarkPlugins: getRemarkPlugins(remarkPlugins), skipHtml: true, unwrapDisallowed: true, urlTransform: urlTransform }, newText)));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}