{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport React, { useCallback, useContext, useEffect, useMemo, useRef } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport clsx from 'clsx';\nimport { useMessageInputContext, useTranslationContext } from '../../context';\nimport { useAttachmentManagerState, useMessageComposer } from './hooks';\nimport { useStateStore } from '../../store';\nconst DragAndDropUploadContext = React.createContext({\n  subscribeToDrop: null\n});\nexport const useDragAndDropUploadContext = () => useContext(DragAndDropUploadContext);\n/**\n * @private This hook should be used only once directly in the `MessageInputProvider` to\n * register `uploadNewFiles` functions of the rendered `MessageInputs`. Each `MessageInput`\n * will then be notified when the drop event occurs from within the `WithDragAndDropUpload`\n * component.\n */\nexport const useRegisterDropHandlers = () => {\n  const {\n    subscribeToDrop\n  } = useDragAndDropUploadContext();\n  const messageComposer = useMessageComposer();\n  useEffect(() => {\n    const unsubscribe = subscribeToDrop === null || subscribeToDrop === void 0 ? void 0 : subscribeToDrop(messageComposer.attachmentManager.uploadFiles);\n    return unsubscribe;\n  }, [subscribeToDrop, messageComposer]);\n};\nconst attachmentManagerConfigStateSelector = state => ({\n  acceptedFiles: state.attachments.acceptedFiles,\n  multipleUploads: state.attachments.maxNumberOfFilesPerMessage > 1\n});\n/**\n * Wrapper to replace now deprecated `Channel.dragAndDropWindow` option.\n *\n * @example\n * ```tsx\n * <Channel>\n *  <WithDragAndDropUpload component=\"section\" className=\"message-list-dnd-wrapper\">\n *    <Window>\n *      <MessageList />\n *      <MessageInput />\n *    </Window>\n *  </WithDragAndDropUpload>\n *  <Thread />\n * <Channel>\n * ```\n */\nexport const WithDragAndDropUpload = _ref => {\n  var _messageInputContext$;\n  let {\n    children,\n    className,\n    component: Component = 'div',\n    style\n  } = _ref;\n  const dropHandlersRef = useRef(new Set());\n  const {\n    t\n  } = useTranslationContext();\n  const messageInputContext = useMessageInputContext();\n  const dragAndDropUploadContext = useDragAndDropUploadContext();\n  const messageComposer = useMessageComposer();\n  const {\n    isUploadEnabled\n  } = useAttachmentManagerState();\n  const {\n    acceptedFiles,\n    multipleUploads\n  } = useStateStore(messageComposer.configState, attachmentManagerConfigStateSelector);\n  // if message input context is available, there's no need to use the queue\n  const isWithinMessageInputContext = Object.keys(messageInputContext).length > 0;\n  const accept = useMemo(() => acceptedFiles.reduce((mediaTypeMap, mediaType) => {\n    var _mediaTypeMap$mediaTy;\n    (_mediaTypeMap$mediaTy = mediaTypeMap[mediaType]) !== null && _mediaTypeMap$mediaTy !== void 0 ? _mediaTypeMap$mediaTy : mediaTypeMap[mediaType] = [];\n    return mediaTypeMap;\n  }, {}), [acceptedFiles]);\n  const subscribeToDrop = useCallback(fn => {\n    dropHandlersRef.current.add(fn);\n    return () => {\n      dropHandlersRef.current.delete(fn);\n    };\n  }, []);\n  const handleDrop = useCallback(files => {\n    dropHandlersRef.current.forEach(fn => fn(files));\n  }, []);\n  const {\n    getRootProps,\n    isDragActive,\n    isDragReject\n  } = useDropzone({\n    accept,\n    // apply `disabled` rules if available, otherwise allow anything and\n    // let the `uploadNewFiles` handle the limitations internally\n    disabled: isWithinMessageInputContext ? !isUploadEnabled || ((_messageInputContext$ = messageInputContext.cooldownRemaining) !== null && _messageInputContext$ !== void 0 ? _messageInputContext$ : 0) > 0 : false,\n    multiple: multipleUploads,\n    noClick: true,\n    onDrop: isWithinMessageInputContext ? messageComposer.attachmentManager.uploadFiles : handleDrop\n  });\n  // nested WithDragAndDropUpload components render wrappers without functionality\n  // (MessageInputFlat has a default WithDragAndDropUpload)\n  if (dragAndDropUploadContext.subscribeToDrop !== null) {\n    return React.createElement(Component, {\n      className: className\n    }, children);\n  }\n  return React.createElement(DragAndDropUploadContext.Provider, {\n    value: {\n      subscribeToDrop\n    }\n  }, React.createElement(Component, _objectSpread({}, getRootProps({\n    className,\n    style\n  })), isDragActive && React.createElement(\"div\", {\n    className: clsx('str-chat__dropzone-container', {\n      'str-chat__dropzone-container--not-accepted': isDragReject\n    })\n  }, !isDragReject && React.createElement(\"p\", null, t('Drag your files here')), isDragReject && React.createElement(\"p\", null, t('Some of the files will not be accepted'))), children));\n};","map":{"version":3,"names":["React","useCallback","useContext","useEffect","useMemo","useRef","useDropzone","clsx","useMessageInputContext","useTranslationContext","useAttachmentManagerState","useMessageComposer","useStateStore","DragAndDropUploadContext","createContext","subscribeToDrop","useDragAndDropUploadContext","useRegisterDropHandlers","messageComposer","unsubscribe","attachmentManager","uploadFiles","attachmentManagerConfigStateSelector","state","acceptedFiles","attachments","multipleUploads","maxNumberOfFilesPerMessage","WithDragAndDropUpload","_ref","_messageInputContext$","children","className","component","Component","style","dropHandlersRef","Set","t","messageInputContext","dragAndDropUploadContext","isUploadEnabled","configState","isWithinMessageInputContext","Object","keys","length","accept","reduce","mediaTypeMap","mediaType","_mediaTypeMap$mediaTy","fn","current","add","delete","handleDrop","files","forEach","getRootProps","isDragActive","isDragReject","disabled","cooldownRemaining","multiple","noClick","onDrop","createElement","Provider","value","_objectSpread"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MessageInput/WithDragAndDropUpload.js"],"sourcesContent":["import React, { useCallback, useContext, useEffect, useMemo, useRef } from 'react';\nimport { useDropzone } from 'react-dropzone';\nimport clsx from 'clsx';\nimport { useMessageInputContext, useTranslationContext } from '../../context';\nimport { useAttachmentManagerState, useMessageComposer } from './hooks';\nimport { useStateStore } from '../../store';\nconst DragAndDropUploadContext = React.createContext({\n    subscribeToDrop: null,\n});\nexport const useDragAndDropUploadContext = () => useContext(DragAndDropUploadContext);\n/**\n * @private This hook should be used only once directly in the `MessageInputProvider` to\n * register `uploadNewFiles` functions of the rendered `MessageInputs`. Each `MessageInput`\n * will then be notified when the drop event occurs from within the `WithDragAndDropUpload`\n * component.\n */\nexport const useRegisterDropHandlers = () => {\n    const { subscribeToDrop } = useDragAndDropUploadContext();\n    const messageComposer = useMessageComposer();\n    useEffect(() => {\n        const unsubscribe = subscribeToDrop?.(messageComposer.attachmentManager.uploadFiles);\n        return unsubscribe;\n    }, [subscribeToDrop, messageComposer]);\n};\nconst attachmentManagerConfigStateSelector = (state) => ({\n    acceptedFiles: state.attachments.acceptedFiles,\n    multipleUploads: state.attachments.maxNumberOfFilesPerMessage > 1,\n});\n/**\n * Wrapper to replace now deprecated `Channel.dragAndDropWindow` option.\n *\n * @example\n * ```tsx\n * <Channel>\n *  <WithDragAndDropUpload component=\"section\" className=\"message-list-dnd-wrapper\">\n *    <Window>\n *      <MessageList />\n *      <MessageInput />\n *    </Window>\n *  </WithDragAndDropUpload>\n *  <Thread />\n * <Channel>\n * ```\n */\nexport const WithDragAndDropUpload = ({ children, className, component: Component = 'div', style, }) => {\n    const dropHandlersRef = useRef(new Set());\n    const { t } = useTranslationContext();\n    const messageInputContext = useMessageInputContext();\n    const dragAndDropUploadContext = useDragAndDropUploadContext();\n    const messageComposer = useMessageComposer();\n    const { isUploadEnabled } = useAttachmentManagerState();\n    const { acceptedFiles, multipleUploads } = useStateStore(messageComposer.configState, attachmentManagerConfigStateSelector);\n    // if message input context is available, there's no need to use the queue\n    const isWithinMessageInputContext = Object.keys(messageInputContext).length > 0;\n    const accept = useMemo(() => acceptedFiles.reduce((mediaTypeMap, mediaType) => {\n        mediaTypeMap[mediaType] ?? (mediaTypeMap[mediaType] = []);\n        return mediaTypeMap;\n    }, {}), [acceptedFiles]);\n    const subscribeToDrop = useCallback((fn) => {\n        dropHandlersRef.current.add(fn);\n        return () => {\n            dropHandlersRef.current.delete(fn);\n        };\n    }, []);\n    const handleDrop = useCallback((files) => {\n        dropHandlersRef.current.forEach((fn) => fn(files));\n    }, []);\n    const { getRootProps, isDragActive, isDragReject } = useDropzone({\n        accept,\n        // apply `disabled` rules if available, otherwise allow anything and\n        // let the `uploadNewFiles` handle the limitations internally\n        disabled: isWithinMessageInputContext\n            ? !isUploadEnabled || (messageInputContext.cooldownRemaining ?? 0) > 0\n            : false,\n        multiple: multipleUploads,\n        noClick: true,\n        onDrop: isWithinMessageInputContext\n            ? messageComposer.attachmentManager.uploadFiles\n            : handleDrop,\n    });\n    // nested WithDragAndDropUpload components render wrappers without functionality\n    // (MessageInputFlat has a default WithDragAndDropUpload)\n    if (dragAndDropUploadContext.subscribeToDrop !== null) {\n        return React.createElement(Component, { className: className }, children);\n    }\n    return (React.createElement(DragAndDropUploadContext.Provider, { value: {\n            subscribeToDrop,\n        } },\n        React.createElement(Component, { ...getRootProps({ className, style }) },\n            isDragActive && (React.createElement(\"div\", { className: clsx('str-chat__dropzone-container', {\n                    'str-chat__dropzone-container--not-accepted': isDragReject,\n                }) },\n                !isDragReject && React.createElement(\"p\", null, t('Drag your files here')),\n                isDragReject && React.createElement(\"p\", null, t('Some of the files will not be accepted')))),\n            children)));\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}