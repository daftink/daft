{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport uniqBy from 'lodash.uniqby';\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\nimport { useChatContext } from '../../../context/ChatContext';\nimport { DEFAULT_INITIAL_CHANNEL_PAGE_SIZE } from '../../../constants/limits';\nconst RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 5000;\nconst MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 2000;\nexport const usePaginatedChannels = function (client, filters, sort, options, activeChannelHandler) {\n  let recoveryThrottleIntervalMs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS;\n  let customQueryChannels = arguments.length > 6 ? arguments[6] : undefined;\n  const {\n    channelsQueryState: {\n      error,\n      setError,\n      setQueryInProgress\n    }\n  } = useChatContext('usePaginatedChannels');\n  const [channels, setChannels] = useState([]);\n  const [hasNextPage, setHasNextPage] = useState(true);\n  const lastRecoveryTimestamp = useRef(undefined);\n  const recoveryThrottleInterval = recoveryThrottleIntervalMs < MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS ? MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS : recoveryThrottleIntervalMs !== null && recoveryThrottleIntervalMs !== void 0 ? recoveryThrottleIntervalMs : RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS;\n  // memoize props\n  const filterString = useMemo(() => JSON.stringify(filters), [filters]);\n  const sortString = useMemo(() => JSON.stringify(sort), [sort]);\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const queryChannels = async function () {\n    let queryType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'load-more';\n    setError(null);\n    if (queryType === 'reload') {\n      setChannels([]);\n    }\n    setQueryInProgress(queryType);\n    try {\n      if (customQueryChannels) {\n        await customQueryChannels({\n          currentChannels: channels,\n          queryType: queryType,\n          setChannels,\n          setHasNextPage\n        });\n      } else {\n        var _options$limit, _options$message_limi;\n        const offset = queryType === 'reload' ? 0 : channels.length;\n        const newOptions = _objectSpread({\n          limit: (_options$limit = options === null || options === void 0 ? void 0 : options.limit) !== null && _options$limit !== void 0 ? _options$limit : MAX_QUERY_CHANNELS_LIMIT,\n          message_limit: (_options$message_limi = options === null || options === void 0 ? void 0 : options.message_limit) !== null && _options$message_limi !== void 0 ? _options$message_limi : DEFAULT_INITIAL_CHANNEL_PAGE_SIZE,\n          offset\n        }, options);\n        const channelQueryResponse = await client.queryChannels(filters, sort || {}, newOptions);\n        const newChannels = queryType === 'reload' ? channelQueryResponse : uniqBy([...channels, ...channelQueryResponse], 'cid');\n        setChannels(newChannels);\n        setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n        // Set active channel only on load of first page\n        if (!offset && activeChannelHandler) {\n          activeChannelHandler(newChannels, setChannels);\n        }\n      }\n    } catch (error) {\n      console.warn(error);\n      setError(error);\n    }\n    setQueryInProgress(null);\n  };\n  const throttleRecover = useCallback(() => {\n    const now = Date.now();\n    const isFirstRecovery = !lastRecoveryTimestamp.current;\n    const timeElapsedSinceLastRecoveryMs = lastRecoveryTimestamp.current ? now - lastRecoveryTimestamp.current : 0;\n    if (!isFirstRecovery && timeElapsedSinceLastRecoveryMs < recoveryThrottleInterval && !error) {\n      return;\n    }\n    lastRecoveryTimestamp.current = now;\n    queryChannels('reload');\n  }, [error, queryChannels, recoveryThrottleInterval]);\n  const loadNextPage = () => queryChannels();\n  useEffect(() => {\n    if (client.recoverStateOnReconnect) return;\n    const {\n      unsubscribe\n    } = client.on('connection.recovered', throttleRecover);\n    return () => {\n      unsubscribe();\n    };\n  }, [client, throttleRecover]);\n  useEffect(() => {\n    queryChannels('reload');\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [filterString, sortString]);\n  return {\n    channels,\n    hasNextPage,\n    loadNextPage,\n    setChannels\n  };\n};","map":{"version":3,"names":["useCallback","useEffect","useMemo","useRef","useState","uniqBy","MAX_QUERY_CHANNELS_LIMIT","useChatContext","DEFAULT_INITIAL_CHANNEL_PAGE_SIZE","RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS","MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS","usePaginatedChannels","client","filters","sort","options","activeChannelHandler","recoveryThrottleIntervalMs","arguments","length","undefined","customQueryChannels","channelsQueryState","error","setError","setQueryInProgress","channels","setChannels","hasNextPage","setHasNextPage","lastRecoveryTimestamp","recoveryThrottleInterval","filterString","JSON","stringify","sortString","queryChannels","queryType","currentChannels","_options$limit","_options$message_limi","offset","newOptions","_objectSpread","limit","message_limit","channelQueryResponse","newChannels","console","warn","throttleRecover","now","Date","isFirstRecovery","current","timeElapsedSinceLastRecoveryMs","loadNextPage","recoverStateOnReconnect","unsubscribe","on"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/ChannelList/hooks/usePaginatedChannels.js"],"sourcesContent":["import { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport uniqBy from 'lodash.uniqby';\nimport { MAX_QUERY_CHANNELS_LIMIT } from '../utils';\nimport { useChatContext } from '../../../context/ChatContext';\nimport { DEFAULT_INITIAL_CHANNEL_PAGE_SIZE } from '../../../constants/limits';\nconst RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 5000;\nconst MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 2000;\nexport const usePaginatedChannels = (client, filters, sort, options, activeChannelHandler, recoveryThrottleIntervalMs = RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS, customQueryChannels) => {\n    const { channelsQueryState: { error, setError, setQueryInProgress }, } = useChatContext('usePaginatedChannels');\n    const [channels, setChannels] = useState([]);\n    const [hasNextPage, setHasNextPage] = useState(true);\n    const lastRecoveryTimestamp = useRef(undefined);\n    const recoveryThrottleInterval = recoveryThrottleIntervalMs < MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS\n        ? MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS\n        : (recoveryThrottleIntervalMs ?? RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS);\n    // memoize props\n    const filterString = useMemo(() => JSON.stringify(filters), [filters]);\n    const sortString = useMemo(() => JSON.stringify(sort), [sort]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const queryChannels = async (queryType = 'load-more') => {\n        setError(null);\n        if (queryType === 'reload') {\n            setChannels([]);\n        }\n        setQueryInProgress(queryType);\n        try {\n            if (customQueryChannels) {\n                await customQueryChannels({\n                    currentChannels: channels,\n                    queryType: queryType,\n                    setChannels,\n                    setHasNextPage,\n                });\n            }\n            else {\n                const offset = queryType === 'reload' ? 0 : channels.length;\n                const newOptions = {\n                    limit: options?.limit ?? MAX_QUERY_CHANNELS_LIMIT,\n                    message_limit: options?.message_limit ?? DEFAULT_INITIAL_CHANNEL_PAGE_SIZE,\n                    offset,\n                    ...options,\n                };\n                const channelQueryResponse = await client.queryChannels(filters, sort || {}, newOptions);\n                const newChannels = queryType === 'reload'\n                    ? channelQueryResponse\n                    : uniqBy([...channels, ...channelQueryResponse], 'cid');\n                setChannels(newChannels);\n                setHasNextPage(channelQueryResponse.length >= newOptions.limit);\n                // Set active channel only on load of first page\n                if (!offset && activeChannelHandler) {\n                    activeChannelHandler(newChannels, setChannels);\n                }\n            }\n        }\n        catch (error) {\n            console.warn(error);\n            setError(error);\n        }\n        setQueryInProgress(null);\n    };\n    const throttleRecover = useCallback(() => {\n        const now = Date.now();\n        const isFirstRecovery = !lastRecoveryTimestamp.current;\n        const timeElapsedSinceLastRecoveryMs = lastRecoveryTimestamp.current\n            ? now - lastRecoveryTimestamp.current\n            : 0;\n        if (!isFirstRecovery &&\n            timeElapsedSinceLastRecoveryMs < recoveryThrottleInterval &&\n            !error) {\n            return;\n        }\n        lastRecoveryTimestamp.current = now;\n        queryChannels('reload');\n    }, [error, queryChannels, recoveryThrottleInterval]);\n    const loadNextPage = () => queryChannels();\n    useEffect(() => {\n        if (client.recoverStateOnReconnect)\n            return;\n        const { unsubscribe } = client.on('connection.recovered', throttleRecover);\n        return () => {\n            unsubscribe();\n        };\n    }, [client, throttleRecover]);\n    useEffect(() => {\n        queryChannels('reload');\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [filterString, sortString]);\n    return {\n        channels,\n        hasNextPage,\n        loadNextPage,\n        setChannels,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}