{"ast":null,"code":"import _objectSpread from \"/tmp/daft-chat-temp/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { useEffect } from 'react';\nimport { useChannelActionContext, useChannelStateContext, useChatContext } from '../../../context';\nconst hasReadLastMessage = (channel, userId) => {\n  var _channel$state$latest, _channel$state$read$u;\n  const latestMessageIdInChannel = (_channel$state$latest = channel.state.latestMessages.slice(-1)[0]) === null || _channel$state$latest === void 0 ? void 0 : _channel$state$latest.id;\n  const lastReadMessageIdServer = (_channel$state$read$u = channel.state.read[userId]) === null || _channel$state$read$u === void 0 ? void 0 : _channel$state$read$u.last_read_message_id;\n  return latestMessageIdInChannel === lastReadMessageIdServer;\n};\n/**\n * Takes care of marking a channel read. The channel is read only if all the following applies:\n * 1. the message list is not rendered in a thread\n * 2. the message list is scrolled to the bottom\n * 3. the channel was not marked unread by the user\n * @param isMessageListScrolledToBottom\n * @param messageListIsThread\n * @param wasChannelMarkedUnread\n */\nexport const useMarkRead = _ref => {\n  let {\n    isMessageListScrolledToBottom,\n    messageListIsThread,\n    wasMarkedUnread\n  } = _ref;\n  const {\n    client\n  } = useChatContext('useMarkRead');\n  const {\n    markRead,\n    setChannelUnreadUiState\n  } = useChannelActionContext('useMarkRead');\n  const {\n    channel\n  } = useChannelStateContext('useMarkRead');\n  useEffect(() => {\n    const shouldMarkRead = () => {\n      var _client$user;\n      return !document.hidden && !wasMarkedUnread && !messageListIsThread && isMessageListScrolledToBottom && ((_client$user = client.user) === null || _client$user === void 0 ? void 0 : _client$user.id) && !hasReadLastMessage(channel, client.user.id);\n    };\n    const onVisibilityChange = () => {\n      if (shouldMarkRead()) markRead();\n    };\n    const handleMessageNew = event => {\n      var _event$message, _event$message2;\n      const mainChannelUpdated = !((_event$message = event.message) !== null && _event$message !== void 0 && _event$message.parent_id) || ((_event$message2 = event.message) === null || _event$message2 === void 0 ? void 0 : _event$message2.show_in_channel);\n      if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {\n        setChannelUnreadUiState(prev => {\n          var _prev$unread_messages, _prev$last_read;\n          const previousUnreadCount = (_prev$unread_messages = prev === null || prev === void 0 ? void 0 : prev.unread_messages) !== null && _prev$unread_messages !== void 0 ? _prev$unread_messages : 0;\n          const previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);\n          return _objectSpread(_objectSpread({}, prev || {}), {}, {\n            last_read: (_prev$last_read = prev === null || prev === void 0 ? void 0 : prev.last_read) !== null && _prev$last_read !== void 0 ? _prev$last_read : previousUnreadCount === 0 && previousLastMessage !== null && previousLastMessage !== void 0 && previousLastMessage.created_at ? new Date(previousLastMessage.created_at) : new Date(0),\n            // not having information about the last read message means the whole channel is unread,\n            unread_messages: previousUnreadCount + 1\n          });\n        });\n      } else if (mainChannelUpdated && shouldMarkRead()) {\n        markRead();\n      }\n    };\n    channel.on('message.new', handleMessageNew);\n    document.addEventListener('visibilitychange', onVisibilityChange);\n    if (shouldMarkRead()) {\n      markRead();\n    }\n    return () => {\n      channel.off('message.new', handleMessageNew);\n      document.removeEventListener('visibilitychange', onVisibilityChange);\n    };\n  }, [channel, client, isMessageListScrolledToBottom, markRead, messageListIsThread, setChannelUnreadUiState, wasMarkedUnread]);\n};\nfunction getPreviousLastMessage(messages, newMessage) {\n  if (!newMessage) return;\n  let previousLastMessage;\n  for (let i = messages.length - 1; i >= 0; i--) {\n    const msg = messages[i];\n    if (!(msg !== null && msg !== void 0 && msg.id)) break;\n    if (msg.id !== newMessage.id) {\n      previousLastMessage = msg;\n      break;\n    }\n  }\n  return previousLastMessage;\n}","map":{"version":3,"names":["useEffect","useChannelActionContext","useChannelStateContext","useChatContext","hasReadLastMessage","channel","userId","_channel$state$latest","_channel$state$read$u","latestMessageIdInChannel","state","latestMessages","slice","id","lastReadMessageIdServer","read","last_read_message_id","useMarkRead","_ref","isMessageListScrolledToBottom","messageListIsThread","wasMarkedUnread","client","markRead","setChannelUnreadUiState","shouldMarkRead","_client$user","document","hidden","user","onVisibilityChange","handleMessageNew","event","_event$message","_event$message2","mainChannelUpdated","message","parent_id","show_in_channel","prev","_prev$unread_messages","_prev$last_read","previousUnreadCount","unread_messages","previousLastMessage","getPreviousLastMessage","messages","_objectSpread","last_read","created_at","Date","on","addEventListener","off","removeEventListener","newMessage","i","length","msg"],"sources":["/tmp/daft-chat-temp/node_modules/stream-chat-react/dist/components/MessageList/hooks/useMarkRead.js"],"sourcesContent":["import { useEffect } from 'react';\nimport { useChannelActionContext, useChannelStateContext, useChatContext, } from '../../../context';\nconst hasReadLastMessage = (channel, userId) => {\n    const latestMessageIdInChannel = channel.state.latestMessages.slice(-1)[0]?.id;\n    const lastReadMessageIdServer = channel.state.read[userId]?.last_read_message_id;\n    return latestMessageIdInChannel === lastReadMessageIdServer;\n};\n/**\n * Takes care of marking a channel read. The channel is read only if all the following applies:\n * 1. the message list is not rendered in a thread\n * 2. the message list is scrolled to the bottom\n * 3. the channel was not marked unread by the user\n * @param isMessageListScrolledToBottom\n * @param messageListIsThread\n * @param wasChannelMarkedUnread\n */\nexport const useMarkRead = ({ isMessageListScrolledToBottom, messageListIsThread, wasMarkedUnread, }) => {\n    const { client } = useChatContext('useMarkRead');\n    const { markRead, setChannelUnreadUiState } = useChannelActionContext('useMarkRead');\n    const { channel } = useChannelStateContext('useMarkRead');\n    useEffect(() => {\n        const shouldMarkRead = () => !document.hidden &&\n            !wasMarkedUnread &&\n            !messageListIsThread &&\n            isMessageListScrolledToBottom &&\n            client.user?.id &&\n            !hasReadLastMessage(channel, client.user.id);\n        const onVisibilityChange = () => {\n            if (shouldMarkRead())\n                markRead();\n        };\n        const handleMessageNew = (event) => {\n            const mainChannelUpdated = !event.message?.parent_id || event.message?.show_in_channel;\n            if (!isMessageListScrolledToBottom || wasMarkedUnread || document.hidden) {\n                setChannelUnreadUiState((prev) => {\n                    const previousUnreadCount = prev?.unread_messages ?? 0;\n                    const previousLastMessage = getPreviousLastMessage(channel.state.messages, event.message);\n                    return {\n                        ...(prev || {}),\n                        last_read: prev?.last_read ??\n                            (previousUnreadCount === 0 && previousLastMessage?.created_at\n                                ? new Date(previousLastMessage.created_at)\n                                : new Date(0)), // not having information about the last read message means the whole channel is unread,\n                        unread_messages: previousUnreadCount + 1,\n                    };\n                });\n            }\n            else if (mainChannelUpdated && shouldMarkRead()) {\n                markRead();\n            }\n        };\n        channel.on('message.new', handleMessageNew);\n        document.addEventListener('visibilitychange', onVisibilityChange);\n        if (shouldMarkRead()) {\n            markRead();\n        }\n        return () => {\n            channel.off('message.new', handleMessageNew);\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n        };\n    }, [\n        channel,\n        client,\n        isMessageListScrolledToBottom,\n        markRead,\n        messageListIsThread,\n        setChannelUnreadUiState,\n        wasMarkedUnread,\n    ]);\n};\nfunction getPreviousLastMessage(messages, newMessage) {\n    if (!newMessage)\n        return;\n    let previousLastMessage;\n    for (let i = messages.length - 1; i >= 0; i--) {\n        const msg = messages[i];\n        if (!msg?.id)\n            break;\n        if (msg.id !== newMessage.id) {\n            previousLastMessage = msg;\n            break;\n        }\n    }\n    return previousLastMessage;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}